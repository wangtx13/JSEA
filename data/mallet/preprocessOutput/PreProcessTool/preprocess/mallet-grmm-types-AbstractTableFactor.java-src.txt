2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types gnu trove t hash map io i o io input stream io output stream general utils types maths randoms a multivariate multinomial <p > created mon sep 15 17 19 24 2003 author <a href= mailto casutton > charles sutton< a> $ table factor v 1 1 2007 10 22 21 37 44 exp $ table factor discrete factor maps all variable to an that says which dimension in probs matrix correspands to that var universe universe = universe d e f a u l t var set vars number variables in potential num vars reordering map sizes passed sizes sorted matrix probs table factor bidirectional map var map init vars var map set identity init vars bidirectional map all vars init vars arrays list all vars to init vars variable vars passed sizes passed = vars passed length sizes sorted = vars passed length reordering map = vars passed length variable all vars = vars passed clone vars = hash var set arrays list all vars vars = universe arrays list all vars arrays sort all vars store mapping between order in which variables were given and canonically sorted order we are storing them in and set sizes i = 0 i < all vars length i++ variable var = vars get i var continuous illegal argument attempt to create table over continous variable +all vars i sizes sorted i = var get num outcomes j = 0 vars passed j != var j++ reordering map j = i sizes passed j = vars get i get num outcomes probs = matrixn sizes sorted probs num locations == 0 err warning empty potential created num vars = all vars length init vars collection all vars init vars variable all vars to variable all vars size set probs prob prob length != probs num locations shouldn t be a runtime so sue me runtime attempt to initialize potential bad number probabilities + needed + probs num locations + got + prob length i = 0 i < prob length i++ indices passed = sizes passed length matrixn single to indices i indices passed sizes passed indices sorted = sizes passed length j = 0 j < sizes passed length j++ indices sorted j = indices passed reordering map j single index sorted = matrixn single index sizes sorted indices sorted probs set value at location single index sorted prob i creates an identity potential over given variable table factor variable var init vars variable var set identity table factor variable var values init vars variable var set probs values creates an identity potential over n o variables table factor init vars variable set identity creates an identity potential given variables table factor variable all vars init vars all vars set identity creates an identity potential given variables all vars a collection containing variables table factor collection all vars init vars all vars set identity creates a potential given variables and given probabilities all vars variables potential probs all phi values potential in row major order table factor variable all vars probs init vars all vars set probs probs creates a potential given variables and given probabilities all vars variables potential probs all phi values potential in row major order table factor bidirectional map all vars probs init vars all vars set probs probs creates a potential given variables and given probabilities all vars variables potential probs all phi values potential in row major order table factor var set all vars probs init vars all vars to variable set probs probs creates a potential given variables and given probabilities all vars variables potential probs in all phi values potential table factor variable all vars matrix probs in init vars all vars probs = matrix probs in clone matrix creates a potential given variables and given probabilities all vars variables potential probs in all phi values potential table factor bidirectional map all vars matrix probs in init vars all vars probs = matrix probs in clone matrix copy constructor table factor table factor in xxx could be dangerous! but these should never be modified vars = in vars num vars = in num vars in projection cache == in initialize projection cache projection cache = in projection cache creates a potential given variables and given probabilities all vars variables potential probs in all phi values potential table factor var set all vars matrix probs in init vars all vars to variable probs = matrix probs in clone matrix creates a potential same variables another but different probabilites ptl probs table factor table factor ptl probs ptl vars probs s t a t i f a t o r y m e t h o d s factor make identity factor table factor copy table factor copy vars set all val i = 0 i < probs num locations i++ probs set single value i val a b s t r a t m e t h o d s forces potential to be identity all 1s set identity factor duplicate factor normalize sum table factor create blank subset variable vars table factor create blank subset collection vars create blank subset variable vars to variable vars size get num vars num vars inherently dangerous b variable ordering issues consider using set phi assignment instead set values matrix probs probs single size != probs single size unsupported operation trying to reset prob matrix wrong number probabilities previous num probs + probs single size + num probs +probs single size probs get num dimensions != probs get num dimensions unsupported operation trying to reset prob matrix wrong number dimensions probs = probs iff potential over given variable contains var variable var vars contains var set variables in potential var set var set unmodifiable var set vars assignment iterator assignment iterator probs sparse matrixn idxs = sparse matrixn probs get indices idxs != sparse assignment iterator vars idxs dense assignment iterator vars set raw value assignment assn value indices = num vars i = 0 i < num vars i++ variable var = get variable i indices i = assn get var probs set value indices value set raw value assignment iterator it value probs set single value it index current assn value set raw value loc value probs set single value loc value value assignment assn special function to normalization in log space computes sum potential in log space logsum math log probs one norm entropy h = 0 p assignment iterator it = assignment iterator it has next p = log value it ! infinite p h = p math exp p it advance h p r o j e t i o n o f i n d i e s maps potentials > be careful about thing however it gets shallow copied whenever a potential duplicated so a potential were modified e g expand to contain was being shared things could get ugly i think everything all right at moment but keep it in mind inexplicable bugs show up in future cas t hash map projection cache lazily constructed initialize projection cache projection cache = universe lookup projection cache var set a hash value subsets potential s variable set note that hash value depends only on set s membership not its order so that hashing scheme would be unsafe projection cache unless potential variables were always in a canonical order which they are compute subset hash value discrete factor subset potentials have more than 32 variables we need to use an expandable bitset but then again you probably wouldn t have enough memory to represent potential anyway get num vars <= 32 result = 0 num vars = subset var set size lrgi = 0 relies on variables being sorted smi = 0 smi < num vars smi++ var = subset get variable smi loop breaks subset not in fact a subset but that an anyway var != get variable lrgi lrgi++ result |= 1 << lrgi result below i tried special casing small potential num vars == 1 projection = probs single size large dims = num vars variable small var = variable small potential var map lookup 0 large dim = var map lookup index small var large dim != 1 small var large idx = 0 large idx < probs single size large idx++ probs single to indices large idx large dims projection large idx = large dims large dim projection but didn t seem to make a huge performance gain compute large idx to small discrete factor small potential large idx to small large idx multinomial potential small potential projection = probs num locations large dims = num vars small num vars = small potential var set size small dims = small num vars large loc = 0 large loc < probs num locations large loc++ large idx = probs index at location large loc probs single to indices large idx large dims relies on variables being sorted large dim = 0 small dim = 0 small dim < small num vars small dim++ variable small var = small potential get variable small dim small var != get variable large dim large dim++ small dims small dim = large dims large dim projection large loc = small potential single index small dims projection large idx to small discrete factor small potential cachedlarge idx to small large idx multinomial potential small potential projection cache == initialize projection cache special where small ptl has only one variable here since ordering not a problem we can use a set based hash key cached large idx to small small potential small potential var set size == 1 cached large idx to small small potential compute large idx to small small potential cached compute large idx to small ptls a single variable designed to work small potential has multiple variables but it breaks it s called two potentials same variables in different orders t o d o make work multiple variables canonical ordering? cached large idx to small discrete factor small potential hashval = compute subset hash value small potential ints = projection cache get hashval ints != ints projection = compute large idx to small small potential projection cache put hashval projection projection marginal over given variables factor marginalize variable vars var set contains all arrays list vars perhaps instead marginalize internal create blank subset vars factor marginalize collection vars var set contains all vars perhaps instead marginalize internal create blank subset vars factor marginalize variable var var set contains var perhaps instead marginalize internal create blank subset variable var factor marginalize out variable var set vars = hash var set vars vars remove var marginalize internal create blank subset vars factor marginalize out var set bad vars set vars = hash var set vars vars remove bad vars marginalize internal create blank subset vars factor marginalize internal table factor result factor extract max variable var extract max internal create blank subset variable var factor extract max variable vars extract max internal create blank subset vars factor extract max collection vars extract max internal create blank subset vars factor extract max internal table factor result result set all n e g a t i v e i n f i n i t y projection = large idx to small result add each element single large potential to correct element in small potential large loc = 0 large loc < probs num locations large loc++ convert a single index from to one smaller small idx = projection large loc whew! now add it in large value = probs value at location large loc small value = result probs single value small idx large value > small value result probs set value at location small idx large value result expand to contain discrete factor pot so expand potential not pretty needs to expand var set pot var set var set var set = hash var set var set var set add all pot var set table factor ptl = create blank subset var set ptl multiply internal vars = ptl vars probs = ptl probs num vars = ptl num vars initialize projection cache needs to expand var set mine var set his size h = his size vi m = 0 vi h = 0 variable var h var m vi m < num vars vi h < size h var m = mine get vi m var h = his get vi h vi m++ var m == var h vi h++ vi h < size h does conceptual equivalent = pot assumes that pot s variables are a subset potential s multiply factor pot pot discrete factor discrete factor factor = discrete factor pot expand to contain factor factor = ensure operand compatible factor multiply internal factor pot constant factor times equals pot value assignment table factor tbl tbl = pot table unsupported operation e unsupported operation t know how to multiply +this+ +pot multiply tbl ensures that <tt>this in log space == ptl in log space< tt> not a copy ptl logified or delogified appropriate ptl a potential equivalent to ptl possibly logified or delogified ptl itself could be discrete factor ensure operand compatible discrete factor ptl ptl does destructive multiplication on assuming has all variables in pot multiply internal discrete factor ptl plus equals internal discrete factor ptl elementwise product potential and another one factor multiply factor dist factor result = duplicate result multiply dist result does conceptual equivalent = pot assumes that pot s variables are a subset potential s divide factor pot pot discrete factor discrete factor pot1 = discrete factor pot cheating expand to contain pot1 pot1 = ensure operand compatible pot1 divide internal pot1 pot constant factor times equals 1 0 pot value assignment table factor tbl tbl = pot table unsupported operation e unsupported operation t know how to multiply +this+ +pot multiply tbl does destructive divison on assuming has all variables in pot divide internal discrete factor ptl xxx should an assignment argmax best idx = 0 best val = probs single value 0 idx = 1 idx < probs num locations idx++ val = probs single value idx val > best val best val = val best idx = idx best idx e p s = 1e 5 assignment sample randoms r loc = sample location r location2assignment loc assignment location2assignment loc dense assignment iterator vars loc assignment sample location randoms r sum = sum sampled = r next uniform sum cum = 0 idx = 0 idx < probs num locations idx++ val = value idx cum += val sampled <= cum + e p s idx runtime internal errors couldn t sample from potential +this+ +dump to + using value +sampled almost equals factor p almost equals p maths e p s i l o n almost equals factor p epsilon ! p table factor discrete factor p2 = discrete factor p !var set contains all p2 var set !p2 var set contains all var set t o d o fold into probs almost eqauals variable ordering issues ever resolved also consider using in all those has converged functions projection = large idx to small p2 loc1 = 0 loc1 < probs num locations loc1++ idx2 = projection loc1 v1 = value at location loc1 v2 = p2 value idx2 math abs v1 v2 > epsilon clone duplicate to buffer s = buffer 1024 s append s append general utils name s append s append var set s append s to dump to buffer s = buffer 1024 s append to s append indices = num vars loc = 0 loc < probs num locations loc++ idx = probs index at location loc probs single to indices idx indices j = 0 j < num vars j++ s append indices j s append val = probs single value idx s append val s append s append sum = append sum append s to na n probs na n print values out print i = 0 i < probs num locations i++ out print probs value at location i out print out print print sizes sizes = num vars probs get dimensions sizes out print i = 0 i < num vars i++ out print sizes i + out print variable find variable name i = 0 i < get num vars i++ variable var = get variable i var get label equals name var num locations probs num locations index at location loc probs index at location loc variable get variable i vars get i serialization serial u = 1 seralization incompatible changes are made to these classes then smarts can be added to these backward compatibility write output stream out i o out write read input stream in i o not found in read rerun initializers fields projection cache = t hash map divide v probs divide equals v use discouraged set log value assignment assn log value use discouraged set log value assignment iterator assn it log value use discouraged set value assignment iterator assn it log value factor hacky mixture table factor ptl1 table factor ptl2 weight check that alphabets match ptl1 get num vars != ptl2 get num vars illegal argument i = 0 i < ptl2 get num vars i++ ptl1 get variable i != ptl2 get variable i illegal argument ptl1 ensure operand compatible ptl2 != ptl2 illegal argument table factor result = table factor ptl1 vars loc1 = 0 loc1 < ptl1 num locations loc1++ val1 = ptl1 value at location loc1 idx = ptl1 index at location loc1 val2 = ptl2 value idx result set raw value idx weight val1 + 1 weight val2 t hash set indices = t hash set loc = 0 loc < ptl1 probs num locations loc++ indices add ptl1 probs index at location loc loc = 0 loc < ptl2 probs num locations loc++ indices add ptl2 probs index at location loc idxs = indices to arrays sort idxs vals = idxs length ptl1 log table factor hack i = 0 i < idxs length i++ vals i = weight math exp ptl1 probs single value idxs i + 1 weight math exp ptl2 probs single value idxs i vals i = math log vals i i = 0 i < idxs length i++ vals i = weight ptl1 probs single value idxs i + 1 weight ptl2 probs single value idxs i szs = ptl1 probs get num dimensions ptl1 probs get dimensions szs sparse matrixn m = sparse matrixn szs idxs vals table factor result = ptl1 create blank subset ptl1 var map result set values m !ptl1 na n !ptl2 na n result na n err oops! na n in averaging p1 +ptl1 na n + p2 +ptl2 na n + result +result na n result raw value single idx to value matrix matrix = get value matrix arr = matrix num locations i = 0 i < arr length i++ arr i = matrix value at location i arr single index small dims probs single index small dims matrix get value matrix matrix get log value matrix set log values vals set values vals to log value matrix matrix = get log value matrix matrix matrixn matrixn matrix to matrix sparse matrixn sparse matrixn matrix to runtime get values matrixn get value matrix to adds a constant to all values in table most useful to add a small constant to avoid zeros plus equals v loc = 0 loc < num locations loc++ plus equals at location loc v plus equals factor f f discrete factor discrete factor factor = discrete factor f expand to contain factor factor = ensure operand compatible factor plus equals internal factor f constant factor plus equals f value assignment table factor tbl tbl = f table unsupported operation e unsupported operation t know how to add +this+ +f plus equals tbl multiplies a constant all values in table times equals v plus equals at location loc v multiplies factor constant 1 max ensures that maximum value factor 1 0 table factor recenter table factor table creates a potential that equal to one restricted to a given assignment assn variables to hold fixed a factor over v a r s factor \ v a r s assn factor slice assignment assn set intersection = var set intersection assn var set intersection empty hash var set clique = hash var set var set clique remove all arrays list assn get vars slice internal clique to variable assn factor slice internal variable vars assignment observed special speed vars length == 1 slice onevar vars 0 observed vars length == 2 slice twovar vars 0 vars 1 observed slice general vars observed factor slice onevar variable var assignment observed factor slice twovar variable v1 variable v2 assignment observed factor slice general variable vars assignment observed pretty output buffer buf = buffer iterator it = vars iterator it has next variable var = variable it next buf append var get label buf append buf append ~ table factor buf to 