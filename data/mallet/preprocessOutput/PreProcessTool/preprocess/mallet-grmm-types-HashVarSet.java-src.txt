2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types gnu trove t hash set io i o io input stream io output stream io serializable inference utils a clique a collection nodes in a graph that are all adjacent we implement it cheaply delegating to a hash set created wed sep 17 12 50 01 2003 author <a href= mailto casutton > charles sutton< a> $ hash var set v 1 1 2007 10 22 21 37 44 exp $ xxx perhaps should just use an alphabet and not implement set hash var set var set serializable t hash set verts = t hash set list verts list = list create an empty clique hash var set clique constructor create a two clique given an edge in a graph hash var set edge e add e get vertex a add e get vertex b create a clique given a collection nodes hash var set collection add all hash var set variable vars add all arrays list vars variable get idx variable verts list get idx get label to intersection two cliques var set intersection var set utils intersection delegation set to verts can t delegate to t hash map because in early versions trove that we are frozen at t hash map hash isn t consistent equals workaround which may be removed when we upgrade trove hash ret = 39 iterator it = verts list iterator it has next o = it next ret = 59 ret + o hash ret equals verts equals remove all collection collection ret = iterator it = collection iterator it has next o = it next ret = remove o ret ret variable to variable cannot just variable verts list to because that would cause a cast i suppose that s why to overloaded variable verts list to variable size delegation collection to verts to val = iterator it = iterator it has next val += val += it next to val += val add all collection collection ret = iterator it = collection iterator it has next ret = ret add it next collections sort verts list ret variables in clique an clique not modified then ordering will remain consistent across calls to using verts list here assures that to always same ordering verts list to variables in clique an clique not modified then ordering will remain consistent across calls to using verts list here assures that to always same ordering verts list to contains all collection collection verts contains all collection retain all collection collection verts retain all collection delegation hash set to verts clone verts clone add add add check sorted ! variable illegal argument to !verts contains verts list add ret = verts add check sorted collections sort verts list ret contains verts contains size verts size total size a dense discrete variable over clique weight tot = 1 i = 0 i < verts list size i++ variable var = variable verts list get i tot = var get num outcomes tot iterator iterator verts list iterator remove verts list remove verts remove clear verts list clear verts clear empty verts empty iterating over assignments assignment iterator assignment iterator dense assignment iterator serialization garbage serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write out write u r r e n t s e r i a l v e r s i o n out write size vi = 0 vi < size vi++ out write get vi read input stream in i o not found in read = in read size = in read vi = 0 vi < size vi++ variable var = variable in read add var clique 