2011 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised pr logging level logging logger r f sum lattice transducer transducer state types label alphabet types label vector types matrix ops types sequence logger sum lattice that caches dot products author gregory druck full dynamic programming forward backward sum product lattice algorithm sum lattice cached dot sum lattice logger logger = logger get logger sum lattice cached dot get name logger set level level f i n e variables acting values correspondingly named instance variables can be overridden sort like named like sum lattice lattice = sum lattice transducer input save xis=true save xis = ip == input position op == output position i == state index transducer t total weight sequence input output lattice node nodes indexed ip i lattice length gammas indexed ip i xis indexed ip i j saved only save xis label vector labelings indexed op created only output alphabet non in constructor ensure that instances cannot easily be created a zero constructor sum lattice cached dot lattice node get lattice node ip state index nodes ip state index == nodes ip state index = lattice node ip t get state state index nodes ip state index sum lattice cached dot transducer trans sequence input sequence output cached dots transducer incrementor incrementor save xis label alphabet output alphabet output == || input size == output size logger loggable level f i n e logger fine starting lattice logger fine input ip = 0 ip < input size ip++ logger fine + input get ip logger fine output output == logger fine op = 0 op < output size op++ logger fine + output get op logger fine initialize some structures t = trans input = input output = output xxx not very efficient when lattice actually sparse especially when number states large and sequence lattice length = input size +1 num states = t num states nodes = lattice node lattice length num states xxx yipes could get big something sparse might be better? gammas = lattice length num states save xis xis = lattice length num states num states output counts = output alphabet != output counts = lattice length output alphabet size i = 0 i < num states i++ ip = 0 ip < lattice length ip++ gammas ip i = transducer i m p o s s i b l e w e i g h t save xis j = 0 j < num states j++ ip = 0 ip < lattice length ip++ xis ip i j = transducer i m p o s s i b l e w e i g h t forward pass logger fine starting foward pass at least one initial state = i = 0 i < num states i++ initial weight = t get state i get initial weight out forward pass initial cost = +initial cost initial weight > transducer i m p o s s i b l e w e i g h t get lattice node 0 i alpha = initial weight out nodes 0 i alpha= +nodes 0 i alpha at least one initial state = at least one initial state == logger warning there are no starting states! ip = 0 ip < lattice length 1 ip++ i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t xxx we end up doing a lot we could save a list non ones state s = t get state i cached dot transition iterator iter = cached dot transition iterator r f state s input ip cached dots ip i logger loggable level f i n e logger fine starting foward transition iteration from state + s get name + on input + input get ip to + and output + output==null ? output get ip to iter has next state destination = iter next state logger loggable level f i n e logger fine forward lattice input pos= +ip+ source= +s get name + dest= +destination get name + lattice node destination node = get lattice node ip+1 destination get index destination node output = iter get output transition weight = iter get weight logger loggable level f i n e logger fine b e f o r e update destination node alpha= +destination node alpha destination node alpha = transducer sum log prob destination node alpha nodes ip i alpha + transition weight logger loggable level f i n e logger fine transition weight= +transition weight+ nodes +ip+ +i+ alpha= +nodes ip i alpha + destination node alpha= +destination node alpha out destination node alpha < +destination node alpha logger loggable level f i n e logger fine forward lattice ip = 0 ip < lattice length ip++ buffer sb = buffer i = 0 i < num states i++ sb append + nodes ip i == ? <null> nodes ip i alpha logger fine sb to calculate total weight lattice normalizer total weight = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes lattice length 1 i != out ending alpha state +i+ = +nodes lattice length 1 i alpha out ending beta state +i+ = +t get state i get weight total weight = transducer sum log prob total weight nodes lattice length 1 i alpha + t get state i get weight logger fine total weight= +total weight total weight now an unnormalized weight entire lattice sequence has infinite weight just usefully avoids calling any increment x it also relies on fact that gammas and alpha but not beta values are already initialized to values that reflect infinite weight t o d o it important to fill in betas before we return? total weight == transducer i m p o s s i b l e w e i g h t backward pass i = 0 i < num states i++ nodes lattice length 1 i != state s = t get state i nodes lattice length 1 i beta = s get weight gammas lattice length 1 i = nodes lattice length 1 i alpha + nodes lattice length 1 i beta total weight incrementor != p = math exp gammas lattice length 1 i gsc reducing from 1e 10 to 1e 6 gsc removing na n check range check will na n well p >= 0 0 p <= 1 0+1e 10 ! na n p p= +p+ gamma= +gammas lattice length 1 i p >= 0 0 p <= 1 0+1e 6 p= +p+ gamma= +gammas lattice length 1 i incrementor increment state s p ip = lattice length 2 ip >= 0 ip i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t note that skipping here based on alpha means that beta values won t be correct but since alpha infinite anyway it shouldn t matter state s = t get state i cached dot transition iterator iter = cached dot transition iterator r f state s input ip cached dots ip i iter has next state destination = iter next state logger loggable level f i n e logger fine backward lattice input pos= +ip+ source= +s get name + dest= +destination get name + j = destination get index lattice node destination node = nodes ip+1 j destination node != transition weight = iter get weight ! na n transition weight old beta = nodes ip i beta ! na n nodes ip i beta nodes ip i beta = transducer sum log prob nodes ip i beta destination node beta + transition weight ! na n nodes ip i beta dest beta= +destination node beta+ trans= +transition weight+ sum= + destination node beta+transition weight + old beta= +old beta xi = nodes ip i alpha + transition weight + nodes ip+1 j beta total weight save xis xis ip i j = xi ! na n nodes ip i alpha ! na n transition weight ! na n nodes ip+1 j beta ! na n total weight incrementor != || output alphabet != p = math exp xi gsc reducing from 1e 10 to 1e 6 gsc removing na n check range check will na n well p >= 0 0 p <= 1 0+1e 10 ! na n p xis +ip+ +i+ +j+ = +xi p >= 0 0 p <= 1 0+1e 6 p= +p+ xis +ip+ +i+ +j+ = +xi incrementor != incrementor increment transition iter p output alphabet != output index = output alphabet lookup index iter get output output index >= 0 xxx assumes that ip == op ! output counts ip output index += p out r f lattice output counts +ip+ +output index+ += +p gammas ip i = nodes ip i alpha + nodes ip i beta total weight incrementor != i = 0 i < num states i++ p = math exp gammas 0 i gsc reducing from 1e 10 to 1e 6 gsc removing na n check range check will na n well p >= 0 0 p <= 1 0+1e 10 ! na n p p= +p p >= 0 0 p <= 1 0+1e 6 p= +p incrementor increment initial state t get state i p output alphabet != labelings = label vector lattice length ip = lattice length 2 ip >= 0 ip math abs 1 0 matrix ops sum output counts ip < 0 000001 labelings ip = label vector output alphabet output counts ip logger loggable level f i n e logger fine lattice ip = 0 ip < lattice length ip++ buffer sb = buffer i = 0 i < num states i++ sb append +gammas ip i logger fine sb to get xis xis get gammas gammas get total weight ! na n total weight total weight get gamma weight input position state s gammas input position s get index get gamma weight input position state index gammas input position state index get gamma probability input position state s math exp gammas input position s get index get gamma probability input position state index math exp gammas input position state index get xi probability ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index math exp xis ip i j get xi weight ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index xis ip i j length lattice length sequence get input input get alpha ip state s lattice node node = get lattice node ip s get index node alpha get beta ip state s lattice node node = get lattice node ip s get index node beta label vector get labeling at position output position labelings != labelings output position transducer get transducer t a container some about a particular input position and state lattice node input position output position not really needed until we deal asymmetric epsilon state state output alpha = transducer i m p o s s i b l e w e i g h t beta = transducer i m p o s s i b l e w e i g h t lattice node input position state state input position = input position state = state alpha == transducer i m p o s s i b l e w e i g h t xxx remove check 