2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author aron culotta <a href= mailto culotta >culotta edu< a> author andrew mc callum <a href= mailto >mccallum edu< a> io io output stream io i o io input stream io output stream io serializable list hash map iterator random logging logger regex pattern types alphabet types feature sequence types instance types instance list types multinomial types sequence pipe pipe logger a hidden markov model h m m transducer serializable logger logger = logger get logger h m m get name l a b e l s e p a r a t o r = alphabet input alphabet alphabet output alphabet list< state> states = list< state> list< state> initial states = list< state> hash map< state> name2state = hash map< state> multinomial estimator transition estimator multinomial estimator emission estimator multinomial estimator initial estimator multinomial transition multinomial multinomial emission multinomial multinomial initial multinomial h m m pipe input pipe pipe output pipe input pipe = input pipe output pipe = output pipe input alphabet = input pipe get data alphabet output alphabet = input pipe get target alphabet h m m alphabet input alphabet alphabet output alphabet input alphabet stop growth logger info h m m input dictionary size = + input alphabet size input alphabet = input alphabet output alphabet = output alphabet alphabet get input alphabet input alphabet alphabet get output alphabet output alphabet multinomial get transition multinomial transition multinomial multinomial get emission multinomial emission multinomial multinomial get initial multinomial initial multinomial print buffer sb = buffer i = 0 i < num states i++ state s = state get state i sb append s t a t e n a m e=\ sb append s name sb append \ sb append s destinations length sb append outgoing transitions sb append sb append initial weight= sb append s initial weight sb append sb append sb append weight= sb append s weight sb append sb append emission + emission multinomial i + sb append transition + transition multinomial i to out sb to add state name initial weight weight destination names label names label names length == destination names length name2state get name != illegal argument state name ` + name + already state s = state name states size initial weight weight destination names label names s print states add s initial weight > i m p o s s i b l e w e i g h t initial states add s name2state put name s add a state equal zero and labels on out going arcs same name their destination state names add state name destination names add state name 0 0 destination names destination names add a group states that are fully connected each other equal zero and labels on their out going arcs same name their destination state names add fully connected states state names i = 0 i < state names length i++ add state state names i state names add fully connected states labels labels = output alphabet size assuming entries in output alphabet are strings! i = 0 i < output alphabet size i++ labels i = output alphabet lookup i add fully connected states labels label connections in instance list training set num labels = output alphabet size connections = num labels num labels instance instance training set feature sequence output = feature sequence instance get target j = 1 j < output size j++ source index = output alphabet lookup index output get j 1 dest index = output alphabet lookup index output get j source index >= 0 dest index >= 0 connections source index dest index = connections add states to create a first order markov model on labels adding only those transitions occur in given training set add states labels connected in instance list training set num labels = output alphabet size connections = label connections in training set i = 0 i < num labels i++ num destinations = 0 j = 0 j < num labels j++ connections i j num destinations++ destination names = num destinations destination index = 0 j = 0 j < num labels j++ connections i j destination names destination index++ = output alphabet lookup j add state output alphabet lookup i destination names add many states there are labels but t create separate weights each source destination pair states instead have all incoming transitions to a state share same weights add states half labels connected in instance list training set num labels = output alphabet size connections = label connections in training set i = 0 i < num labels i++ num destinations = 0 j = 0 j < num labels j++ connections i j num destinations++ destination names = num destinations destination index = 0 j = 0 j < num labels j++ connections i j destination names destination index++ = output alphabet lookup j add state output alphabet lookup i 0 0 0 0 destination names destination names add many states there are labels but t create separate observational test weights each source destination pair states instead have all incoming transitions to a state share same observational feature test weights however create separate feature each transition which acts an h m m style transition probability add states three quarter labels connected in instance list training set num labels = output alphabet size connections = label connections in training set i = 0 i < num labels i++ num destinations = 0 j = 0 j < num labels j++ connections i j num destinations++ destination names = num destinations destination index = 0 j = 0 j < num labels j++ connections i j label name = output alphabet lookup j destination names destination index = label name transition weights will include only feature gsc variable never used wn = output alphabet lookup i + > + output alphabet lookup j destination index++ add state output alphabet lookup i 0 0 0 0 destination names destination names add fully connected states three quarter labels instance list training set num labels = output alphabet size i = 0 i < num labels i++ destination names = num labels j = 0 j < num labels j++ label name = output alphabet lookup j destination names j = label name add state output alphabet lookup i 0 0 0 0 destination names destination names add fully connected states bi labels labels = output alphabet size assuming entries in output alphabet are strings! i = 0 i < output alphabet size i++ labels i = output alphabet lookup i to i = 0 i < labels length i++ j = 0 j < labels length j++ destination names = labels length k = 0 k < labels length k++ destination names k = labels j + l a b e l s e p a r a t o r + labels k add state labels i + l a b e l s e p a r a t o r + labels j 0 0 0 0 destination names labels add states to create a second order markov model on labels adding only those transitions occur in given training set add states bi labels connected in instance list training set num labels = output alphabet size connections = label connections in training set i = 0 i < num labels i++ j = 0 j < num labels j++ !connections i j num destinations = 0 k = 0 k < num labels k++ connections j k num destinations++ destination names = num destinations labels = num destinations destination index = 0 k = 0 k < num labels k++ connections j k destination names destination index = output alphabet lookup j + l a b e l s e p a r a t o r + output alphabet lookup k labels destination index = output alphabet lookup k destination index++ add state output alphabet lookup i + l a b e l s e p a r a t o r + output alphabet lookup j 0 0 0 0 destination names labels add fully connected states tri labels labels = output alphabet size assuming entries in output alphabet are strings! i = 0 i < output alphabet size i++ logger info h m m output alphabet lookup = + output alphabet lookup i get get name labels i = output alphabet lookup i to i = 0 i < labels length i++ j = 0 j < labels length j++ k = 0 k < labels length k++ destination names = labels length l = 0 l < labels length l++ destination names l = labels j + l a b e l s e p a r a t o r + labels k + l a b e l s e p a r a t o r + labels l add state labels i + l a b e l s e p a r a t o r + labels j + l a b e l s e p a r a t o r + labels k 0 0 0 0 destination names labels add self transitioning state all labels name labels = output alphabet size destination names = output alphabet size i = 0 i < output alphabet size i++ labels i = output alphabet lookup i to destination names i = name add state name 0 0 0 0 destination names labels concat labels labels sep = buffer buf = buffer i = 0 i < labels length i++ buf append sep append labels i sep = l a b e l s e p a r a t o r buf to next k gram history k next sep = buffer buf = buffer start = history length + 1 k i = start i < history length i++ buf append sep append history i sep = l a b e l s e p a r a t o r buf append sep append next buf to allowed transition prev curr pattern no pattern yes pair = concat labels prev curr no != no matcher pair matches yes != !yes matcher pair matches allowed history history pattern no pattern yes i = 1 i < history length i++ !allowed transition history i 1 history i no yes assumes that h m m s output alphabet contains <code> string< code>s creates an order <em>n< em> h m m input predicates and output labels given <code>training set< code> and order connectivity and weights given remaining arguments training set training instances orders an increasing non negative numbers giving orders features h m m largest number <em>n< em> markov order h m m states are <em>n< em> tuples output labels each other numbers <em>k< em> in <code>orders< code> represents a weight set shared all destination states whose last most recent <em>k< em> labels agree <code>orders< code> <code>null< code> an order 0 h m m built defaults non it must be same length <code>orders< code> <code>true< code> positions indicating that weight set corresponding order contains only weight a feature otherwise weight set has weights all features built from input predicates start label that represents context start a sequence it may be also used sequence labels forbidden non specifies what pairs successive labels are not allowed both constructing <em>n< em>order states or transitions a label pair <em>u< em> <em>v< em> not allowed <em>u< em> + + <em>v< em> matches <code>forbidden< code> allowed non specifies what pairs successive labels are allowed both constructing <em>n< em>order states or transitions a label pair <em>u< em> <em>v< em> allowed only <em>u< em> + + <em>v< em> matches <code>allowed< code> fully connected whether to include all allowed transitions even those not occurring in <code>training set< code> name start state add order n states instance list training set orders defaults start pattern forbidden pattern allowed fully connected connections = !fully connected connections = label connections in training set order = 1 defaults != defaults length != orders length illegal argument defaults must be or match orders orders == order = 0 i = 0 i < orders length i++ orders i <= order illegal argument orders must be non negative and in ascending order order = orders i order < 0 order = 0 order > 0 history indexes = order history = order label0 = output alphabet lookup 0 i = 0 i < order i++ history i = label0 num labels = output alphabet size history indexes 0 < num labels logger info preparing + concat labels history allowed history history forbidden allowed state name = concat labels history nt = 0 dest names = num labels label names = num labels next index = 0 next index < num labels next index++ next = output alphabet lookup next index allowed transition history order 1 next forbidden allowed fully connected || connections history indexes order 1 next index dest names nt = next k gram history order next label names nt = next nt++ nt < num labels dest names = nt label names = nt t = 0 t < nt t++ dest names t = dest names t label names t = label names t dest names = dest names label names = label names add state state name 0 0 0 0 dest names label names o = order 1 o >= 0 o ++history indexes o < num labels history o = output alphabet lookup history indexes o o > 0 history indexes o = 0 history o = label0 i = 0 i < order i++ history i = start concat labels history state names = output alphabet size s = 0 s < output alphabet size s++ state names s = output alphabet lookup s s = 0 s < output alphabet size s++ add state state names s 0 0 0 0 state names state names start state get state name state name2state get name num states states size transducer state get state index transducer state states get index iterator initial state iterator initial states iterator trainable alphabet get transition alphabet alphabet transition alphabet = alphabet i = 0 i < num states i++ transition alphabet lookup index get state i get name transition alphabet deprecated reset emission estimator = multinomial laplace estimator num states transition estimator = multinomial laplace estimator num states emission multinomial = multinomial num states transition multinomial = multinomial num states alphabet transition alphabet = get transition alphabet i = 0 i < num states i++ emission estimator i = multinomial laplace estimator input alphabet transition estimator i = multinomial laplace estimator transition alphabet emission multinomial i = multinomial get uniform input alphabet size input alphabet transition multinomial i = multinomial get uniform transition alphabet size transition alphabet initial multinomial = multinomial get uniform transition alphabet size transition alphabet initial estimator = multinomial laplace estimator transition alphabet separate initialization initial transitions and emissions all probabilities are proportional to 1+ uniform 0 1 ^noise author kedarb random random use uniform noise noise exponent to use zero then uniform init transitions random random noise alphabet transition alphabet = get transition alphabet initial multinomial = multinomial get random transition alphabet size random noise transition alphabet initial estimator = multinomial laplace estimator transition alphabet transition multinomial = multinomial num states transition estimator = multinomial laplace estimator num states i = 0 i < num states i++ transition multinomial i = multinomial get random transition alphabet size random noise transition alphabet transition estimator i = multinomial laplace estimator transition alphabet set state s initial weight state s = state get state i s set initial weight initial multinomial log probability s get name init emissions random random noise emission multinomial = multinomial num states emission estimator = multinomial laplace estimator num states i = 0 i < num states i++ emission multinomial i = multinomial get random input alphabet size random noise input alphabet emission estimator i = multinomial laplace estimator input alphabet estimate alphabet transition alphabet = get transition alphabet initial multinomial = initial estimator estimate initial estimator = multinomial laplace estimator transition alphabet i = 0 i < num states i++ state s = state get state i emission multinomial i = emission estimator i estimate transition multinomial i = transition estimator i estimate s set initial weight initial multinomial log probability s get name reset estimators emission estimator i = multinomial laplace estimator input alphabet transition estimator i = multinomial laplace estimator transition alphabet trains a h m m without validation and evaluation train instance list ilist train ilist instance list instance list trains a h m m <tt>evaluator< tt> set to train instance list ilist instance list validation instance list testing train ilist validation testing transducer evaluator train instance list ilist instance list validation instance list testing transducer evaluator eval ilist size > 0 emission estimator == emission estimator = multinomial laplace estimator num states transition estimator = multinomial laplace estimator num states emission multinomial = multinomial num states transition multinomial = multinomial num states alphabet transition alphabet = alphabet i = 0 i < num states i++ transition alphabet lookup index state states get i get name i = 0 i < num states i++ emission estimator i = multinomial laplace estimator input alphabet transition estimator i = multinomial laplace estimator transition alphabet emission multinomial i = multinomial get uniform input alphabet size input alphabet transition multinomial i = multinomial get uniform transition alphabet size transition alphabet initial estimator = multinomial laplace estimator transition alphabet instance instance ilist feature sequence input = feature sequence instance get data feature sequence output = feature sequence instance get target sum lattice input output incrementor initial multinomial = initial estimator estimate i = 0 i < num states i++ emission multinomial i = emission estimator i estimate transition multinomial i = transition estimator i estimate get state i set initial weight initial multinomial log probability get state i get name incrementor transducer incrementor increment state transducer state s count increment initial state transducer state s count initial estimator increment s get name count increment transition transducer transition iterator ti count input ftr = ti get input state src = h m m state transition iterator ti get source state state dest = h m m state transition iterator ti get destination state index = ti get index emission estimator index increment input ftr count transition estimator src get index increment dest get name count weighted incrementor transducer incrementor weight = 1 0 weighted incrementor wt weight = wt increment state transducer state s count increment initial state transducer state s count initial estimator increment s get name weight count increment transition transducer transition iterator ti count input ftr = ti get input state src = h m m state transition iterator ti get source state state dest = h m m state transition iterator ti get destination state index = ti get index emission estimator index increment input ftr weight count transition estimator src get index increment dest get name weight count write f output stream oos = output stream output stream f oos write oos close i o e err writing + f + + e get uniform size ret = size i = 0 i < size i++ gsc removing unnecessary cast from size ret i = 1 0 size ret kedarb p i = 1+random ^noise sum get random size random random noise ret = size sum = 0 i = 0 i < size i++ ret i = random == ? 1 0 math pow 1 0 + random next noise sum += ret i i = 0 i < size i++ ret i = sum ret serialization h m m serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 n u l l i n t e g e r = 1 need to check pointers bug fix from cheng ju kuo cju kuo gmail com write output stream out i o i size out write u r r e n t s e r i a l v e r s i o n out write input pipe out write output pipe out write input alphabet out write output alphabet size = states size out write size i = 0 i < size i++ out write states get i size = initial states size out write size i = 0 i < size i++ out write initial states get i out write name2state emission estimator != size = emission estimator length out write size i = 0 i < size i++ out write emission estimator i out write n u l l i n t e g e r emission multinomial != size = emission multinomial length out write size i = 0 i < size i++ out write emission multinomial i out write n u l l i n t e g e r transition estimator != size = transition estimator length out write size i = 0 i < size i++ out write transition estimator i out write n u l l i n t e g e r transition multinomial != size = transition multinomial length out write size i = 0 i < size i++ out write transition multinomial i out write n u l l i n t e g e r bug fix from cheng ju kuo cju kuo gmail com read input stream in i o not found size i = in read input pipe = pipe in read output pipe = pipe in read input alphabet = alphabet in read output alphabet = alphabet in read size = in read states = list i = 0 i < size i++ state s = h m m state in read states add s size = in read initial states = list i = 0 i < size i++ state s = h m m state in read initial states add s name2state = hash map in read size = in read size == n u l l i n t e g e r emission estimator = emission estimator = multinomial estimator size i = 0 i < size i++ emission estimator i = multinomial estimator in read size = in read size == n u l l i n t e g e r emission multinomial = emission multinomial = multinomial size i = 0 i < size i++ emission multinomial i = multinomial in read size = in read size == n u l l i n t e g e r transition estimator = transition estimator = multinomial estimator size i = 0 i < size i++ transition estimator i = multinomial estimator in read size = in read size == n u l l i n t e g e r transition multinomial = transition multinomial = multinomial size i = 0 i < size i++ transition multinomial i = multinomial in read state transducer state serializable indexed destination state feature index name index initial weight weight destination names state destinations labels h m m hmm no constructor so serialization works state state name index initial weight weight destination names label names h m m hmm destination names length == label names length name = name index = index initial weight = initial weight weight = weight destination names = destination names length destinations = state label names length labels = label names length hmm = hmm i = 0 i < label names length i++ make sure label appears in our output alphabet hmm output alphabet lookup index label names i destination names i = destination names i labels i = label names i transducer get transducer hmm get weight weight get initial weight initial weight set weight weight = set initial weight initial weight = print out state # + index + \ + name + \ out initial weight= + initial weight + weight= + weight out #destinations= + destinations length i = 0 i < destinations length i++ out > + destination names i state get destination state index state ret ret = destinations index == ret = destinations index = state hmm name2state get destination names index ret != index ret transducer transition iterator transition iterator sequence input sequence input position sequence output sequence output position input position < 0 || output position < 0 unsupported operation epsilon transitions not input sequence == unsupported operation h m ms are generative models but not yet ! input sequence feature sequence unsupported operation h m ms currently expect instances to have feature sequence data transition iterator feature sequence input sequence input position output sequence == ? output sequence get output position hmm get name name get index index increment initial count count increment count count serialization state serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 n u l l i n t e g e r = 1 write output stream out i o i size out write u r r e n t s e r i a l v e r s i o n out write name out write index size = destination names == ? n u l l i n t e g e r destination names length out write size size != n u l l i n t e g e r i = 0 i < size i++ out write destination names i size = destinations == ? n u l l i n t e g e r destinations length out write size size != n u l l i n t e g e r i = 0 i < size i++ out write destinations i size = labels == ? n u l l i n t e g e r labels length out write size size != n u l l i n t e g e r i = 0 i < size i++ out write labels i out write hmm read input stream in i o not found size i = in read name = in read index = in read size = in read size != n u l l i n t e g e r destination names = size i = 0 i < size i++ destination names i = in read destination names = size = in read size != n u l l i n t e g e r destinations = state size i = 0 i < size i++ destinations i = state in read destinations = size = in read size != n u l l i n t e g e r labels = size i = 0 i < size i++ labels i = in read input alphabet = alphabet in read output alphabet = alphabet in read labels = hmm = h m m in read transition iterator transducer transition iterator serializable state source index next index input pos weights log prob eventually change because we will have a more space efficient feature vector sequence that cannot out each feature vector feature sequence input sequence input feature h m m hmm transition iterator state source feature sequence input seq input position output h m m hmm source = source hmm = hmm input sequence = input seq input feature = input sequence get index at position input position input pos = input position weights = source destinations length trans index = 0 trans index < source destinations length trans index++ output == || output equals source labels trans index weights trans index = 0 xxx should be emission next observation? log emission prob = hmm emission multinomial source get index log probability input seq get input position dest index = source get destination state trans index get index log emission prob = hmm emission multinomial dest index log probability input seq get input position log transition prob = hmm transition multinomial source get index log probability source destination names trans index weight = log probability weights trans index = log emission prob + log transition prob ! na n weights trans index weights trans index = i m p o s s i b l e w e i g h t next index = 0 next index < source destinations length weights next index == i m p o s s i b l e w e i g h t next index++ has next next index < source destinations length transducer state next state next index < source destinations length index = next index next index++ next index < source destinations length weights next index == i m p o s s i b l e w e i g h t next index++ source get destination state index get index index an containing feature index symbol at position in input sequence get input input feature get input position input pos get output source labels index get weight weights index transducer state get source state source transducer state get destination state source get destination state index serialization transition iterator serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 n u l l i n t e g e r = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write source out write index out write next index out write input pos weights != out write weights length i = 0 i < weights length i++ out write weights i out write n u l l i n t e g e r out write input sequence out write input feature out write hmm read input stream in i o not found = in read source = state in read index = in read next index = in read input pos = in read size = in read size == n u l l i n t e g e r weights = weights = size i = 0 i < size i++ weights i = in read input sequence = feature sequence in read input feature = in read hmm = h m m in read 