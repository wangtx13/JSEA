logging level logging logger sum lattice lattice node transducer state transducer transition iterator types dense vector types label alphabet types label vector types matrix ops types sequence logger sum lattice constrained sum lattice logger logger = logger get logger sum lattice constrained get name sum lattice constrained transducer t sequence input sequence output segment required segment sequence constrained sequence t input output transducer incrementor make constraints t input output required segment constrained sequence make constraints transducer t sequence input sequence sequence output sequence segment required segment sequence constrained sequence constrained sequence size != input sequence size illegal argument constrained sequence size + constrained sequence size + != input sequence size + input sequence size + constraints tells lattice which states must emit which observations positive values say all paths must pass through state index negative values say all paths must not pass through state index 0 means we t care initialize to 0 include 1 extra node start state constraints = constrained sequence size + 1 = 0 < constraints length c++ constraints = 0 i=required segment get start i <= required segment get end i++ si = t state index constrained sequence get i si == 1 logger warning could not find state + constrained sequence get i + check that state labels match start tages and in tags and that all labels are seen in training data illegal argument could not find state + constrained sequence get i + check that state labels match start tags and in tags constraints i+1 = si + 1 set additional negative constraint to ensure state after segment not a tag xxx segment length=1 actually constrains sequence to b tag b tag instead intended constraint b tag i tag fix below unsafe but will have to now f i x e d b e l o w end tag = constrained sequence get required segment get end required segment get end +2 < constraints length required segment get start == required segment get end segment has length 1 end tag starts b end tag = i + end tag substring 1 end tag length ! end tag starts i || end tag starts 0 illegal argument constrained lattice requires that states are tagged in b i o format statei = state index end tag statei == 1 no i tag b tag statei = state index constrained sequence get required segment get start constraints required segment get end + 2 = statei + 1 required segment get end + 2 < constraints length end tag = required segment get in tag to statei = t state index end tag statei == 1 illegal argument could not find state + end tag + check that state labels match start tags and in tags constraints required segment get end + 2 = statei + 1 print states logger fine segment + required segment sequence to + constrained sequence + constrained sequence + constraints i=0 i < constraints length i++ logger fine constraints i + logger fine constraints culotta constructor constrained lattice create a lattice that constrains its transitions such that <position label> pairs in constraints are adhered to constraints an where each entry index required label at that position an entry 0 means there are no constraints on that <position label> positive values mean path must pass through that state negative values mean path must not pass through that state n o t e constraints length must be equal to output size + 1 a lattice has one extra position initial state generally should be unconstrained since it does not produce an observation sum lattice constrained transducer trans sequence input sequence output transducer incrementor incrementor label alphabet output alphabet constraints logger loggable level f i n e logger fine starting lattice logger fine input ip = 0 ip < input size ip++ logger fine + input get ip logger fine output output == logger fine op = 0 op < output size op++ logger fine + output get op logger fine initialize some structures t = trans input = input output = output xxx not very efficient when lattice actually sparse especially when number states large and sequence lattice length = input size +1 num states = t num states nodes = lattice node lattice length num states xxx yipes could get big something sparse might be better? gammas = lattice length num states xxx move to an ivar so we can save it? but what? commenting out because it s a memory hog and not used right now uncomment and conditionalize a flag ever needed cas xis = lattice length num states num states output counts = output alphabet != output counts = lattice length output alphabet size i = 0 i < num states i++ ip = 0 ip < lattice length ip++ gammas ip i = transducer i m p o s s i b l e w e i g h t commenting out xis cas j = 0 j < num states j++ ip = 0 ip < lattice length ip++ xis ip i j = i m p o s s i b l e w e i g h t forward pass logger fine starting constrained foward pass ensure that at least one state has initial weight greater than infinity so we can start from there at least one initial state = i = 0 i < num states i++ initial weight = t get state i get initial weight out forward pass initial weight = +initial weight initial weight > transducer i m p o s s i b l e w e i g h t get lattice node 0 i alpha = initial weight out nodes 0 i alpha= +nodes 0 i alpha at least one initial state = at least one initial state == logger warning there are no starting states! ip = 0 ip < lattice length 1 ip++ i = 0 i < num states i++ logger fine ip= + ip+ i= + i check node possible at <position label> not skip it constraints ip > 0 must be in state indexed constraints ip 1 constraints ip 1 != i logger fine current state does not match positive constraint position= +ip+ constraint= + constraints ip 1 + curr state= +i constraints ip < 0 must not be in state indexed constraints ip constraints ip +1 == i logger fine current state does not match negative constraint position= +ip+ constraint= + constraints ip +1 + curr state= +i nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t xxx we end up doing a lot we could save a list non ones nodes ip i == logger fine nodes ip i n u l l nodes ip i alpha == transducer i m p o s s i b l e w e i g h t logger fine nodes ip i alpha inf logger fine i n f i n i t e weight or n u l l skipping state s = t get state i transition iterator iter = s transition iterator input ip output ip logger loggable level f i n e logger fine starting forward transition iteration from state + s get name + on input + input get ip to + and output + output==null ? output get ip to iter has next state destination = iter next state legal transition = check constraints to node at <ip i> can transition to destination ip+1 < constraints length constraints ip+1 > 0 constraints ip+1 1 != destination get index logger fine destination state does not match positive constraint assigning infinite weight position= + ip+1 + constraint= + constraints ip+1 1 + source = +i+ destination= +destination get index legal transition = ip+1 < constraints length constraints ip+1 < 0 constraints ip+1 +1 == destination get index logger fine destination state does not match negative constraint assigning infinite weight position= + ip+1 + constraint= + constraints ip+1 +1 + destination= +destination get index legal transition = logger loggable level f i n e logger fine forward lattice input pos= +ip + source= +s get name + dest= +destination get name + lattice node destination node = get lattice node ip+1 destination get index destination node output = iter get output transition weight = iter get weight legal transition logger loggable level f i n e logger fine transition weight= +transition weight + nodes +ip+ +i+ alpha= +nodes ip i alpha + destination node alpha= +destination node alpha destination node alpha = transducer sum log prob destination node alpha nodes ip i alpha + transition weight out destination node alpha < +destination node alpha logger fine set alpha lattice node at ip = + ip+1 + state index = + destination get index + destination node alpha = + destination node alpha an illegal transition according to our constraints so set its prob to 0 n o alpha s are unnormalized weights set to inf destination node alpha = 0 0 destination node alpha = i m p o s s i b l e w e i g h t logger fine illegal transition from state + i + to state + destination get index + setting alpha to inf calculate total weight lattice normalizer total weight = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes lattice length 1 i != note actually we could sum at any ip index choice lattice length 1 arbitrary out ending alpha state +i+ = +nodes lattice length 1 i alpha out ending beta state +i+ = +get state i weight constraints lattice length 1 > 0 i != constraints lattice length 1 1 constraints lattice length 1 < 0 i == constraints lattice length 1 +1 logger fine summing lattice weight state= +i+ alpha= +nodes lattice length 1 i alpha + weight = +t get state i get weight total weight = transducer sum log prob total weight nodes lattice length 1 i alpha + t get state i get weight weight now an unnormalized weight entire lattice weight >= 0 weight = +weight sequence has infinite weight just usefully avoids calling any increment x it also relies on fact that gammas and alpha and beta values are already initialized to values that reflect infinite weight xxx although perhaps not all alphas betas exactly correctly reflecting? total weight == transducer i m p o s s i b l e w e i g h t backward pass i = 0 i < num states i++ nodes lattice length 1 i != state s = t get state i nodes lattice length 1 i beta = s get weight gammas lattice length 1 i = nodes lattice length 1 i alpha + nodes lattice length 1 i beta total weight incrementor != p = math exp gammas lattice length 1 i p >= 0 0 p <= 1 0 ! na n p p= +p+ gamma= +gammas lattice length 1 i incrementor increment state s p ip = lattice length 2 ip >= 0 ip i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t note that skipping here based on alpha means that beta values won t be correct but since alpha infinite anyway it shouldn t matter state s = t get state i transition iterator iter = s transition iterator input ip output ip iter has next state destination = iter next state logger loggable level f i n e logger fine backward lattice input pos= +ip + source= +s get name + dest= +destination get name + j = destination get index lattice node destination node = nodes ip+1 j destination node != transition weight = iter get weight ! na n transition weight transition weight >= 0 not necessarily old beta = nodes ip i beta ! na n nodes ip i beta nodes ip i beta = transducer sum log prob nodes ip i beta destination node beta + transition weight ! na n nodes ip i beta dest beta= +destination node beta+ trans= +transition weight+ sum= + destination node beta+transition weight + old beta= +old beta xis ip i j = nodes ip i alpha + transition weight + nodes ip+1 j beta weight ! na n nodes ip i alpha ! na n transition weight ! na n nodes ip+1 j beta ! na n total weight incrementor != || output alphabet != xi = nodes ip i alpha + transition weight + nodes ip+1 j beta total weight p = math exp xi p > transducer i m p o s s i b l e w e i g h t ! na n p xis +ip+ +i+ +j+ = +xi incrementor != incrementor increment transition iter p output alphabet != output index = output alphabet lookup index iter get output output index >= 0 xxx assumes that ip == op ! output counts ip output index += p out r f lattice output counts +ip+ +output index+ += +p gammas ip i = nodes ip i alpha + nodes ip i beta total weight incrementor != i = 0 i < num states i++ p = math exp gammas 0 i p > transducer i m p o s s i b l e w e i g h t ! na n p incrementor increment initial state t get state i p output alphabet != labelings = label vector lattice length ip = lattice length 2 ip >= 0 ip math abs 1 0 matrix ops sum output counts ip < 0 000001 labelings ip = label vector output alphabet output counts ip following used to be in transducer does it still apply? does it still need addressing? akm culotta constrained lattice create constrained lattice such that all paths pass through labeling <code> required segment < code> indicated <code> constrained sequence < code> input sequence input sequence output sequence output sequence required segment segment sequence that must be labelled constrained sequence lattice must have labels sequence from <code> required segment start < code> to <code> required segment end < code> correctly lattice forward backward sequence input sequence sequence output sequence segment required segment sequence constrained sequence constrained sequence size != input sequence size illegal argument constrained sequence size + constrained sequence size + != input sequence size + input sequence size + constraints tells lattice which states must emit which observations positive values say all paths must pass through state index negative values say all paths must not pass through state index 0 means we t care initialize to 0 include 1 extra node start state constraints = constrained sequence size + 1 = 0 < constraints length c++ constraints = 0 i=required segment get start i <= required segment get end i++ si = state index constrained sequence get i si == 1 logger warning could not find state + constrained sequence get i + check that state labels match start tages and in tags and that all labels are seen in training data illegal argument could not find state + constrained sequence get i + check that state labels match start tags and in tags constraints i+1 = si + 1 set additional negative constraint to ensure state after segment not a tag xxx segment length=1 actually constrains sequence to b tag b tag instead intended constraint b tag i tag fix below unsafe but will have to now f i x e d b e l o w end tag = constrained sequence get required segment get end required segment get end +2 < constraints length required segment get start == required segment get end segment has length 1 end tag starts b end tag = i + end tag substring 1 end tag length ! end tag starts i || end tag starts 0 illegal argument constrained lattice requires that states are tagged in b i o format statei = state index end tag statei == 1 no i tag b tag statei = state index constrained sequence get required segment get start constraints required segment get end + 2 = statei + 1 required segment get end + 2 < constraints length end tag = required segment get in tag to statei = state index end tag statei == 1 logger fine could not find state + end tag + check that state labels match start tags and in tags constraints required segment get end + 2 = statei + 1 logger fine segment + required segment sequence to + constrained sequence + constrained sequence + constraints i=0 i < constraints length i++ logger fine constraints i + logger fine forward backward input sequence output sequence constraints 