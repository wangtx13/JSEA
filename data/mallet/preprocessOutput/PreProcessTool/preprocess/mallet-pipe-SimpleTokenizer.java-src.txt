pipe types hash set list io a simple unicode tokenizer that accepts sequences letters tokens simple tokenizer pipe u s e e m p t y s t o p l i s t = 0 u s e d e f a u l t e n g l i s h s t o p l i s t = 1 hash set< string> stoplist simple tokenizer flag stoplist = hash set< string> flag == u s e d e f a u l t e n g l i s h s t o p l i s t articles stop stop a stop an conjunctions stop and stop or prepositions stop stop stop in stop on stop to stop stop definite pronouns stop stop that stop these stop those stop some stop other personal pronouns stop it stop its stop we stop our conjuctions stop stop but stop not verbs stop stop does stop stop be stop are stop can stop was stop were simple tokenizer stopfile stoplist = hash set< string> buffered reader in = buffered reader input stream reader input stream stopfile u t f 8 word = word = in read line != stop word in close e err problem loading stoplist + e simple tokenizer hash set< string> stoplist stoplist = stoplist simple tokenizer deep clone simple tokenizer hash set< string> stoplist clone stop word stoplist add word instance pipe instance instance underscore point = character point at 0 instance get data sequence sequence characters = sequence instance get data list< string> tokens = list< string> token buffer = 1000 length = 1 using points instead chars allows us to support extended unicode and has no significant efficiency costs total points = character point count characters 0 characters length i=0 i < total points i++ point = character point at characters i point type = character get type point point type == character l o w e r a s e l e t t e r || point type == character u p p e r a s e l e t t e r || point == underscore point length++ token buffer length = point point type == character s p a e s e p a r a t o r || point type == character l i n e s e p a r a t o r || point type == character p a r a g r a p h s e p a r a t o r || point type == character e n d p u n t u a t i o n || point type == character d a s h p u n t u a t i o n || point type == character o n n e t o r p u n t u a t i o n || point type == character s t a r t p u n t u a t i o n || point type == character i n i t i a l q u o t e p u n t u a t i o n || point type == character f i n a l q u o t e p u n t u a t i o n || point type == character o t h e r p u n t u a t i o n things that delimit words length != 1 token = token buffer 0 length + 1 ! stoplist contains token tokens add token length = 1 point type == character o m b i n i n g s p a i n g m a r k || point type == character e n l o s i n g m a r k || point type == character n o n s p a i n g m a r k || point type == character t i t l e a s e l e t t e r || point type == character m o d i f i e r l e t t e r || point type == character o t h e r l e t t e r obscure things that are technically words marks are especially useful indic scripts length++ token buffer length = point character d e i m a l d i g i t n u m b e r character o n t r o l character m a t h s y m b o l out type + point type avoid buffer overflows length + 1 == token buffer length token = token buffer 0 length + 1 ! stoplist contains token tokens add token length = 1 length != 1 token = token buffer 0 length + 1 ! stoplist contains token tokens add token instance set data tokens illegal argument looking a sequence found a + instance get data get instance serial u = 1 