2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> types logging bit set io logger where will features get extracted in pipe? feature inducer serializable logger logger = logger get logger feature inducer get name add masked features = min training list size = 20 only one following two will be non ranked feature vector factory ranker ranked feature vector per label factory per label ranker beam1 = 300 beam2 = 1000 feature conjunction list fcl xxx could perhaps build a hash value each feature that measures its over instances and avoid conjunctions features that are exact duplicates hash value feature inducer ranked feature vector factory ranker instance list ilist num features beam1 beam2 fcl = feature conjunction list beam1 = beam1 beam2 = beam2 ilist size < min training list size logger info feature inducer not inducing from less than +min training list size+ features alphabet tmp d v = alphabet ilist get data alphabet clone feature selection features selected = ilist get feature selection instance list tmpilist = instance list tmp d v ilist get target alphabet ranked feature vector gg = ranker ranked feature vector ilist logger info rank values before round conjunction building n = math min 200 gg num locations i = 0 i < n i++ logger info rank= +i+ + to gg get value at rank i + + gg get at rank i to i = gg num locations 200 i < gg num locations i++ out i= +i+ + to gg get value at rank i + + gg get at rank i to out feature selection fs min = feature selection tmp d v feature selection fs max = feature selection tmp d v min beam = math min beam1 beam2 max beam = math max beam1 beam2 logger info using min beam= +min beam+ max beam= +max beam max = max beam < gg num locations ? max beam gg num locations b = 0 b < max b++ gg get value at rank b == 0 index = gg get index at rank b fs max add index b < min beam fs min add index prevent it from searching through all gg2 min gain = gg get value at rank max beam 2 no there are so many duplicate features that it ends up only adding a few each round min gain = n e g a t i v e i n f i n i t y just use a constant anything less than must not have enough support in data min gain = 5 min gain = 0 xxx temporarily remove all feature conjunction pruning out feature inducer temporarily not pruning any feature conjunctions from consideration fs min = fs max = min gain = n e g a t i v e i n f i n i t y conjunctions = beam b = 0 b < beam b++ conjunctions b = gg get index at rank b gg = allow memory to be freed i = 0 i < ilist size i++ instance inst = ilist get i feature vector fv = feature vector inst get data tmpilist add instance feature vector fv tmp d v fs min fs max inst get target inst get name inst get source ilist get instance weight i logger info calculating gradient gain conjunctions vocab size = +tmp d v size ranked feature vector gg2 = ranker ranked feature vector tmpilist i = 0 i < 200 i < gg2 num locations i++ logger info conjunction rank= +i+ + to gg2 get value at rank i + + gg2 get at rank i to num features added = 0 alphabet orig v = ilist get data alphabet orig v size = orig v size nextfeatures i = 0 i < gg2 num locations i++ gain = gg2 get value at rank i gain < min gain there are no more features we could add because they all have no more gain than features we started logger info stopping feature induction gain +i+ = +gain+ min gain= +min gain gg2 get index at rank i >= orig v size first disjunct above so that we also add singleton features that are currently masked out xxx add masked features == we should still check mask so we t add and print features that are already unmasked s = gg2 get at rank i feature indices = feature conjunction get feature indices orig v s make sure that conjunction doesn t contain duplicate features feature conjunction valid conjunction feature indices t add features exactly same gain value they are probably an exactly overlapping duplicate xxx note that might actually increase over fitting! i == 0 || gg2 get value at rank i 1 != gg2 get value at rank i feature value = gg2 get value at rank i t add conjunctions that have no more gain than any their constituents j = 0 j < feature indices length j++ gg2 value feature indices j >= feature value out skipping feature that adds no gain +new feature value+ +s nextfeatures fcl add feature conjunction orig v feature indices index = orig v size 1 we have a feature mask be sure to include feature logger info added feature +num features added+ +new feature value+ + s xxx also print gradient here feature already num features added++ features selected != index = gg2 get index at rank i out atomic feature rank +i+ at index +index !features selected contains index a atomic feature added to feature selection t add features exactly same gain value they are probably an exactly overlapping duplicate xxx note that might actually increase over fitting! i == 0 || gg2 get value at rank i 1 != gg2 get value at rank i fcl add feature conjunction orig v index logger info added feature a +num features added+ +gg2 get value at rank i + + gg2 get at rank i num features added++ num features added >= num features logger info stopping feature induction num features added= +num features added logger info finished adding features feature inducer ranked feature vector factory ranker instance list ilist num features ilist classifications num features 200 num features ilist classifications num features 200 500 ranker ilist num features num features num features must be run on test instance lists before they can be transduced because we have to add right feature combinations! induce features instance list ilist feature shrinkage add per features add per features == feature shrinkage == feature selection fs = ilist get feature selection ilist get per label feature selection == fcl size == 0 i = 0 i < ilist size i++ out induced features instance # +i instance inst = ilist get i data = inst get data data augmentable feature vector augmentable feature vector afv = augmentable feature vector data fcl add to afv 1 0 fs data feature vector sequence feature vector sequence fvs = feature vector sequence data j = 0 j < fvs size j++ fcl add to augmentable feature vector fvs get j 1 0 fs illegal argument unsupported instance data type +data get get name serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write beam1 out write beam2 out write fcl read input stream in i o not found = in read beam1 = in read beam2 = in read fcl = feature conjunction list in read 