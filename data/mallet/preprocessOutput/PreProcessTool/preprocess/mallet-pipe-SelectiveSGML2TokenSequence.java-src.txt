2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e pipe io net u r i regex set types instance types token types token sequence sequence lexer lexer similar to link s g m l2 token sequence except that only tags listed in <code>allowed tags< code> are converted to link label s author aron culotta <a href= mailto culotta >culotta edu< a> selective s g m l2 token sequence pipe serializable pattern sgml pattern = pattern compile < ? ^> > sequence lexer lexer background tag set allowed tags lexer to tokenize input background tag tag when not in any other tag allowed set tags strings that will be converted to labels selective s g m l2 token sequence sequence lexer lexer background tag set allowed lexer = lexer background tag = background tag allowed tags = allowed selective s g m l2 token sequence regex background tag set allowed sequence lexer regex background tag allowed selective s g m l2 token sequence set allowed sequence lexer o allowed selective s g m l2 token sequence sequence lexer lex set allowed lex o allowed instance pipe instance carrier ! carrier get data sequence cast carrier data a + carrier get data get get name + not a sequence token sequence data tokens = token sequence token sequence target tokens = token sequence sequence = sequence carrier get data tag = background tag next tag = background tag matcher m = sgml pattern matcher text start = 0 text end = 0 next start = 0 done = !done done = !find next valid match m done text end = length 1 sgml = m group group count = m group count sgml at 1 == next tag = background tag next tag = m group 0 next tag = sgml substring 1 sgml length 1 next start = m end text end = m start text end text start > 0 lexer set sequence sub sequence text start text end lexer has next data tokens add token lexer next target tokens add token tag text start = next start tag = next tag carrier set data data tokens carrier set target target tokens carrier set source data tokens carrier finds next match contained in <code> allowed tags < code> find next valid match matcher m !m find sgml = m group start = m start first = 1 last = sgml length 1 sgml at 1 == first = 2 sgml = sgml substring first last allowed tags contains sgml m find start find next valid match m to ret = sgml pattern + sgml pattern to ret += lexer + lexer get pattern to ret += bg tag + background tag to ret += allowed hash + allowed tags + ret serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write sgml pattern out write lexer out write background tag out write allowed tags read input stream in i o not found = in read sgml pattern = pattern in read lexer = sequence lexer in read background tag = in read allowed tags = set in read 