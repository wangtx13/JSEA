2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> math and statistics functionspublic maths from libbow dirichlet written tom minka <minka stat cmu edu> log gamma x result y xnum xden i d1 = 5 772156649015328605195174e 1 p1 = 4 945235359296727046734888e0 2 018112620856775083915565e2 2 290838373831346393026739e3 1 131967205903380828685045e4 2 855724635671635335736389e4 3 848496228443793359990269e4 2 637748787624195437963534e4 7 225813979700288197698961e3 q1 = 6 748212550303777196073036e1 1 113332393857199323513008e3 7 738757056935398733233834e3 2 763987074403340708898585e4 5 499310206226157329794414e4 6 161122180066002127833352e4 3 635127591501940507276287e4 8 785536302431013170870835e3 d2 = 4 227843350984671393993777e 1 p2 = 4 974607845568932035012064e0 5 424138599891070494101986e2 1 550693864978364947665077e4 1 847932904445632425417223e5 1 088204769468828767498470e6 3 338152967987029735917223e6 5 106661678927352456275255e6 3 074109054850539556250927e6 q2 = 1 830328399370592604055942e2 7 765049321445005871323047e3 1 331903827966074194402448e5 1 136705821321969608938755e6 5 267964117437946917577538e6 1 346701454311101692290052e7 1 782736530353274213975932e7 9 533095591844353613395747e6 d4 = 1 791759469228055000094023e0 p4 = 1 474502166059939948905062e4 2 426813369486704502836312e6 1 214755574045093227939592e8 2 663432449630976949898078e9 2 940378956634553899906876e10 1 702665737765398868392998e11 4 926125793377430887588120e11 5 606251856223951465078242e11 q4 = 2 690530175870899333379843e3 6 393885654300092398984238e5 4 135599930241388052042842e7 1 120872109616147941376570e9 1 488613728678813811542398e10 1 016803586272438228077304e11 3 417476345507377132798597e11 4 463158187419713286462081e11 = 1 910444077728e 03 8 4171387781295e 04 5 952379913043012e 04 7 93650793500350248e 04 2 777777777777681622553e 03 8 333333333333333331554247e 02 5 7083835261e 03 a = 0 6796875 x <= 0 5 || x > a x <= 1 5 x <= 0 5 result = math log x test whether x < epsilon x+1 == 1 result result = 0 x = x 0 5 0 5 xnum = 0 xden = 1 i=0 i<8 i++ xnum = xnum x + p1 i xden = xden x + q1 i result += x d1 + x xnum xden x <= a || x > 1 5 x <= 4 x <= a result = math log x x = x 0 5 0 5 result = 0 x = 2 xnum = 0 xden = 1 i=0 i<8 i++ xnum = xnum x + p2 i xden = xden x + q2 i result += x d2 + x xnum xden x <= 12 x = 4 xnum = 0 xden = 1 i=0 i<8 i++ xnum = xnum x + p4 i xden = xden x + q4 i result = d4 + x xnum xden x > 12 y = math log x result = x y 1 y 0 5 + 9189385332046727417803297 x = 1 x y = x x xnum = 6 i=0 i<6 i++ xnum = xnum y + i xnum = x result += xnum result from numeric recipes in old log gamma x j y tmp ser cof = 76 18009172947146 86 50532032941677 24 01409824083091 1 231739572450155 0 1208650973866179e 2 0 5395239384953e 5 y = x tmp = x + 5 5 x + 0 5 math log x + 5 5 ser = 1 000000000190015 j = 0 j <= 5 j++ ser += cof j ++y math log 2 5066282746310005 ser x tmp log beta a b log gamma a +log gamma b log gamma a+b beta a b math exp log beta a b gamma x math exp log gamma x factorial n math exp log gamma n+1 log factorial n log gamma n+1 computes p x n p where x~ b n p copied classic from catherine loader fast and accurate computation binomial probabilities 2001 not fast and accurate log binom x n p log factorial n log factorial x log factorial n x + x math log p + n x math log 1 p vastly inefficient o x to compute cdf b n p pbinom x n p sum = n e g a t i v e i n f i n i t y i = 0 i <= x i++ sum = sum log prob sum log binom i n p math exp sum sigmod beta 1 0 1 0+ math exp beta sigmod rev sig math log sig 1 sig logit p math log p 1 p combination? num combinations n r math exp log factorial n log factorial r log factorial n r permutation? num permutations n r math exp log factorial n log factorial r cosh a a < 0 0 5 math exp a + math exp a 0 5 math exp a + math exp a tanh a math exp a math exp a math exp a + math exp a numbers that are closer than are considered equal almost equals e p s i l o n = 0 000001 almost equals d1 d2 almost equals d1 d2 e p s i l o n almost equals d1 d2 epsilon math abs d1 d2 < epsilon almost equals d1 d2 eps i = 0 i < d1 length i++ v1 = d1 i v2 = d2 i !almost equals v1 v2 eps gsc checks <tt>min lt = value lt = max< tt> check within range value min max value > min || almost equals value min e p s i l o n value < max || almost equals value max e p s i l o n log2 = math log 2 gsc k l divergence k p1 || p2 log w r t base 2 <p> note any value in <tt>p2< tt> <tt>0 0< tt> then k l divergence <tt>infinite< tt> kl divergence p1 p2 p1 length == p2 length kl div = 0 0 i = 0 i < p1 length ++i p1 i == 0 p2 i == 0 p o s i t i v e i n f i n i t y kl div += p1 i math log p1 i p2 i kl div log2 moved division out loop d m gsc jensen shannon divergence jensen shannon divergence p1 p2 p1 length == p2 length average = p1 length i = 0 i < p1 length ++i average i += p1 i + p2 i 2 kl divergence p1 average + kl divergence p2 average 2 sum two doubles expressed in log space that <pre> sum log prob = log e^a + e^b = log e^a 1 + e^ b a = a + log 1 + e^ b a < pre> exponentiating <tt>b a< tt> we obtain better numerical precision than we would we calculated <tt>e^a< tt> or <tt>e^b< tt> directly < p> note function just like link transducer#sum neg log prob sum neg log prob in < t t> transducer< t t> except that logs aren t negated sum log prob a b a == n e g a t i v e i n f i n i t y b b == n e g a t i v e i n f i n i t y a b < a a + math log 1 + math exp b a b + math log 1 + math exp a b below from stanford n l p sloppy math l o g t o l e r a n e = 30 0 sums an numbers log x1 log xn saves some unnecessary calls to math log in two argument <p> note that i g n o r e s elements input that are more than l o g t o l e r a n e currently 30 0 less than maximum element <p> cursory testing makes me wonder actually much faster than repeated use 2 argument however cas vals an log x1 log x2 log xn log x1+x2+ +xn sum log prob vals max = n e g a t i v e i n f i n i t y len = vals length maxidx = 0 i = 0 i < len i++ vals i > max max = vals i maxidx = i any added = intermediate = 0 0 cutoff = max l o g t o l e r a n e i = 0 i < maxidx i++ vals i >= cutoff any added = intermediate += math exp vals i max i = maxidx + 1 i < len i++ vals i >= cutoff any added = intermediate += math exp vals i max any added max + math log 1 0 + intermediate max difference two doubles expressed in log space that <pre> sum log prob = log e^a e^b = log e^a 1 e^ b a = a + log 1 e^ b a < pre> exponentiating <tt>b a< tt> we obtain better numerical precision than we would we calculated <tt>e^a< tt> or <tt>e^b< tt> directly <p> <tt> na n< tt> b > a so that log e^a e^b undefined subtract log prob a b b == n e g a t i v e i n f i n i t y a a + math log 1 math exp b a get entropy dist entropy = 0 i = 0 i < dist length i++ dist i != 0 entropy = dist i math log dist i entropy 