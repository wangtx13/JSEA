2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> optimize logging optimize optimizable types matrix types matrix ops logger brents using derivative p405 numeric recipes in gradient bracket line optimizer line optimizer logger logger = logger get logger gradient bracket line optimizer get name max iterations = 50 optimizable gradient value optimizable gradient bracket line optimizer optimizable gradient value function optimizable = function maximize optimizable function matrix line initial step maximize optimizable gradient function line initial step t o d o seems to work but slower than back track line search why? last step size used line should point in direction we want to move to get higher value optimize line initial step initial step > 0 = optimizable get num gradient = optimizable get num optimizable get optimizable get value gradient gradient a=left b=center c=right t=test ax bx cx tx steps domain these are deltas from initial params! ay cy ty costs range ag bg cg tg projected gradients ox x step last function call orig y tx = ax = bx = cx = ox = 0 ty = ay = = cy = orig y = optimizable get value tg = ag = bg = matrix ops dot product gradient line make sure search line points upward logger info initial gradient = +tg ag <= 0 invalid optimizable search direction \ line\ does not point down uphill + gradient dot product line = +ag+ but should be positive find an cx value where gradient points other way then we will know that local zero gradient minimum falls in between ax and cx iterations = 0 iterations++ > max iterations illegal state exceeded maximum number allowed iterations searching gradient cross over we are still looking to cross minimum move ax towards it ax = bx ay = ag = bg save possibly middle point it might make an acceptable bx bx = tx = ty bg = tg tx == 0 initial step < 1 0 tx = initial step tx = 1 0 sometimes suggested initial step very large and causes values to go to infinity tx = initial step tx = 1 0 tx = 3 0 logger info gradient cross over search incrementing + tx ox matrix ops plus equals line tx ox optimizable set ty = optimizable get value optimizable get value gradient gradient tg = matrix ops dot product gradient line logger info next gradient = +tg ox = tx tg > 0 err iterations + total iterations in a cx = tx cy = ty cg = tg logger info after gradient cross over ax= +ax+ bx= +bx+ cx= +cx logger info after gradient cross over ay= +ay+ by= +by+ cy= +cy logger info after gradient cross over ag= +ag+ bg= +bg+ cg= +cg we need to find a that less than both ay and cy ! na n <= ay || <= cy || bx == ax last condition would happen we did first loop only once iterations++ > max iterations illegal state exceeded maximum number allowed iterations searching bracketed minimum iteratation count = +iterations xxx what should tolerance be? xxx i m nervous that masking some s below that were previously failing they were failing due to round off that s o k but not math abs bg < 100 || math abs ay < 10 || math abs cy < 10 bx != ax math abs bg < 10 || math abs ay < 1 || math abs cy < 1 bx != ax magically we are done instead make a that finds interpolating point fitting a parabola and then jumps to that minimum actual y value within tolerance parabola fit s guess then we are done otherwise use parabola s x to split region and again there might be some cases where will perform worse than simply bisecting we now when function not at all parabola shaped gradients ag and bg point in same direction then value must be less than ay and vice versa bg and cg ax==bx || ag bg >=0 by>ay || bg cg >=0 by>cy ! na n bg bg > 0 minimum at higher x values than bx drop ax >= ay ax = bx ay = ag = bg minimum at lower x values than bx drop cx >= cy cx = bx cy = cg = bg find a mid point bx = ax + cx 2 logger info minimum bx search incrementing + bx ox matrix ops plus equals line bx ox optimizable set = optimizable get value ! na n optimizable get value gradient gradient bg = matrix ops dot product gradient line ox = bx logger info during min bx search +iterations+ ax= +ax+ bx= +bx+ cx= +cx logger info during min bx search +iterations+ ay= +ay+ by= +by+ cy= +cy logger info during min bx search +iterations+ ag= +ag+ bg= +bg+ cg= +cg we now have two points ax cx that straddle minimum and a mid point bx a value lower than either ay or cy tx = ax + bx ax bx ax cy ay cx ax cx ax ay 2 0 bx ax cy ay cx ax ay logger info ending ax= +ax+ bx= +bx+ cx= +cx+ tx= +tx logger info ending ay= +ay+ by= +by+ cy= +cy matrix ops plus equals line tx ox optimizable set function get value >= orig y logger info ending cost = +optimizable get value a suggestion next inital step distance from our initial step to minimum we found err iterations + total iterations in b exit 0 math max 1 tx initial step 