2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types gnu trove t hash map gnu trove t hash set gnu trove t procedure gnu trove t hash map io inference exact sampler inference variable elimination s int2 multi map models randoms undirected graphical models created mon sep 15 15 18 30 2003 author <a href= mailto casutton > charles sutton< a> $ factor graph v 1 1 2007 10 22 21 37 44 exp $ factor graph factor list factors = list set clique potential graph ordinarily will map cliques to discrete potentials t hash map clique2ptl = t hash map universe universe t hash map projection map my2global bidirectional map factors alphabet duplicate indexing factors vertices and edges these arrays are indexed their variable s index link variable#index list vertex pots s int2 multi map pairwise factors list factors var num nodes factor graph num nodes = 0 set caches capacity 0 factors alphabet = bidirectional map create a model variables given much faster than adding variables one at a time factor graph variable vars set caches capacity vars length i = 0 i < vars length i++ cache variable vars i factor graph factor factors i = 0 i < factors length i++ add factor factors i factor graph collection factors iterator it = factors iterator it has next add factor factor it next create a model given capacity i e capacityin number variable nodes it can expand later but declaring capacity in advance you know it makes many things more efficient factor graph capacity set caches capacity capacity a h i n g clear caches set caches capacity num nodes pairwise factors clear projection map clear increases size all caching arrays that need to be increased when a node added can also be called before he caches have been se up set caches capacity n factors var = list n i = 0 i < n i++ factors var i = list vertex pots = list n my2global = n projection map == projection map = t hash map n projection map set value 1 projection map ensure capacity n no need to recreate edge pots it since it s a hash map pairwise factors == pairwise factors = s int2 multi map remove factor factor factor factors remove factor clique2ptl remove factor var set regenerate caches remove factors variable variable var iterator it = factors iterator it has next factor ptl = factor it next ptl var set contains var it remove clique2ptl retain entries t procedure execute clique ptl ! var set clique contains var remove from variable caches variable victim set survivors = t hash set variables set survivors remove victim vi = 0 t hash map dict = t hash map survivors size dict set value 1 no longer supported but get index written to avoid need my2global = survivors size iterator it = survivors iterator it has next variable var = variable it next gvi = var get index dict put gvi vi my2global vi = gvi projection map = dict num nodes at end b it affects get vertex set recache factors num nodes = 0 iterator it = factors iterator it has next factor ptl = factor it next var set vs = ptl var set add vars necessary vs cache factor vs ptl regenerate caches clear caches recache factors update factor caches num nodes == num variables vertex pots == set caches capacity num nodes num nodes > vertex pots length list old vertex pots = vertex pots s int2 multi map old edge pots = pairwise factors list old factors var = factors var old m2 g = my2global set caches capacity 2 num nodes old edge pots != arraycopy old vertex pots 0 vertex pots 0 old vertex pots length arraycopy old m2 g 0 my2global 0 old m2 g length i = 0 i < old factors var length i++ factors var i add all old factors var i cache variable variable var num nodes++ update factor caches gvi = var get index myvi = num nodes 1 projection map put gvi myvi my2global myvi = gvi cache factor var set var set factor factor var set size 1 vidx = get index var set get 0 cache variable factor vidx factor factors var vidx add factor 2 idx1 = get index var set get 0 idx2 = get index var set get 1 cache pairwise factor idx1 idx2 factor iterator it = var set iterator it has next variable var = variable it next idx = get index var factors var idx add factor cache variable factor vidx factor factor vertex pots vidx == vertex pots vidx = list 2 vertex pots vidx add factor cache pairwise factor idx1 idx2 factor ptl pairwise factors add idx1 idx2 ptl pairwise factors add idx2 idx1 ptl factors var idx1 add ptl factors var idx2 add ptl a e s s o r s number variable nodes in graph num variables num nodes set variables set set iterator iterator variables iterator size num nodes iterator variables iterator iterator i = 0 has next i < num nodes next get i++ remove unsupported operation all variables that are adjacent to a given variable in graph that set all variables that share a factor one xxx inefficient perhaps cache var set get adjacent vertices variable var hash var set = hash var set list adj factors = all factors containing var iterator it = adj factors iterator it has next factor factor = factor it next add all factor var set collection that contains factors in model collection factors collections unmodifiable collection factors an iterator all factors in graph iterator factors iterator factors iterator an iterator over all assignments to all variables graphical model assignment assignment iterator assignment iterator dense assignment iterator var set an iterator all var sets in graph over which factors are defined iterator var set iterator clique2ptl key set iterator a unique numeric index a variable in model every undirected model <tt>mdl< tt> maintains a mapping between its variables and integers 0 size mdl 1 which suitable caching variables in an <p> <tt>get index< tt> and <tt>get< tt> are inverses that <tt>idx == get index var < tt> then <tt>get idx < tt> will <tt>var< tt> var a variable contained in graphical model numeric index var #get get index variable var idx = var get index projection map contains key idx projection map get idx 1 get index factor factor factors alphabet lookup index factor a variable from model a given index every undirected model <tt>mdl< tt> maintains a mapping between its variables and integers 0 size mdl 1 which suitable caching variables in an < p> <tt>get index< tt> and <tt>get< tt> are inverses that <tt>idx == get index var < tt> then <tt>get idx < tt> will <tt>var< tt> #get index variable variable get index global idx = my2global index universe get global idx factor get factor i factor factors alphabet lookup i degree a given variable in factor graph that number factors in which variable an argument get degree variable var all factors containing var size searches model a variable a given name name name to find a variable <tt>var< tt> such that <tt>var get label equals name < tt> variable find variable name iterator it = variables iterator it has next variable var = variable it next var get label equals name var factor in graph any whose domain a given clique factor defined over clique no such factor will not potential defined over subsets or supersets clique #add factor factor #factor variable variable #factor variable factor factor var set var set var set size 1 factor var set get 0 2 factor var set get 0 var set get 1 factor collection var set factor defined over a given pair variables < p> equivalent to calling link #factor a var set that contains only <tt>v1< tt> and <tt>v2< tt> < p> var1 one variable pair var2 other variable pair factor defined over pair <tt> v1 v2 < tt> no such potential factor factor variable var1 variable var2 list ptls = all edge factors var1 var2 factor ptl = first singleton ptls var1+ +var2 ptl != ptl var set size == 2 ptl contains var var1 ptl contains var var2 ptl list all edge factors variable var1 variable var2 pairwise factors get get index var1 get index var2 a collection all factors that involve only given variables that all factors whose domain a subset given collection collection all factors containing collection vars t hash set factors = t hash set iterator it = factors iterator it has next factor ptl = factor it next vars contains all ptl var set factors add ptl factors list all factors containing variable var factors var get index var a list all factors in graph whose domain exactly specified var list all factors variable var idx = get index var idx == 1 list vertex pots idx a list all factors in graph whose domain exactly specified collection variables list all factors collection rather than iterating over all factors just iterate over ones that we know contain get 0 could possibly make more efficient picking var smallest degree variable v0 = variable iterator next list factors = factors var get index v0 list ret = list iterator it = factors iterator it has next factor f = factor it next var set var set = f var set var set size == size contains all var set var set contains all ret add f ret m u t a t o r s removes a variable from model along all its factors remove variable var remove from variable caches var remove factors variable var regenerate caches removes a collection variables from model along all its factors equivalent to calling remove variable on each element collection but because caching performed elsewhere in vastly more efficient remove collection vars iterator it = vars iterator it has next variable var = variable it next remove factors variable var num nodes = vars size regenerate caches whether two variables are adjacent in model s graph v1 a variable in model v2 another variable in model whether there an edge connecting them adjacent variable v1 variable v2 list factors = all factors containing v1 iterator it = factors iterator it has next factor ptl = factor it next ptl var set contains v2 whether variable model v1 any variable variable contained in moel contains var variable v1 variables set contains v1 add factor variable var1 variable var2 probs variable vars = variable var1 var2 table factor pot = table factor vars probs add factor pot adds a factor to model < p> a factor has already been added variables in given clique effects are currently undefined <p> all convenience adding factors eventually call through to one so subclasses to override they wish to perform additional actions when a factor added to graph factor a factor over variables in clique add factor factor factor before factor add factor var set var set = factor var set add vars necessary var set factors add factor factors alphabet lookup index factor add to list map clique2ptl var set factor cache factor cache factor var set factor after factor add factor performs checking a factor before it added to model should an unchecked there a problem does nothing but it may be overridden subclasses factor factor that about to be added before factor add factor factor performs operations on a factor after it has been added to model such caching does nothing but it may be overridden subclasses factor factor that has just been added after factor add factor factor add to list map map map key value list lst = list map get key lst == lst = list map put key lst lst add value add vars necessary var set var set i = 0 i < var set size i++ variable var = var set get i universe == universe = var get universe get index var < 0 cache variable var removes all potentias from model clear factors alphabet = bidirectional map factors clear clique2ptl clear clear caches num nodes = 0 unnormalized probability an assignment to model that value <pre> \prod \phi assn < pre> where ranges over all cliques which factors have been defined assn an assignment all variables in model unnormalized probability factor product assignment assn iterator ptl iter = factors iterator ptl prod = 1 ptl iter has next ptl prod = factor ptl iter next value assn ptl prod factor a given node that factor whose domain exactly node < p> equivalent to calling link #factor a clique that contains only <tt>v< tt> < p> var which factor over runtime model contains more than one factor over given variable use all factors in factor defined over edge <tt>v< tt> such link #add factor factor no such factor factor factor variable var list lst = all factors var first singleton lst var to factor first singleton list lst desc lst == sz = lst size sz > 1 runtime multiple factors over +desc+ + collection utils dump to lst sz == 0 factor lst get 0 searches graphical model a factor over given collection variables factor defined over given collection no such factor will not factors defined over subsets or supersets given collection runtime multiple factors over given collection #all factors collection #add factor factor #factor var set factor factor collection list factors = all factors first singleton factors to a copy model variable are shared between model and its copy but factor are deep copied factor duplicate factor graph dup = factor graph num variables iterator it = variables set iterator it has next variable var = variable it next dup cache variable var iterator it = factors iterator it has next factor pot = factor it next dup add factor pot duplicate e e print stack trace dup dumps all variables and factors model to <tt> out< tt> in human readable text dump dump print writer output stream writer out dump print writer out out out factors = +clique2ptl iterator it = factors iterator it has next factor pot = factor it next out pot dump to dump to writer out = writer dump print writer out out to f a t o r i m p l e m e n t a t i o n value assignment assn math exp log value assn value assignment iterator it value it assignment uses brute force algorithm factor normalize variable elimination inf = variable elimination z = inf compute normalization factor add factor constant factor 1 0 z factor marginalize variable vars unsupported operation not yet factor marginalize collection vars num variables < 5 table marginalize vars unsupported operation not yet factor marginalize variable var variable elimination inf = variable elimination inf unnormalized marginal var factor marginalize out variable var unsupported operation not yet factor marginalize out var set varset unsupported operation not yet factor extract max collection vars num variables < 5 table extract max vars unsupported operation not yet factor extract max variable var num variables < 5 table extract max var unsupported operation not yet factor extract max variable vars num variables < 5 table extract max vars unsupported operation not yet xxx should an assignment argmax unsupported operation not yet assumes that structure factor graph continous > discrete assignment sample randoms r variable cont vars = factors continuous vars cont vars length == 0 || cont vars length == num variables sample internal r assignment assn = sample continuous vars cont vars r factor graph discrete slice fg = factor graph slice assn assignment discrete assn = discrete slice fg sample internal r assignment union assn discrete assn samples continuous variables in factor graph assignment sample continuous vars randoms r variable cont vars = factors continuous vars sample continuous vars cont vars r assignment sample continuous vars variable cont vars randoms r collection cont factors = all factors containing arrays list cont vars factor graph cont fg = factor graph cont vars iterator it = cont factors iterator it has next factor factor = factor it next cont fg multiply factor cont fg sample internal r assignment sample internal randoms r exact sampler sampler = exact sampler r sampler sample 1 sum variable elimination inf = variable elimination inf compute normalization factor entropy unsupported operation not yet factor multiply factor dist factor graph fg = factor graph duplicate fg add factor dist fg multiply factor pot add factor pot exponentiate power unsupported operation not yet divide factor pot factors contains pot remove factor pot unsupported operation not yet var set var set hash var set variables set almost equals factor p unsupported operation almost equals factor p epsilon unsupported operation not yet na n fi = 0 fi < factors size fi++ get factor fi na n log value assignment iterator it log value it assignment log value loc unsupported operation variable get variable i get i todo merge in factor slice assignment assn slice assn factor slice assignment assn map to sliced map models add evidence assn to sliced map a h i n g f a i l i t y f o r t h e u s e o f i n f e r e n e a l g o r i t h m s t hash map inference caches = t hash map caches some about graph that specific to a given type inferencer e g a junction tree inferencer inferencer that can use info to cache #get inference cache set inference cache inferencer info inference caches put inferencer info caches some about graph that specific to a given type inferencer e g a junction tree inferencer inferencer which wants whatever was previously cached inferencer using set inference cache no has been cached #set inference cache get inference cache inferencer inference caches get inferencer logify list old factors = list factors clear iterator it = old factors iterator it has next table factor factor = table factor it next add factor log table factor factor log value assignment assn iterator ptl iter = factors iterator ptl prod = 0 ptl iter has next ptl prod += factor ptl iter next log value assn ptl prod table factor table table factor multiply all factors table pretty output to to buffer buf = buffer buf append factor graph variables i = 0 i < num nodes i++ variable var = get i buf append var buf append buf append buf append factors iterator it = factors iterator it has next factor factor = factor it next buf append buf append factor var set buf append buf append buf to print dot print writer out out graph model output edges dot out out colors = red green blue yellow print dot print writer out assignment assn out graph model output edges dot out iterator it = variables iterator it has next variable var = variable it next value = assn get var color = colors value out var get label + style=filled fillcolor= +color+ out output edges dot print writer out ptl idx = 0 iterator it = factors iterator it has next factor ptl = factor it next var set vars = ptl var set iterator var it = vars iterator var it has next variable var = variable var it next out print p t l +ptl idx+ +var get label out ptl idx++ serialization garbage serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write out write u r r e n t s e r i a l v e r s i o n read input stream in i o not found in read in read = regenerate caches 