2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types arrays collection iterator flops types matrix types matrixn maths created jan 4 2006 author < a h r e f= mailto casutton edu>casutton edu< a> $ table factor v 1 1 2007 10 22 21 37 44 exp $ table factor table factor discrete factor multiply all factor phis multiply all arrays list phis product a collection multinomial potentials xxx once there are other types potentials will need to be refactored into a factors utilities table factor multiply all collection phis phis size == 1 factor first = factor phis iterator next table factor first duplicate get all variables var set vs = hash var set iterator it = phis iterator it has next factor phi = factor it next vs add all phi var set define a potential over neighbors n o d e table factor p f = table factor vs iterator it = phis iterator it has next factor phi = factor it next p f multiply phi p f table factor variable var var table factor variable var values var values table factor table factor bidirectional map var map var map table factor variable all vars all vars table factor collection all vars all vars table factor variable all vars probs all vars probs table factor var set all vars probs all vars probs table factor variable all vars matrix probs in all vars probs in table factor table factor in in probs = matrix in get value matrix clone matrix table factor var set all vars matrix probs in all vars probs in table factor table factor ptl probs ptl probs set identity set all 1 0 factor duplicate table factor table factor create blank subset variable vars table factor vars multiplies every entry in potential a constant such that all entries sum to 1 factor normalize flops increment 2 probs num locations probs one normalize sum flops increment probs num locations probs one norm log value assignment iterator it flops log math log raw value it index current assn log value assignment assn flops log math log raw value assn log value loc flops log math log raw value loc value assignment assn raw value assn value loc raw value loc value assignment iterator assn raw value assn index current assn factor marginalize internal table factor result result set all 0 0 projection = large idx to small result add each element single large potentialto correct element in small potential num locs = probs num locations large loc = 0 large loc < num locs large loc++ convert a single index from to one smaller small idx = projection large loc whew! now add it in old value = probs value at location large loc result probs increment single value small idx old value flops increment num locs result does destructive multiplication on assuming has all variables in pot multiply internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl value small idx probs set value at location single loc prev val flops increment num locs does destructive divison on assuming has all variables in pot divide internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl value small idx product = prev val convention let dividing zero just 0 maths almost equals val 0 product = 0 probs set value at location single loc product flops increment num locs does destructive addition on assuming has all variables in pot plus equals internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl value small idx probs set value at location single loc prev + val flops increment num locs raw value assignment assn num vars = get num vars indices = num vars i = 0 i < num vars i++ variable var = get variable i indices i = assn get var value = raw value indices value raw value indices handle non occuring indices specially value inf in log space single idx = probs single index indices raw value single idx raw value single idx loc = probs location single idx loc < 0 0 probs value at location loc exponentiate power loc = 0 loc < probs num locations loc++ old val = probs value at location loc val = math pow old val power probs set value at location loc val flops pow probs num locations table factor ensure operand compatible table factor ptl ! ptl table factor table factor ptl ptl set log value assignment assn log value flops exp set raw value assn math exp log value set log value assignment iterator assn it log value flops exp set raw value assn it math exp log value set value assignment iterator assn it value set raw value assn it value set log values vals flops exp vals length i = 0 i < vals length i++ set raw value i math exp vals i set values vals i = 0 i < vals length i++ set raw value i vals i times equals v flops increment probs num locations probs times equals v plus equals at location loc v flops increment 1 old val = value at location loc set raw value loc old val + v matrix get value matrix probs matrix get log value matrix flops log probs num locations matrix log probs = matrix probs clone matrix loc = 0 loc < probs num locations loc++ log probs set value at location loc math log log probs value at location loc log probs value at location idx probs value at location idx creates a potential from another restricting it to a given assignment var variable potential will be over observed evidence to restrict to must give values all variables in ptl var set except var a discrete potential over var factor slice onevar variable var assignment observed vals = var get num outcomes i = 0 i < var get num outcomes i++ assignment to assn = assignment var i assignment union = assignment union to assn observed vals i = value union table factor var vals factor slice twovar variable v1 variable v2 assignment observed n1 = v1 get num outcomes n2 = v2 get num outcomes szs = n1 n2 variable varr = variable v1 v2 outcomes = 2 vals = n1 n2 i = 0 i < n1 i++ outcomes 0 = i j = 0 j < n2 j++ outcomes 1 = j assignment to vars = assignment varr outcomes assignment assn = assignment union to vars observed idx = matrixn single index szs i j inefficient but much less prone vals idx = value assn table factor variable v1 v2 vals factor slice general variable vars assignment observed var set to keep = hash var set vars to keep remove all observed var set vals = to keep weight assignment iterator it = to keep assignment iterator it has next assignment union = assignment union observed it assignment vals it index current assn = value union it advance table factor to keep vals table factor make from log values var set domain vals vals2 = vals length i = 0 i < vals length i++ vals2 i = math exp vals i table factor domain vals2 table factor recenter loc = argmax val = value at location loc times equals 1 0 val 