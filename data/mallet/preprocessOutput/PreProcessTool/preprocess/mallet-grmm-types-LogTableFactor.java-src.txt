2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types collection iterator flops types matrix types matrixn types sparse matrixn maths created jan 4 2006 author < a h r e f= mailto casutton edu>casutton edu< a> $ log table factor v 1 1 2007 10 22 21 37 44 exp $ log table factor table factor log table factor table factor in in probs = matrix in get log value matrix clone matrix log table factor variable var var log table factor variable all vars all vars log table factor collection all vars all vars create from used make from log factor values log table factor variable vars log values vars log values log table factor variable all vars matrix probs in all vars probs in log table factor make from values variable vars vals vals2 = vals length i = 0 i < vals length i++ vals2 i = math log vals i make from log values vars vals2 log table factor make from log values variable vars vals log table factor vars vals set identity set all 0 0 factor duplicate log table factor table factor create blank subset variable vars log table factor vars factor normalize sum = logspace one norm sum < 500 err attempt to normalize all 0 factor +this dump to i = 0 i < probs num locations i++ val = probs value at location i probs set value at location i val sum logspace one norm sum = n e g a t i v e i n f i n i t y that s 0 in log space i = 0 i < probs num locations i++ sum = maths sum log prob sum probs value at location i flops sum log prob probs num locations sum sum flops exp logspace one norm counts rest math exp logspace one norm logsum logspace one norm does conceptual equivalent = pot assumes that pot s variables are a subset potential s multiply internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl log value small idx product = prev + val probs set value at location single loc product flops increment num locs handle pluses does destructive divison on assuming has all variables in pot divide internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl log value small idx product = prev val convention let inf + inf corresponds to 0 0 be inf infinite val product = n e g a t i v e i n f i n i t y probs set value at location single loc product flops increment num locs handle pluses does conceptual equivalent += pot assumes that pot s variables are a subset potential s plus equals internal discrete factor ptl projection = large idx to small ptl num locs = probs num locations single loc = 0 single loc < num locs single loc++ small idx = projection single loc prev = probs value at location single loc val = ptl log value small idx product = maths sum log prob prev val probs set value at location single loc product flops sum log prob num locs value assignment assn flops exp get num vars == 0 1 0 math exp raw value assn value assignment iterator it flops exp math exp raw value it index current assn value idx flops exp math exp raw value idx log value assignment iterator it raw value it index current assn log value idx raw value idx log value assignment assn raw value assn factor marginalize internal table factor result result set all n e g a t i v e i n f i n i t y projection = large idx to small result add each element single large potentialto correct element in small potential num locs = probs num locations large loc = 0 large loc < num locs large loc++ convert a single index from to one smaller small idx = projection large loc whew! now add it in old value = probs value at location large loc current value = result probs single value small idx result probs set value at location small idx maths sum log prob old value current value flops sum log prob num locs result raw value assignment assn num vars = get num vars indices = num vars i = 0 i < num vars i++ variable var = get variable i indices i = assn get var raw value indices raw value indices handle non occuring indices specially value inf in log space single idx = probs single index indices raw value single idx raw value single idx loc = probs location single idx loc < 0 n e g a t i v e i n f i n i t y probs value at location loc exponentiate power flops increment probs num locations probs times equals power table factor ensure operand compatible table factor ptl ! ptl log table factor log table factor ptl ptl set log value assignment assn log value set raw value assn log value set log value assignment iterator assn it log value set raw value assn it log value set value assignment iterator assn it value flops log set raw value assn it math log value set log values vals i = 0 i < vals length i++ set raw value i vals i set values vals flops log vals length i = 0 i < vals length i++ set raw value i math log vals i v not in log space times equals v times equals log math log v times equals log log v flops increment probs num locations matrix other = matrix probs clone matrix other set all log v probs plus equals other plus equals at location loc v flops log flops sum log prob 1 old val = log value loc set raw value loc maths sum log prob old val math log v log table factor make from values variable var vals2 make from values variable var vals2 log table factor make from matrix variable vars sparse matrixn values sparse matrixn log values = sparse matrixn values clone matrix i = 0 i < log values num locations i++ log values set value at location i math log log values value at location i flops log log values num locations log table factor vars log values log table factor make from log matrix variable vars matrix values matrix log values = matrix values clone matrix log table factor vars log values log table factor make from log values variable v vals make from log values variable v vals matrix get value matrix matrix log probs = matrix probs clone matrix loc = 0 loc < probs num locations loc++ log probs set value at location loc math exp log probs value at location loc flops exp probs num locations log probs matrix get log value matrix probs value at location idx flops exp math exp probs value at location idx factor slice onevar variable var assignment observed assignment assn = assignment observed duplicate vals = var get num outcomes i = 0 i < var get num outcomes i++ assn set value var i vals i = log value assn log table factor make from log values var vals factor slice twovar variable v1 variable v2 assignment observed assignment assn = assignment observed duplicate n1 = v1 get num outcomes n2 = v2 get num outcomes szs = n1 n2 vals = n1 n2 i = 0 i < n1 i++ assn set value v1 i j = 0 j < n2 j++ assn set value v2 j idx = matrixn single index szs i j inefficient but much less prone vals idx = log value assn log table factor make from log values variable v1 v2 vals factor slice general variable vars assignment observed var set to keep = hash var set vars to keep remove all observed var set vals = to keep weight assignment iterator it = to keep assignment iterator it has next assignment union = assignment union observed it assignment vals it index current assn = log value union it advance log table factor make from log values to keep to variable vals log table factor multiply all collection phis get all variables var set vs = hash var set iterator it = phis iterator it has next factor phi = factor it next vs add all phi var set define a potential over neighbors n o d e log table factor p f = log table factor vs iterator it = phis iterator it has next factor phi = factor it next p f multiply phi p f table factor recenter table factor normalize loc = argmax lval = probs value at location loc should be refactored times equals log lval 