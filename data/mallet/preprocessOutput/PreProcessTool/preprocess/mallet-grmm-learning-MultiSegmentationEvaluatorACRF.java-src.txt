2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e evaluate segmentation f1 several different tags marked in o i b format example tags might be b p e r s o n i p e r s o n o b l o a t i o n i l o a t i o n o author andrew mc callum <a href= mailto >mccallum edu< a> generated nameimport logging text decimal format list types logger multi segmentation evaluator a r f a r f evaluator logger logger = logger get logger multi segmentation evaluator a r f get name equals called on these to determine token start or continuation a segment a tag not equal to any these an other not segment segment start tags segment tags segment start or tags eval iterations = 0 slice = 0 w i l l n o t w o r k segment start tags and segment tags are same!! multi segmentation evaluator a r f segment start tags segment tags show viterbi segment start tags = segment start tags segment tags = segment tags segment start tags length == segment tags length w i l l n o t w o r k segment start tags and segment tags are same!! multi segmentation evaluator a r f segment start tags segment tags segment start tags segment tags multi segmentation evaluator a r f segment start tags segment tags slice segment start tags segment tags slice = slice label sequence slice labels sequence lseq k label arr = label lseq size i = 0 i < lseq size i++ arr i = lseq get labels i get k label sequence arr evaluate a r f acrf iter instance list training instance list validation instance list testing t evaluate it too early in training to matter !should evaluate iter instance list lists = instance list training validation testing listnames = training validation testing k = 0 k < lists length k++ lists k != test acrf lists k listnames k test instance list gold list description test results results = test results segment start tags segment tags i = 0 i < gold size i++ instance instance = gold get i sequence output = process output sequence instance get target sequence pred output = slice labels sequence get i slice pred output size == output size results increment counts output pred output results log results description sequence process output sequence sequence sequence labels sequence labels sequence lseq = labels sequence sequence slice lseq slice sequence test results segment start tags segment tags num correct tokens total tokens num segments num predicted segments num correct segments all index test results segment start tags segment tags segment start tags = segment start tags segment tags = segment tags all index = segment start tags length num segments = all index+1 num predicted segments = all index+1 num correct segments = all index+1 token sequence source token sequence = total tokens = num correct tokens = 0 n = 0 n < num segments length n++ num segments n = num predicted segments n = num correct segments n = 0 log results description decimal format f = decimal format 0 #### logger info description + tokenaccuracy= +f format num correct tokens total tokens n = 0 n < num correct segments length n++ logger info n < all index ? segment start tags n to o v e r a l l + precision = num predicted segments n == 0 ? 1 num correct segments n num predicted segments n recall = num segments n == 0 ? 1 num correct segments n num segments n f1 = recall+precision == 0 0 ? 0 0 2 0 recall precision recall + precision logger info segments true= +num segments n + pred= +num predicted segments n + correct= +num correct segments n + misses= + num segments n num correct segments n + alarms= + num predicted segments n num correct segments n logger info precision= +f format precision + recall= +f format recall + f1= +f format f1 increment counts sequence output sequence pred output start pred start 1 non start otherwise index into segment start tag j = 0 j < output size j++ total tokens++ token = output get j to pred token = pred output get j to token equals pred token num correct tokens++ start = pred start = 1 count segment starts n = 0 n < segment start tags length n++ segment start tags n equals token num segments n ++ num segments all index ++ start = n count predicted segment starts n = 0 n < segment start tags length n++ segment start tags n equals pred output get j num predicted segments n ++ num predicted segments all index ++ pred start = n start != 1 start == pred start truth and prediction both agree that same segment tag type starting now m = pred = m = j+1 m < output size m++ token ctd = output get m to pred token ctd = pred output get m to = segment tags pred start equals token ctd pred = segment tags pred start equals pred token ctd !true || !pred == pred they agree about a segment ending somehow num correct segments pred start ++ num correct segments all index ++ end sequence m == output size == pred num correct segments pred start ++ num correct segments all index ++ 