2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e create feature from conjunction features from given offsets that match given regular expressions can be seen hand coding in a few conjunctions that you d get from link offset conjunctions < p> example creating a pipe < t t>new offset feature conjunction t i m e number w= number 0 1 2 < t t> will create a feature that whenever all a a feature at current time matches number b a feature at next time step matches w= b a feature 2 timesteps from now match number so that you have a simple time detector < p> conjunction passes then either first timestep that one all offsets were computed from or all matching timesteps get feature t i m e depending on value field tag all timesteps author charles sutton <a href= mailto casutton >casutton edu< a> author andrew mc callum <a href= mailto >mccallum edu< a> pipe tsf io i o io input stream io output stream io serializable regex pattern pipe pipe types instance types token types token sequence property list offset feature conjunction pipe serializable feature name pattern feature patterns offsets non negated tag all timesteps create a pipe adding conjunctions specified features feature name name conjunction feature feature names giving name each subfeature i offsets each subfeature i which offset from current timestep must i appear at non negated element i then negation feature added to conjuction offset feature conjunction feature name feature names offsets non negated tag all timesteps feature name = feature name feature patterns = patternify feature names offsets = offsets non negated = non negated tag all timesteps = tag all timesteps length ret = length i = 0 i < length i++ ret i = ret pattern patternify regex pattern retval = pattern regex length i = 0 i < regex length i++ retval i = pattern compile regex i retval offset feature conjunction feature name feature names offsets tag all timesteps feature name feature names offsets feature names length tag all timesteps offset feature conjunction feature name feature names offsets feature name feature names offsets feature names length tag all timesteps tag all timesteps get feature name feature name pattern get feature patterns feature patterns get offsets offsets get non negated non negated instance pipe instance carrier token sequence ts = token sequence carrier get data ts size = ts size t = 0 t < ts size t++ check whether conjunction at time step t passes = fnum = 0 fnum < feature patterns length fnum++ pos = t + offsets fnum ! pos >= 0 pos < ts size passes = feature present = has matching feature ts get pos feature patterns fnum feature present != non negated fnum passes = passes tag all timesteps fnum = 0 fnum < feature patterns length fnum++ pos = t + offsets fnum ts get pos set feature value feature name 1 0 ts get t set feature value feature name 1 0 carrier has matching feature token token pattern pattern property list iterator iter = token get features iterator iter has next iter next pattern matcher iter get key matches iter get numeric value == 1 0 serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 n u l l i n t e g e r = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write feature name out write tag all timesteps size size = feature patterns == ? n u l l i n t e g e r feature patterns length out write size size != n u l l i n t e g e r i = 0 i <size i++ out write feature patterns i out write offsets i out write non negated i read input stream in i o not found size = in read feature name = in read >= 1 tag all timesteps = in read size = in read size == n u l l i n t e g e r feature patterns = offsets = non negated = feature patterns = pattern size offsets = size non negated = size i = 0 i < size i++ feature patterns i = pattern in read offsets i = in read non negated i = in read 