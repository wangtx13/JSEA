2010 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised constraints gnu trove t list gnu trove t hash map list bit set sum lattice semi supervised state label map types feature vector types feature vector sequence types instance types instance list a set constraints on distributions over single labels conditioned on presence input features subclasses are to be used g e multiple constraints are grouped together here to make things more efficient author gregory druck one label g e constraints g e constraint maps between input feature indices and constraints t hash map< one label g e constraint> constraints state label map map cache set constrained features that fire at last feature vector in preprocess call t list cache one label g e constraints constraints = t hash map< one label g e constraint> cache = t list one label g e constraints t hash map< one label g e constraint> constraints state label map map constraints = constraints map = map cache = t list add constraint fi target weight one state constraint set state label map state label map map map = map pre process feature vector fv cache reset quick fi cache constrained input features loc = 0 loc < fv num locations loc++ fi = fv index at location loc constraints contains key fi cache add fi constraints contains key fv get alphabet size cache add fv get alphabet size find examples that contain constrained input features bit set pre process instance list data count ii = 0 fi feature vector fv bit set bit set = bit set data size instance instance data feature vector sequence fvs = feature vector sequence instance get data ip = 0 ip < fvs size ip++ fv = fvs get ip loc = 0 loc < fv num locations loc++ fi = fv index at location loc constraints contains key fi constraints get fi count += 1 bit set set ii constraints contains key fv get alphabet size bit set set ii constraints get fv get alphabet size count += 1 ii++ bit set get composite constraint feature value feature vector fv ip si1 si2 value = 0 li2 = map get label index si2 i = 0 i < cache size i++ value += constraints get cache get quick i get value li2 value get value zero expectations fi constraints keys constraints get fi expectation = map get num labels compute expectations list< sum lattice> lattices gammas t list cache = t list i = 0 i < lattices size i++ lattices get i == sum lattice lattice = lattices get i feature vector sequence fvs = feature vector sequence lattice get input gammas = lattice get gammas ip = 0 ip < fvs size ++ip cache reset quick feature vector fv = fvs get feature vector ip fi loc = 0 loc < fv num locations loc++ fi = fv index at location loc binary constraint features constraints contains key fi cache add fi constraints contains key fv get alphabet size cache add fv get alphabet size s = 0 s < map get num states ++s = map get label index s != state label map s t a r t l a b e l gamma prob = math exp gammas ip+1 s j = 0 j < cache size j++ constraints get cache get quick j expectation += gamma prob one label g e constraint target expectation count weight one label g e constraint target weight target = target weight = weight expectation = count = 0 get count count get target target get expectation expectation get weight weight get value 