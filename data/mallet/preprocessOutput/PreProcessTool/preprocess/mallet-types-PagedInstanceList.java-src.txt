2002 m a l l e t m achine languag e ~mccallum 1 0 furtherinformation ` l i e n s e types io io input stream io output stream io i o io input stream io output stream rmi dgc v m bit set map pipe noop pipe pipe types feature vector types instance types instance list types label types label alphabet types matrix ops an instance list which avoids out memory errors saving instances to disk when there not enough memory to create a instance it a fixed size paging scheme where each page on disk stores <code>instances per page< code> instances so number instances per pages constant size in bytes each page may vary using instead instance list means number instances you can store essentially limited only disk size and patience paging scheme optimized most frequent looping through instance list from index 0 to n there are n instances then instances 0 > n size are stored together on page 1 instances n size +1 > 2 n size are on page 2 etc way pages adjacent in <code>instances< code> list will usually be in same page instance list author aron culotta <a href= mailto culotta >culotta edu< a> paged instance list instance list t y p e f e a t u r e v e t o r = f t y p e l a b e l = l t y p e o b j e t = o number instances to put in one page instances per page directory to store swap files swap dir page numbers that represent in memory pages in memory page ids instance lists that represent in memory pages instance list in memory pages dirty get i == in memory bin i dirty bit set dirty = bit set total number instances in list including those swapped out size = 0 recommend garbage collection after every swap out? collect garbage = total number swap ins swap ins = 0 total time spent in swap ins swap in time = 0 total number swap outs swap outs = 0 total time spent in swap ins swap out time = 0 uniquely identifies instance list used in creating serialized page name swap files v m = v m avoids creating a noop pipe each page pipe noop pipe o n s t r u t o r s creates a paged instance list where instances per page instances are swapped to disk in directory swap dir amount free memory drops below min free memory bytes pipe instance pipe num pages number pages to keep in memory instances per page number instances to store in each page swap dir where pages on disk live paged instance list pipe pipe num pages instances per page swap dir pipe num pages instances per page instances per page = instances per page swap dir = swap dir in memory page ids = num pages in memory pages = instance list num pages noop pipe = noop pipe get data alphabet pipe get target alphabet i = 0 i < num pages i++ in memory page ids i = 1 !swap dir swap dir mkdir security e err no permission to make directory + swap dir exit 1 paged instance list pipe pipe num pages instances per page pipe num pages instances per page s p l i t t i n g a n d s a m p l i n g m e t h o d s shuffles elements an taken from collections shuffle r source randomness to use in shuffling a to shuffle shuffle random r a size = a length shuffle i = size 1 i > 0 i swap = r next i + 1 tmp = a i a i = a swap a swap = tmp shuffles elements list among several smaller lists instance list split to add instances in original order to prevent thrashing proportions a list numbers not necessarily summing to 1 which when normalized correspond to proportion elements in each sublist r source randomness to use in shuffling one <code> instance list< code> each element <code>proportions< code> instance list split random r proportions instance list ret = instance list proportions length maxind = proportions clone size = size shuffled = size splits = size build a list shuffled instance indexes i = 0 i < size i++ shuffled i = i shuffle r shuffled matrix ops normalize maxind i = 0 i < maxind length i++ ret i = clone empty note that we are passing on feature selection here i > 0 maxind i += maxind i 1 i = 0 i < maxind length i++ fill maxind highest instance index to go in each corresponding instance list maxind i = math rint maxind i size i = 0 j = 0 i < size i++ gives a slight bias toward putting an extra instance in last instance list i >= maxind j j < ret length j++ splits shuffled i = j i = 0 i < size i++ logger info adding instance + i + to split ilist + splits i ret splits i add get i ret p a g i n g m e t h o d s gets swap specified page page page to get swap swap get page page swap dir + + page gets page specified instance index swapping in necessary index instance index to get page dirty mark page dirty page specified instance index instance list get page index index dirty index > size index out bounds index + index + size + size swap in index instances per page dirty swaps in specified page page page to swap in dirty mark page dirty page that was just swapped in instance list swap in page dirty bin = page % in memory pages length in memory page ids bin != page swap out in memory page ids bin start time = current time millis page = get page page input stream in = in = input stream input stream page instance list page = deserialize page in in memory page ids bin = page in memory pages bin = page e err e exit 1 in != in close e err e exit 1 swap ins++ swap in time += current time millis start time dirty dirty set bin in memory pages bin swaps out page in specified bin it dirty page page to swap out swap out page bin = page % in memory pages length page != 1 dirty get bin start time = current time millis page = get page page output stream out = out = output stream output stream page instance list page = in memory pages bin in memory page ids bin = 1 in memory pages bin = serialize page out page dirty set bin e err e exit 1 out != out close e err e exit 1 collect garbage gc swap outs++ swap out time += current time millis start time a e s s o r s appends instance to list note that since memory instance has already been allocated no check made to out memory <code>true< code> successful add instance instance instance list page size % instances per page == 0 start a page swap out one in pages spot and create a one page = size instances per page bin = page % in memory pages length swap out in memory page ids bin page = instance list noop pipe in memory page ids bin = page in memory pages bin = page page = get page index size ret = page add instance ret size++ ret <code> instance< code> at specified index instance not in memory swap a block instances back into memory instance get index instance list page = get page index index page get index % instances per page replaces <code> instance< code> at position <code>index< code> a one note that only sanctioned way changing an instance instance set index instance instance instance list page = get page index index page set index % instances per page instance get collect garbage collect garbage set collect garbage b collect garbage = b instance list shallow clone instance list ret = clone empty i = 0 i < size i++ ret add get i ret instance list clone empty clone empty into paged instance list pipe in memory pages length instances per page swap dir clear num pages = size instances per page i = 0 i <= num pages i++ get page i delete i = 0 i < in memory pages length i++ in memory pages i = in memory page ids i = 1 size = 0 swap ins = 0 swap in time = 0 swap outs = 0 swap out time = 0 dirty clear clear get swap ins swap ins get swap in time swap in time get swap outs swap outs get swap out time swap out time size size serializes a single without metadata out i o serialize output stream out obj i o obj feature vector feature vector features = feature vector obj out write t y p e f e a t u r e v e t o r out write features get indices out write features get values obj label out write t y p e l a b e l out write label obj to out write t y p e o b j e t out write obj serialize a page without metadata attempts to serialize minimum amount needed to restore page leaving out redundant data such pipes and dictionaries out output stream page i o serialize page output stream out instance list page i o out write page size instance inst page serialize out inst get data serialize out inst get target out write inst get name out write inst get source inst weights != weight = inst weights get inst weight != out write inst weights get inst out write 1 0 out write 1 0 deserialize an serialized using link #serialize output stream i o not found deserialize input stream in i o not found type = in read obj type t y p e l a b e l label alphabet ldict = label alphabet get target alphabet name = in read obj = ldict lookup label name t y p e f e a t u r e v e t o r indices = in read values = in read obj = feature vector get data alphabet indices values t y p e o b j e t obj = in read i o unknown type + type obj deserialize a page restores a page serialized using link #serialize page output stream instance list in input stream page i o not found instance list deserialize page input stream in i o not found instance list page = instance list noop pipe size = in read i = 0 i < size i++ data = deserialize in target = deserialize in name = in read source = in read weight = in read page add instance data target name source weight page constructs a <code> instance list< code> deserialized from <code>file< code> value <code>file< code> then deserialize from link in instance list load input stream ois to equals ois = input stream in ois = input stream input stream paged instance list ilist = paged instance list ois read ois close ilist e e print stack trace illegal argument couldn t read paged instance list from +file serialization paged instance list serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write out write pipe memory attributes out write instances per page out write swap dir out write in memory page ids out write dirty i = 0 i < in memory pages length i++ serialize page out in memory pages i read input stream in i o not found = v m in read pipe = pipe in read memory attributes instances per page = in read swap dir = in read in memory page ids = in read dirty = bit set in read in memory pages = instance list in memory page ids length i = 0 i < in memory page ids length i++ in memory pages i = deserialize page in 