tests io io input stream io output stream io i o io input stream io output stream io serializable junit framework test junit framework test junit framework test suite types alphabet types feature sequence types feature vector types feature vector sequence types instance types instance list types label types label alphabet types label sequence types matrix ops types sequence types tests test serializable pipe sequence2 token sequence pipe pipe pipe print input and target pipe serial pipes pipe token sequence2 feature vector sequence pipe token sequence lowercase pipe iterator iterator pipe tsf offset conjunctions pipe tsf token text m e m m m e m m trainer sum lattice optimize optimizable optimize tests test optimizable extract span extract tokenization 2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e tests m e m m training author andrew mc callum <a href= mailto >mccallum edu< a> gsc 08 25 08 made changes to all tests after removing option use sparse weights from m e m m trainer now users has to set weights manually irrespective above changes two tests fail test space maximizable test space serializable test m e m m test test m e m m name name data = free a matter users freedom to run copy distribute study change and improve more precisely it refers to four kinds freedom users freedom to run program any purpose freedom to study how program works and adapt it to your needs freedom to redistribute copies so you can help your neighbor freedom to improve program and release your improvements to so that whole community benefits a program free users have all these freedoms thus you should be free to redistribute copies either or without modifications either gratis or charging a fee to anyone anywhere being free to these things means among other things that you not have to ask or pay permission you should also have freedom to make modifications and use them privately in your own work or play without even mentioning that they you publish your changes you should not be required to notify anyone in particular or in any particular way in order freedoms to make changes and to publish improved versions to be meaningful you must have access to source program therefore accessibility source a necessary condition free note that criteria such those stated in free definition require careful thought their interpretation to decide whether a specific qualifies a free we judge it based on these criteria to determine whether it fits their spirit well precise words a includes unconscionable restrictions we reject it even we did not anticipate issue in these criteria sometimes a requirement raises an issue that calls extensive thought including discussions a lawyer before we can decide requirement acceptable when we reach a conclusion about a issue we often update these criteria to make it easier to why certain licenses or t qualify in order these freedoms to be real they must be irrevocable you nothing wrong developer has power to revoke without your doing anything to give cause not free however certain kinds rules about manner distributing free are acceptable when they t conflict central freedoms example copyleft very simply stated rule that when redistributing program you cannot add restrictions to deny other people central freedoms rule does not conflict central freedoms rather it protects them thus you may have paid money to get copies free or you may have obtained copies at no charge but regardless how you got your copies you always have freedom to copy and change even to sell copies rules about how to a modified are acceptable they t effectively block your freedom to release modified versions rules that ``if you make program available in way you must make it available in that way also can be acceptable too on same condition note that such a rule still leaves you choice whether to publish program or not it also acceptable to require that you have distributed a modified and a previous developer asks a copy it you must send one sometimes government export control regulations and trade sanctions can constrain your freedom to distribute copies programs internationally developers not have power to eliminate or override these restrictions but what they can and must refuse to impose them conditions use program in way restrictions will not affect activities and people outside jurisdictions these governments note that criteria such those stated in free definition require careful thought their interpretation to decide whether a specific qualifies a free we judge it based on these criteria to determine whether it fits their spirit well precise words a includes unconscionable restrictions we reject it even we did not anticipate issue in these criteria sometimes a requirement raises an issue that calls extensive thought including discussions a lawyer before we can decide requirement acceptable when we reach a conclusion about a issue we often update these criteria to make it easier to why certain licenses or t qualify g n u project was launched in 1984 to develop a complete unix like operating which free g n u test get set input vocab size = 100 num states = 5 alphabet input alphabet = alphabet i = 0 i < input vocab size i++ input alphabet lookup index feature + i alphabet output alphabet = alphabet m e m m memm = m e m m input alphabet output alphabet state names = num states i = 0 i < num states i++ state names i = state + i memm add fully connected states state names m e m m trainer memmt = m e m m trainer memm m e m m trainer m e m m optimizable label likelihood omemm = memmt get optimizable m e m m instance list test optimizable test get set omemm test space maximizable pipe p = make space prediction pipe instance list training = instance list p data = test m e m m data 0 test m e m m data 1 test m e m m data 2 test m e m m data 3 data = ab training add thru pipe iterator data r f4 memm = r f4 p m e m m memm = m e m m p memm add fully connected states labels memm add start state memm set weights dimension in training m e m m trainer memmt = m e m m trainer memm memm gather training sets training a n n o y i n g need to set up per instance training sets memmt train training 1 set weights dimension gathers training sets etc memm print memm print gradient = memm print instance lists memm set gaussian prior variance p o s i t i v e i n f i n i t y optimizable gradient value mcrf = memmt get optimizable m e m m training test optimizable set num components 150 test optimizable test value and gradient mcrf test space serializable i o not found pipe p = make space prediction pipe instance list training = instance list p training add thru pipe iterator data m e m m memm = m e m m p memm add fully connected states labels memm add start state memm set weights dimension in training m e m m trainer memmt = m e m m trainer memm memmt train training 10 m e m m memm2 = m e m m test serializable clone via serialization memm optimizable gradient value mcrf1 = memmt get optimizable m e m m training val1 = mcrf1 get value optimizable gradient value mcrf2 = memmt get optimizable m e m m training val2 = mcrf2 get value equals val1 val2 1e 5 should print at end 4 4 3 unconstrained cost= 2912 0 constrained cost= 428 0 min cost=35770 0 min grad=520 0 disabledtest cost use save input vocab size = 4 num states = 5 create a to store r f f = test obj f2 = test object2 obj alphabet input alphabet = alphabet i = 0 i < input vocab size i++ input alphabet lookup index feature + i alphabet output alphabet = alphabet store dictionary output alphabet == err output dictionary m e m m crf = m e m m input alphabet output alphabet m e m m trainer memmt = m e m m trainer crf state names = num states i = 0 i < num states i++ state names i = state + i m e m m save r f = crf input alphabet = feature alphabet crf get input alphabet feature vector sequence fvs = feature vector sequence feature vector feature vector crf get input alphabet 1 2 3 1 1 1 feature vector crf get input alphabet 1 2 3 1 1 1 feature vector crf get input alphabet 1 2 3 1 1 1 feature vector crf get input alphabet 1 2 3 1 1 1 feature sequence ss = feature sequence crf get output alphabet 0 1 2 3 instance list ilist = instance list ilist add fvs ss crf add fully connected states state names output stream oos = output stream output stream f oos write crf oos close i o e err writing + e err wrote out r f and read it back in crf = input stream ois = input stream input stream f crf = m e m m ois read ois close i o e err reading + e not found cnfe err cound not find reading in + cnfe err read in r f output stream oos = output stream output stream f2 oos write crf oos close i o e err writing + e err wrote out r f use save == 1 crf = save r f m e m m optimizable r f mcrf = crf get maximizable r f ilist optimizable gradient value mcrf = memmt get optimizable m e m m ilist unconstrained cost = sum lattice crf fvs get total weight constrained cost = sum lattice crf fvs ss get total weight minimizable cost = 0 minimizable gradient norm = 0 gradient = mcrf get num out unconstrained cost= +unconstrained cost+ constrained cost= +constrained cost i = 0 i < num states i++ j = 0 j < num states j++ k = 0 k < input vocab size k++ crf set parameter i j k k + i + j k i + i j unconstrained cost = sum lattice crf fvs get total weight constrained cost = sum lattice crf fvs ss get total weight minimizable cost = mcrf get value mcrf get value gradient gradient minimizable gradient norm = matrix ops one norm gradient out + i + + j + + k + unconstrained cost= + unconstrained cost + constrained cost= + constrained cost + min cost= + minimizable cost + min grad= + minimizable gradient norm equals math abs minimizable cost 35770 < 0 001 equals math abs minimizable gradient norm 520 < 0 001 test increment test m e m m token sequence remove spaces pipe serializable test m e m m token sequence remove spaces label alphabet instance pipe instance carrier tokenization ts = tokenization carrier get data tokenization ts = tokenization sequence ts get document label alphabet dict = label alphabet get target alphabet label sequence label seq = label sequence dict label start = dict lookup label start label notstart = dict lookup label notstart last was space = buffer sb = buffer i = 0 i < ts size i++ span t = span ts get span i t get text equals last was space = sb append t get text ts add t label seq add last was space ? start notstart last was space = target processing carrier set target label seq carrier set data ts carrier set source sb to carrier serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n read input stream in i o = in read test m e m m2 pipe serializable test m e m m2 instance pipe instance carrier buffer sb = buffer source = carrier get source sequence = sequence carrier get target start label index = get alphabet lookup index start i = 0 i < source length i++ out target + i + = + get i to get i to equals start i != 0 sb append sb append source at i carrier set source sb to out carrier get source = + carrier get source carrier serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n read input stream in i o = in read test space prediction test value and gradient pipe p = make space prediction pipe pipe p2 = test m e m m2 instance list instances = instance list p instances add thru pipe iterator data instance list lists = instances split 5 5 m e m m memm = m e m m p p2 memm add fully connected states labels memm set weights dimension in lists 0 m e m m trainer memmt = m e m m trainer memm test value and gradient optimizable gradient value minable = memmt get optimizable m e m m lists 0 test optimizable test value and gradient minable out training accuracy before training = + memm average token accuracy lists 0 out testing accuracy before training = + memm average token accuracy lists 1 out training memmt train lists 0 1 out training accuracy after training = + memm average token accuracy lists 0 out testing accuracy after training = + memm average token accuracy lists 1 out training results i = 0 i < lists 0 size i++ instance inst = lists 0 get i sequence input = sequence inst get data sequence output = memm transduce input out output out testing results i = 0 i < lists 1 size i++ instance inst = lists 1 get i sequence input = sequence inst get data sequence output = memm transduce input out output test space prediction test value and gradient use saved use sparse weights pipe p = make space prediction pipe m e m m saved r f f = test obj instance list instances = instance list p instances add thru pipe iterator data instance list lists = instances split 5 5 m e m m crf = m e m m p get data alphabet p get target alphabet crf add fully connected states labels use sparse weights crf set weights dimension in lists 0 crf set weights dimension densely m e m m trainer memmt = m e m m trainer crf memmt set use sparse weights use sparse weights test value and gradient optimizable gradient value minable = memmt get optimizable m e m m lists 0 test optimizable test value and gradient minable out training accuracy before training = + crf average token accuracy lists 0 out testing accuracy before training = + crf average token accuracy lists 1 saved r f = crf out training serialized crf memmt train lists 0 100 pre train acc = crf average token accuracy lists 0 pre test acc = crf average token accuracy lists 1 out training accuracy after training = + pre train acc out testing accuracy after training = + pre test acc output stream oos = output stream output stream f oos write crf oos close i o e err writing + e err wrote out r f and read it back in use saved crf = input stream ois = input stream input stream f crf = m e m m ois read ois close i o e err reading + e not found cnfe err cound not find reading in + cnfe err read in r f crf = saved r f post train acc = crf average token accuracy lists 0 post test acc = crf average token accuracy lists 1 out training accuracy after saving = + post train acc out testing accuracy after saving = + post test acc equals post train acc pre train acc 0 0001 equals post test acc pre test acc 0 0001 pipe make space prediction pipe pipe p = serial pipes pipe sequence2 token sequence token sequence lowercase test m e m m token sequence remove spaces token text offset conjunctions 0 1 1 0 0 1 1 1 0 0 1 2 1 0 0 1 2 3 2 1 1 2 3 2 1 1 0 0 1 1 2 3 2 1 2 1 0 1 0 1 0 1 2 1 2 3 print input and target token sequence2 feature vector sequence p disabledtest add order n states pipe p = make space prediction pipe instance list instances = instance list p instances add thru pipe iterator data instance list lists = instances split random 678 5 5 compare 3 r fs trained add order n states and make sure that having more features leads to a higher likelihood m e m m crf1 = m e m m p get data alphabet p get target alphabet crf1 add order n states lists 0 1 s t a r t crf1 set weights dimension in lists 0 m e m m trainer memmt1 = m e m m trainer crf1 memmt1 train lists 0 m e m m crf2 = m e m m p get data alphabet p get target alphabet crf2 add order n states lists 0 1 2 s t a r t crf2 set weights dimension in lists 0 m e m m trainer memmt2 = m e m m trainer crf2 memmt2 train lists 0 m e m m crf3 = m e m m p get data alphabet p get target alphabet crf3 add order n states lists 0 1 2 s t a r t crf3 set weights dimension in lists 0 m e m m trainer memmt3 = m e m m trainer crf3 memmt3 train lists 0 prevent cached values lik1 = get likelihood memmt1 lists 0 lik2 = get likelihood memmt2 lists 0 lik3 = get likelihood memmt3 lists 0 out r f1 likelihood +lik1 zero order likelihood < +lik1+ > greater than first order < +lik2+ > lik1 < lik2 defaults only likelihood < +lik2+ > greater than full first order < +lik3+ > lik2 < lik3 equals 167 335971702 lik1 0 0001 equals 166 212235389 lik2 0 0001 equals 90 386005741 lik3 0 0001 get likelihood m e m m trainer memmt instance list data optimizable gradient value mcrf = memmt get optimizable m e m m data elaborate thing so that crf cached value stale forced params = mcrf get num mcrf get params mcrf set params mcrf get value disabledtest value gradient test space prediction disabledtest train test space prediction disabledtest dense train test space prediction disabledtest serialization test space prediction disabledtest dense serialization test space prediction disabledtest print pipe p = serial pipes pipe sequence2 token sequence token text test m e m m test m e m m token sequence remove spaces token sequence2 feature vector sequence print input and target instance list one = instance list p data = a b d e one add thru pipe iterator data m e m m crf = m e m m p crf add fully connected states labels crf set weights dimension in one m e m m trainer memmt = m e m m trainer crf m e m m trainer m e m m optimizable label likelihood mcrf = memmt get optimizable m e m m one params = mcrf get num i = 0 i < params length i++ params i = i mcrf set params crf print test suite test suite test m e m m test m e m m tm = test m e m m tm test space prediction test suite suite length > 0 suite = test suite i = 0 i < length i++ suite add test test m e m m i suite = test suite suite junit textui test runner run suite 