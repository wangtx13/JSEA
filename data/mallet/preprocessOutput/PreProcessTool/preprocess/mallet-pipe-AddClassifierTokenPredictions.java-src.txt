2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e pipe io i o io input stream io output stream io serializable hash map logging logger classify balanced winnow trainer classify classification classify classifier classify classifier trainer classify trial types alphabet types augmentable feature vector types feature vector types feature vector sequence types instance types instance list types label types label sequence types label vector types labeling logger pipe uses a classifier to label each token i e using 0 th order markov assumption then adds predictions features to each token pipe assumes input instance s data type feature vector sequence each an augmentable feature vector example usage <pre> 1 create and serialize a feature pipe that converts raw input to feature vector sequences 2 pipe input data through feature pipe train a token classifiers via cross validation then serialize classifiers 2 pipe input data through feature pipe and pipe using saved classifiers and train a transducer 4 serialize trained transducer < pre> author ghuang add classifier token predictions pipe serializable logger logger = logger get logger add classifier token predictions get name specify which predictions are to be added features e g 1 2 = add labels top 2 highest scoring predictions features m pred ranks2add trained token classifier token classifiers m token classifiers whether to treat each instance s feature values binary m binary whether pipe currently being used at production time i e not being used pipeline training a transducer m in production augmented data alphabet that includes predictions alphabet m data alphabet add classifier token predictions instance list train list train list add classifier token predictions instance list train list instance list test list token classifiers convert train list noop train list get pipe 1 convert test list noop train list get pipe add classifier token predictions token classifiers token classifiers pred ranks2add binary instance list test list m pred ranks2add = pred ranks2add m binary = binary m token classifiers = token classifiers m in production = m data alphabet = alphabet token classifiers get alphabet clone alphabet label alphabet = token classifiers get label alphabet add token prediction features to alphabet i = 0 i < m pred ranks2add length i++ j = 0 j < label alphabet size j++ feat name = t o k p r e d= + label alphabet lookup j to + r a n k + m pred ranks2add i m data alphabet lookup index feat name evaluate token classifier test list != trial trial = trial m token classifiers test list logger info token classifier accuracy on test set = + trial get accuracy set in production in production m in production = in production get in production m in production set in production pipe p value p add classifier token predictions add classifier token predictions p set in production value p serial pipes serial pipes sp = serial pipes p i = 0 i < sp size i++ set in production sp get pipe i value alphabet get data alphabet m data alphabet add token classifier s predictions features to instance assumes input instance contains feature vector sequence data instance pipe instance carrier feature vector sequence fvs = feature vector sequence carrier get data instance list ilist = convert carrier noop m token classifiers get instance pipe fvs size == ilist size passing instances to token classifier each instance s data alphabet needs to match that used token classifier at training time resulting piped instance each instance s data alphabet needs to contain token classifier s prediction features feature vector fva = feature vector fvs size i = 0 i < ilist size i++ instance inst = ilist get i classification = m token classifiers classify inst ! m in production label vector lv = get label vector augmentable feature vector afv1 = augmentable feature vector inst get data indices = afv1 get indices augmentable feature vector afv2 = augmentable feature vector m data alphabet indices afv1 get values indices length + m pred ranks2add length j = 0 j < m pred ranks2add length j++ label label = lv get label at rank m pred ranks2add j idx = m data alphabet lookup index t o k p r e d= + label to + r a n k + m pred ranks2add j idx >= 0 afv2 add idx 1 fva i = afv2 carrier set data feature vector sequence fva carrier converts each instance containing a feature vector sequence to multiple instances each containing an augmentable feature vector data ilist instances feature vector sequence data field alphabets pipe a noop pipe containing data and target alphabets resulting instance list an instance list where each instance contains one token s augmentable feature vector data instance list convert instance list ilist noop alphabets pipe ilist == monstrosity necessary b classifiers obtain data target alphabets via pipes instance list ret = instance list alphabets pipe instance inst ilist ret add inst i = 0 i < ilist size i++ ret add convert ilist get i alphabets pipe ret inst input instance feature vector sequence data alphabets pipe a noop pipe containing data and target alphabets resulting instance list and augmentable feature vectors list instances each one augmentable feature vector data instance list convert instance inst noop alphabets pipe instance list ret = instance list alphabets pipe obj = inst get data obj feature vector sequence feature vector sequence fvs = feature vector sequence obj label sequence ls = label sequence inst get target fvs size == ls size inst name = inst get name == ? n o n a m e inst get name j = 0 j < fvs size j++ feature vector fv = fvs get feature vector j indices = fv get indices feature vector data = augmentable feature vector alphabets pipe get data alphabet indices fv get values indices length labeling target = ls get label at position j name = inst name to + p o s + j + 1 source = inst get source instance to add = alphabets pipe pipe instance data target name source ret add to add ret serialization serial u = 1 inner represents trained token classifiers author ghuang token classifiers classifier serializable number folds in cross validation training m num v random seed to split training data cross validation m rand seed trainer token classifier classifier trainer m trainer token classifier trained on entirety training set classifier m token classifier table storing instance name > out fold classifier used to prevent overfitting to token classifier s predictions hash map m table train a token classifier using given instances 5 fold cross validation train list training instances token classifiers instance list train list train list 0 5 token classifiers instance list train list rand seed num v ada boost m2 trainer decision tree trainer 2 10 train list rand seed num v naive bayes trainer train list rand seed num v balanced winnow trainer train list rand seed num v s v m trainer train list rand seed num v token classifiers classifier trainer trainer instance list train list rand seed num v train list get pipe m trainer = trainer m rand seed = rand seed m num v = num v m table = hash map training train list train token classifier training instance list train list train a classifier on entire training set logger info training token classifier on entire data set size= + train list size + m token classifier = m trainer train train list trial t = trial m token classifier train list logger info training set accuracy = + t get accuracy m num v == 0 train classifiers using cross validation instance list cross validation iterator cv iter = train list cross validation iterator m num v m rand seed f = 1 cv iter has next f++ instance list fold = cv iter next split logger info training token classifier on cv fold + f + + m num v + size= + fold 0 size + classifier fold classifier = m trainer train fold 0 trial t1 = trial fold classifier fold 0 trial t2 = trial fold classifier fold 1 logger info within fold accuracy = + t1 get accuracy logger info out fold accuracy = + t2 get accuracy x = 0 x < t2 size x++ logger info xxx pred + t2 get classification x get labeling get best label + + t2 get classification x get instance get labeling i = 0 i < fold 1 size i++ instance inst = fold 1 get i m table put inst get name fold classifier classification classify instance instance classify instance instance instance to classify use out fold whether to check instance name and use out fold classifier instance name matches one in training data token classifier s output classification classify instance instance use out fold inst name = instance get name ! use out fold || ! m table contains key inst name m token classifier classify instance classifier classifier = classifier m table get inst name classifier classify instance serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write get instance pipe out write m num v out write m rand seed out write m table out write m token classifier out write m trainer read input stream in i o not found = in read != u r r e n t s e r i a l v e r s i o n not found mismatched token classifiers versions wanted + u r r e n t s e r i a l v e r s i o n + got + instance pipe = pipe in read m num v = in read m rand seed = in read m table = hash map in read m token classifier = classifier in read m trainer = classifier trainer in read 