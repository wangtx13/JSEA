2010 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised list bit set concurrent callable concurrent executors concurrent thread pool executor concurrent time unit r f sum lattice sum lattice semi supervised constraints g e constraint optimize optimizable types feature vector sequence types instance types instance list types matrix ops optimizable r f using generalized expectation constraints that consider either a single label or a pair labels a linear chain r f generalized expectation criteria semi supervised conditional random fields gideon mann and andrew mc callum a l 2008 author gregory druck r f optimizable g e optimizable gradient value d e f a u l t g p v = 10 r f crf list< g e constraint> constraints instance list data num threads gpv weight indicator that keeps track whether gradient value need to be re computed cache cached value r f factors cached gradient lists source states transition indices each destination state used in g e lattice reverse trans reverse trans indices instances in which at least one constraint fires bit set instances constraints thread pool executor executor crf r f constraints list g e constraints data unlabeled data map map between states and labels num threads number threads to use training d e f a u l t=1 r f optimizable g e r f crf list< g e constraint> constraints instance list data state label map map num threads crf constraints data map num threads 1 r f optimizable g e r f crf list< g e constraint> constraints instance list data state label map map num threads weight crf = crf constraints = constraints cache = m a x v a l u e cached value = na n cached gradient = r f factors crf data = data num threads = num threads weight = weight instances constraints = bit set data size g e constraint constraint constraints constraint set state label map map bit set bitset = constraint pre process data instances constraints or bitset gpv = d e f a u l t g p v num threads > 1 executor = thread pool executor executors fixed thread pool num threads create reverse transition matrices crf initializes data structures mapping between a destination state and its source states transition indices crf r f create reverse transition matrices r f crf counts = crf num states si = 0 si < crf num states si++ r f state prev state = r f state crf get state si di = 0 di < prev state num destinations di++ sj = prev state get destination state di get index counts sj ++ reverse trans = crf num states reverse trans indices = crf num states i = 0 i < counts length i++ reverse trans i = counts i reverse trans indices i = counts i indices = crf num states si = 0 si < crf num states si++ r f state prev state = r f state crf get state si di = 0 di < prev state num destinations di++ sj = prev state get destination state di get index reverse trans sj indices sj = si reverse trans indices sj indices sj = di indices sj ++ get num crf get num get buffer crf get get buffer get parameter index crf get get parameter index set params crf get set params crf weights value changed set parameter index value crf get set parameter index value crf weights value changed cache value and gradient compute and cache lattices gc err used memory + format % 3f runtime get runtime total memory runtime get runtime free memory 1000000 + before lattice list< sum lattice> lattices = list< sum lattice> num threads == 1 ii = 0 ii < data size ii++ instances constraints get ii sum lattice lattice = sum lattice crf feature vector sequence data get ii get data lattices add lattice lattices add mutli threaded list< callable< void>> tasks = list< callable< void>> data size < num threads num threads = data size increment = data size num threads start = 0 end = increment thread = 0 thread < num threads thread++ tasks add sum lattice task crf data instances constraints start end start += increment thread == num threads 2 end = data size end += increment run all threads and wait them to finish executor all tasks interrupted ie ie print stack trace callable< void> task tasks lattices add all sum lattice task task get lattices lattices size == data size lattices size + + data size err done computing lattices g e constraint constraint constraints constraint zero expectations constraint compute expectations lattices err done computing expectations gc err used memory + format % 3f runtime get runtime total memory runtime get runtime free memory 1000000 + after lattice compute g e value cached value = 0 g e constraint constraint constraints cached value += constraint get value cached gradient zero compute g e gradient num threads == 1 ii = 0 ii < data size ii++ instances constraints get ii sum lattice lattice = lattices get ii feature vector sequence fvs = feature vector sequence data get ii get data g e lattice fvs lattice get gammas lattice get xis crf reverse trans reverse trans indices cached gradient constraints multi threaded list< callable< void>> tasks = list< callable< void>> data size < num threads num threads = data size increment = data size num threads start = 0 end = increment thread = 0 thread < num threads thread++ list< g e constraint> constraints copy = list< g e constraint> g e constraint constraint constraints constraints copy add constraint copy tasks add g e lattice task crf data lattices constraints copy instances constraints reverse trans reverse trans indices start end start += increment thread == num threads 2 end = data size end += increment run all threads and wait them to finish executor all tasks interrupted ie ie print stack trace callable< void> task tasks cached gradient plus equals g e lattice task task get gradient 1 err done computing gradient cached value += crf get gaussian prior gpv cached gradient plus equals gaussian prior gradient crf get gpv err done computing regularization weight != 1 cached value = weight err g e value = + cached value set gaussian prior variance variance gpv = variance get value gradient buffer crf get weights value change stamp != cache cache value and gradient cache = crf get weights value change stamp t o d o will also multiply prior active! cached gradient get buffer weight != 1 matrix ops times equals buffer weight get value crf get weights value change stamp != cache cache value and gradient cache = crf get weights value change stamp cached value should be called after training complete to shutdown all threads shutdown executor == executor shutdown executor await termination 30 time unit s e o n d s interrupted e e print stack trace executor shutdown now size == 0 all tasks didn t finish sum lattice task callable< void> start end list< sum lattice default> lattices instance list data r f crf bit set instances constraints sum lattice task r f crf instance list data bit set instances constraints start end crf = crf data = data start = start end = end lattices = list< sum lattice default> instances constraints = instances constraints list< sum lattice default> get lattices lattices call ii = start ii < end ii++ instances constraints get ii instance instance = data get ii sum lattice lattice = sum lattice crf feature vector sequence instance get data lattices add lattice lattices add g e lattice task callable< void> start end list< g e constraint> constraints list< sum lattice> lattices instance list data r f crf r f factors gradient bit set instances constraints reverse trans reverse trans indices crf r f data unlabeled data lattices cached sum lattices constraints list g e constraints instances constraints bit set which indices whether any constraints fire an instance reverse trans source state indices each destination state reverse trans indices transition indices each destination state start position in unlabeled data where thread starts computing end position in unlabeled data where thread stops computing g e lattice task r f crf instance list data list< sum lattice> lattices list< g e constraint> constraints bit set instances constraints reverse trans reverse trans indices start end crf = crf data = data lattices = lattices constraints = constraints start = start end = end gradient = r f factors crf instances constraints = instances constraints reverse trans = reverse trans reverse trans indices = reverse trans indices r f factors get gradient gradient call ii = start ii < end ii++ instances constraints get ii sum lattice lattice = lattices get ii feature vector sequence fvs = feature vector sequence data get ii get data g e lattice fvs lattice get gammas lattice get xis crf reverse trans reverse trans indices gradient constraints 