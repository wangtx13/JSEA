2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types io buffered input stream io io input stream io output stream io i o io input stream io output stream io stream io serializable list bit set collection collections hash map iterator list logging logger pipe feature sequence2 feature vector pipe noop pipe pipe pipe serial pipes pipe target2 label pipe token sequence2 feature sequence pipe iterator random token sequence iterator logger randoms a list instances typically used training or testing a algorithm <p> all instances in list will have been passed through same link pipe pipe and thus must also share same data and target alphabets instance list keeps a reference to pipe and two alphabets <p> most way adding instances to an instance list through <code>add pipe input iterator < code> pipe input iterators are a way mapping general data sources into instances suitable processing through a pipe each link types instance pulled from pipe input iterator instance list copies instance and runs copy through its pipe resultant destructive modifications before saving modified instance on its list usual way in which instances are transformed pipes <p> instance list also contains randomly generating lists feature vectors splitting lists into non overlapping subsets useful test train splits and iterators cross validation instance pipe author andrew mc callum <a href= mailto >mccallum edu< a> instance list list< instance> serializable iterable< instance> alphabet carrying logger logger = logger get logger instance list get name hash map< instance double> inst weights = should never be set a classifier trainer it should be used in conjunction a classifier s feature selection or perhaps it should be removed from here and there should be a classifier trainer train instance list feature selection feature selection feature selection = feature selection per label feature selection = pipe pipe alphabet data alphabet target alphabet data = target = construct an instance list having given capacity given pipe typically instances added to instance list will have gone through pipe example using instance list add thru pipe but not required instanace list will obtain its data alphabet and target alphabet from pipe it required that all instances in instance list share these alphabets pipe pipe used to process instances added via add thru pipe capacity initial capacity list will grow further necessary x x x not very useful should perhaps be removed instance list pipe pipe capacity capacity pipe = pipe construct an instance list initial capacity 10 given pipe typically instances added to instance list will have gone through pipe example using instance list add thru pipe but not required instanace list will obtain its data alphabet and target alphabet from pipe it required that all instances in instance list share these alphabets pipe pipe used to process instances added via add thru pipe instance list pipe pipe pipe 10 construct an instance list initial capacity 10 a noop pipe used in those infrequent circumstances when instances typically would not have further processing and containing vocabularies are entered directly into <code> instance list< code> example creation a random <code> instance list< code> using <code> dirichlet< code>s and <code> multinomial< code>s < p> data alphabet vocabulary added instances data fields target alphabet vocabulary added instances targets instance list alphabet data alphabet alphabet target alphabet noop data alphabet target alphabet 10 data alphabet = data alphabet target alphabet = target alphabet not yet set pipe pipe instance pipe instance carrier unsupported operation instance list has yet to have its pipe set + could happen calling instance list add instance list read resolve stream not yet set pipe serial u = 1 pipe not yet set pipe = not yet set pipe creates a list that will have its pipe set later when its first instance added deprecated pipe never set you use constructor instance list not yet set pipe creates a list consisting randomly generated <code> feature vector< code>s xxx perhaps split these out into a utility instance list randoms r generator all random ness used here dirichlet centroid includes a alphabet centroid average alpha mean gaussian mean on sum alphas centroid average alpha variance gaussian variance on sum alphas feature vector size poisson lambda instance count poisson lambda names serial pipes pipe token sequence2 feature sequence feature sequence2 feature vector target2 label centroid print iterator< instance> iter = random token sequence iterator r centroid centroid average alpha mean centroid average alpha variance feature vector size poisson lambda instance count poisson lambda names add thru pipe iter alphabet dict size size alphabet ret = alphabet i = 0 i < size i++ ret lookup index feature +i ret names size size ret = size i = 0 i < size i++ ret i = +i ret instance list randoms r alphabet vocab names mean instances per label r dirichlet vocab 2 0 30 0 10 mean instances per label names instance list randoms r vocab size num classes r dirichlet dict size vocab size 2 0 30 0 10 20 names size num classes instance list shallow clone instance list ret = instance list pipe size i = 0 i < size i++ ret add get i inst weights == ret inst weights = ret inst weights = hash map< instance double> inst weights clone should we really be so shallow to not make copies these following instance variables? akm 1 2008 ret feature selection = feature selection ret per label feature selection = per label feature selection ret pipe = pipe ret data alphabet = data alphabet ret target alphabet = target alphabet ret data = data ret target = target ret clone shallow clone instance list sub list start end instance list other = clone empty i = start i < end i++ other add get i other instance list sub list proportion proportion > 1 0 illegal argument proportion must <= 1 0 instance list other = instance list clone other shuffle random proportion = other size i = 0 i < proportion i++ other add get i other adds to list every instance generated iterator passing each one through instance list s pipe t o d o should be renamed add piped iterator< instance> ii add thru pipe iterator< instance> ii debug iterator< instance> piped instance iterator = pipe iterator from ii piped instance iterator has next add piped instance iterator next out add instance + piped instance iterator next get name gsc to add one instance at a time adds input instance to list after passing it through instance list s pipe <p> several instances are to be added then accumulate them in a list\< instance\> and use <tt>add thru pipe iterator< instance> < tt> instead add thru pipe instance inst add thru pipe single instance iterator inst constructs and appends an instance to list passing it through list s pipe and assigning it specified weight <code>true< code> deprecated use trainingset add thru pipe instance data target name source instead deprecated add data target name source instance weight instance inst = instance data target name source iterator< instance> ii = pipe iterator from single instance iterator inst ii has next add ii next instance weight constructs and appends an instance to list passing it through list s pipe weight 1 0 <code>true< code> deprecated use trainingset add instance data target name source instead deprecated add data target name source add data target name source 1 0 appends instance to list without passing instance through instance list s pipe alphabets instance must match alphabets instance list <code>true< code> add instance instance data alphabet == data alphabet = instance get data alphabet target alphabet == target alphabet = instance get target alphabet ! alphabet alphabets match instance gsc alphabet data alphabet = instance get data alphabet alphabet target alphabet = instance get target alphabet builder sb = builder sb append alphabets t match sb append instance + data alphabet == ? data alphabet size + + target alphabet == ? target alphabet size + data alphabet = get data alphabet target alphabet = get target alphabet sb append instance list + data alphabet == ? data alphabet size + + target alphabet == ? target alphabet size + illegal argument sb to illegal argument alphabets t match instance + instance get alphabets + instance list +this get alphabets data == data = instance data get pipe != pipe target processing instance target != target = instance target get once it added to an instance list generally speaking instance shouldn t change there are exceptions and these you can instance unlock then instance lock again instance lock add instance appends instance to list without passing it through instance list s pipe assigning it specified weight <code>true< code> add instance instance instance weight call add above and make sure we correctly handle adding first instance to list ret = add instance !ret some reason a subclass instance list refuses to add instance be sure not to rest ret instance weight != 1 0 weight 1 0 everything not in hash map inst weights == inst weights = hash map< instance double> inst weights get instance != illegal argument you cannot add same instance twice to an instance list when it has non 1 0 weight + trying adding instance shallow copy instead inst weights put instance instance weight ret prepare to remove instance instance inst weights != inst weights remove instance instance set index instance instance prepare to remove get index set index instance add index instance element illegal state not yet instance remove index prepare to remove get index remove index remove instance instance prepare to remove instance remove instance add all collection<? instance> instances instance instance instances add instance add all index collection <? instance> illegal state add all collection not supported instance list n clear clear inst weights clear but retain all other instance variables deprecated remove it seems like too specialized behavior to be here intentionally add some noise into data real random ratio added fuchun peng sept 2003 noisify ratio list instances = list instances size ratio >= 0 ratio <= 1 instance size = size noise instance num = ratio instance size random r = random out noise instance num + + instance size gsc parameterizing list< integer> randnumlist = list< integer> noise instance num i=0 i<noise instance num i++ rand index = r next instance size out i + + rand index nn = rand index randnumlist index nn != 1 i randnumlist add nn label alphabet targets = label alphabet pipe get target alphabet real rand num = 0 i=0 i<randnumlist size i++ index = randnumlist get i value index randnumlist instance inst = get index rand index = r next targets size out i + + index + + inst get target to + + targets lookup label rand index old target str = inst get target to target str = targets lookup label rand index to !old target str equals target str inst un lock inst set target targets lookup label rand index inst lock real rand num ++ out i + + index + + inst get target to + + targets lookup rand index set instance index inst real ratio = real rand num instance size real ratio instance list clone empty clone empty into instance list pipe a precursor to cloning subclasses instance list instance list clone empty into instance list ret ret inst weights = t copy these because its empty! inst weights == ? hash map< instance double> inst weights clone xxx should feature selection and per label be cloned? note that roosting trainer currently depends on not cloning its splitting ret feature selection = feature selection ret per label feature selection = per label feature selection ret data = data ret target = target ret data alphabet = data alphabet ret target alphabet = target alphabet ret shuffle random r collections shuffle r shuffles elements list among several smaller lists proportions a list numbers not necessarily summing to 1 which when normalized correspond to proportion elements in each sublist and all split not transfer instance weights to resulting instance lists r source randomness to use in shuffling one <code> instance list< code> each element <code>proportions< code> instance list split random r proportions instance list shuffled = shallow clone shuffled shuffle r shuffled split in order proportions instance list split proportions split random current time millis proportions chops list into several sequential sublists proportions a list numbers corresponding to proportion elements in each sublist not already normalized to sum to 1 0 it will be normalized here one <code> instance list< code> each element <code>proportions< code> instance list split in order proportions instance list ret = instance list proportions length maxind = proportions clone matrix ops normalize maxind i = 0 i < maxind length i++ ret i = clone empty note that we are passing on feature selection here i > 0 maxind i += maxind i 1 i = 0 i < maxind length i++ fill maxind highest instance index to go in each corresponding instance list maxind i = math rint maxind i size i = 0 j = 0 i < size i++ gives a slight bias toward putting an extra instance in last instance list i >= maxind j j < ret length j++ ret j add get i ret instance list split in order counts instance list ret = instance list counts length will leave ununsed instances sum counts != size ! idx = 0 num = 0 num < counts length num++ ret num = clone empty i = 0 i < counts num i++ ret num add get idx transfer weights? idx++ ret a pair lists such that first list in pair contains every <code>m< code>th element list starting first second list contains all remaining elements instance list split in two modulo m instance list ret = instance list 2 ret 0 = clone empty ret 1 = clone empty i = 0 i < size i++ i % m == 0 ret 0 add get i ret 1 add get i ret instance list sample replacement random r num samples instance list ret = clone empty i = 0 i < num samples i++ ret add get r next size ret an <code> instance list< code> same size where instances come from random sampling replacement list using instance weights instances all have their weights set to one added gary ghuang deprecated move to instance list utils instance list sample instance weights random r weights = size i = 0 i < weights length i++ weights i = get instance weight i sample weights r weights an <code> instance list< code> same size where instances come from random sampling replacement list using given weights length weight must be same length list instances all have their weights set to one added gary ghuang instance list sample weights random r weights weights length != size illegal argument length weight vector must equal number instances size == 0 clone empty sum weights = 0 i = 0 i < size i++ weights i < 0 illegal argument weight vector must be non negative sum weights += weights i sum weights <= 0 illegal argument weights must sum to positive value instance list list = instance list get pipe size probabilities = size sum probs = 0 i = 0 i < size i++ sum probs += r next probabilities i = sum probs matrix ops times equals probabilities sum weights sum probs make sure rounding didn t mess things up probabilities size 1 = sum weights sampling a = 0 b = 0 sum probs = 0 a < size b < size sum probs += weights b a < size probabilities a <= sum probs list add get b list set instance weight a 1 a++ b++ list data field instances in list get data data target field instances in list get target target added fuchun replaces <code> instance< code> at position <code>index< code> a one set instance index instance instance get data alphabet equals instance get data alphabet get target alphabet equals instance get target alphabet set index instance get instance weight instance instance inst weights != value = inst weights get instance value != value 1 0 get instance weight index index > size illegal argument index out bounds index= +index+ size= +this size inst weights != value = inst weights get get index value != value 1 0 set instance weight index weight set instance weight get index weight set instance weight instance instance weight weights 1 0 are not explicitly stored in hash weight == 1 0 weights hash does not we are done inst weights == otherwise there a weight currently set value = inst weights get instance there no value set or value 1 0 we re done value == || value value == weight otherwise remove value inst weights remove instance initialize weights hash it does not inst weights == inst weights = hash map< instance double> add value overriding any previous value inst weights put instance weight set feature selection feature selection selected features selected features != selected features get alphabet != xxx we allow a vocabulary here? r f3 selected features get alphabet != get data alphabet illegal argument vocabularies not match feature selection = selected features feature selection get feature selection feature selection set per label feature selection feature selection selected features selected features != i = 0 i < selected features length i++ selected features i get alphabet != get data alphabet illegal argument vocabularies not match per label feature selection = selected features feature selection get per label feature selection per label feature selection sets target field to <code>null< code> in all instances makes unlabeled data remove targets instance instance instance set target sets source field to <code>null< code> in all instances will often save memory when raw data had been placed in that field remove sources i = 0 i < size i++ get i clear source constructs a <code> instance list< code> deserialized from <code>file< code> value <code>file< code> then deserialize from link in instance list load input stream ois to equals ois = input stream in ois = input stream buffered input stream input stream instance list ilist = instance list ois read ois close ilist e e print stack trace illegal argument couldn t read instance list from +file saves <code> instance list< code> to <code>file< code> value <code>file< code> then serialize to link out save output stream ois to equals ois = output stream out ois = output stream output stream ois write ois close e e print stack trace illegal argument couldn t save instance list to +file serialization instance list serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o i size out write u r r e n t s e r i a l v e r s i o n out write inst weights out write pipe read input stream in i o not found i size = in read inst weights = hash map< instance double> in read pipe = pipe in read data alphabet == size >0 instance instance = get 0 data alphabet = instance get data alphabet pipe get data alphabet !=null data alphabet = pipe get data alphabet target alphabet == size >0 instance instance = get 0 target alphabet = instance get target alphabet pipe get target alphabet !=null target alphabet = pipe get target alphabet added culotta <code> cross validation iterator< code> allows iterating over pairs <code> instance list< code> where each pair split into training testing based on nfolds cross validation iterator iterator< instance list > serializable nfolds instance list folds index nfolds number folds to split instance list into seed seed random number used to split instance list cross validation iterator nfolds seed nfolds > 0 nfolds + nfolds nfolds = nfolds index = 0 folds = instance list nfolds fraction = 1 nfolds proportions = nfolds i=0 i < nfolds i++ proportions i = fraction folds = split random seed proportions cross validation iterator nfolds nfolds 1 has next index < nfolds next training testing split a pair lists where <code> instance list 0 < code> larger split training and <code> instance list 1 < code> smaller split testing instance list next split instance list ret = instance list 2 ret 0 = instance list pipe i=0 i < folds length i++ i==index iterator< instance> iter = folds i iterator iter has next ret 0 add iter next ret 1 = folds index shallow clone index++ ret next split given number folds you want in training data instance list next split num train folds instance list ret = instance list 2 ret 0 = instance list pipe ret 1 = instance list pipe train on folds index index+num train folds test on rest i = 0 i < folds length i++ foldno = index + i % folds length instance list add to i < num train folds add to = ret 0 add to = ret 1 iterator< instance> iter = folds foldno iterator iter has next add to add iter next index++ ret instance list next next split remove unsupported operation pipe through which each added <code> instance< code> passed which may be <code>null< code> pipe get pipe pipe change pipe associated instance list very dangerous and should only be used in extreme circumstances!! set pipe pipe p alphabet alphabets match p pipe = p <code> alphabet< code> mapping features data to integers alphabet get data alphabet data alphabet == pipe != data alphabet = pipe get data alphabet pipe == || pipe get data alphabet == || pipe get data alphabet == data alphabet data alphabet <code> alphabet< code> mapping target output labels to integers alphabet get target alphabet target alphabet == pipe != target alphabet = pipe get target alphabet pipe == || pipe get target alphabet == || pipe get target alphabet == target alphabet target alphabet alphabet get alphabet get data alphabet alphabet get alphabets alphabet get data alphabet get target alphabet label vector target label size == 0 ! get 0 get target labeling illegal state target not a labeling counts = get target alphabet size i = 0 i < size i++ instance instance = get i labeling l = labeling instance get target l add to counts get instance weight i label vector label alphabet get target alphabet counts cross validation iterator cross validation iterator nfolds seed cross validation iterator nfolds seed cross validation iterator cross validation iterator nfolds cross validation iterator nfolds t a r g e t p r o p e r t y = target i m not sure these best belong here on other hand it easy to find and centrally located here a k m jan 2006 hide some labels proportion to hide randoms r i = 0 i < size i++ r next proportion to hide instance instance = get i instance un lock instance get property t a r g e t p r o p e r t y != instance get target instance set property t a r g e t p r o p e r t y instance get target instance set target instance lock hide some labels bit set bs i = 0 i < size i++ bs get i instance instance = get i instance un lock instance get property t a r g e t p r o p e r t y != instance get target instance set property t a r g e t p r o p e r t y instance get target instance set target instance lock unhide all labels i = 0 i < size i++ instance instance = get i t instance get target == t=instance get property t a r g e t p r o p e r t y != instance un lock instance set target t instance lock 