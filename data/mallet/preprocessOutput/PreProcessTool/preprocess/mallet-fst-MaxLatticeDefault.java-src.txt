2005 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author fernando pereira <a href= mailto pereira cis upenn >pereira cis upenn edu< a> author andrew mc callum <a href= mailto >mccallum edu< a> io i o io input stream io output stream io print writer io serializable list list logging level logging logger types sequence types sequence types sequence pair alignment transducer state transducer transition iterator logger search a star search a star state search search node search search state full dynamic programming viterbi max product lattice algorithm author fernando pereira author andrew mc callum max lattice max lattice logger logger = logger get logger max lattice get name logger set level level i n f o transducer t sequence< object> input output lattice length viterbi node lattice weight cache first last weight cache caches num caches max caches transducer get transducer t sequence get input input sequence get output output viterbi node a star state input position position input used to enter node state state transducer state from which node entered output transducer output produced on entering node delta = transducer i m p o s s i b l e w e i g h t viterbi node max weight predecessor = viterbi node input position state state input position = input position state = state one required a star state completion cost delta input position == 0 state get initial weight > transducer i m p o s s i b l e w e i g h t previous state iterator a star state next state iterator prev found weight weights previous state iterator prev = 0 input position > 0 j = state get index weights = t num states weight cache = get cache input position 1 s = 0 s < t num states s++ weights s = weight s j look ahead weights != !found prev < t num states prev++ weights prev > transducer i m p o s s i b l e w e i g h t found = has next look ahead weights != prev < t num states search state next state look ahead weight = weights prev++ found = get viterbi node input position 1 prev 1 required search state a star state cost weight weight weight next state iterator get next states previous state iterator weight cache weight cache prev next weight position weight cache position weight = t num states t num states init position init position position = position i = 0 i < t num states i++ j = 0 j < t num states j++ weight i j = transducer i m p o s s i b l e w e i g h t weight cache get cache position weight cache cache = caches position cache == no cache position out cache + num caches + + max caches num caches < max caches create another cache cache = weight cache position num caches++ == 0 first = last = cache steal least used cache cache = last caches cache position = cache init position i = 0 i < t num states i++ lattice position i == || lattice position i delta == transducer i m p o s s i b l e w e i g h t state s = t get state i transition iterator iter = s transition iterator input position output position iter has next state d = iter next cache weight i d get index = iter get weight caches position = cache cache != first move to front cache == last last = cache prev cache prev != cache prev next = cache next cache next = first cache prev = first prev = cache first = cache cache viterbi node get viterbi node ip state index lattice ip state index == lattice ip state index = viterbi node ip t get state state index lattice ip state index max lattice transducer t sequence input sequence t input sequence 100000 max lattice transducer t sequence input sequence sequence output sequence t input sequence output sequence 100000 initiate viterbi decoding input sequence contrained to match non parts output sequence max caches indicates how much state to memoize in n best decoding max lattice transducer t sequence input sequence sequence output sequence max caches initializes forward path but does not yet backward pass t = t max caches < 1 max caches = 1 max caches = max caches input sequence != logger loggable level f i n e logger fine starting viterbi lattice logger fine input ip = 0 ip < input sequence size ip++ logger fine + input sequence get ip logger fine output output sequence == logger fine op = 0 op < output sequence size op++ logger fine + output sequence get op logger fine input = input sequence output = output sequence lattice length = input size +1 num states = t num states lattice = viterbi node lattice length num states caches = weight cache lattice length 1 viterbi forward logger fine starting viterbi any initial state = i = 0 i < num states i++ initial weight = t get state i get initial weight initial weight > transducer i m p o s s i b l e w e i g h t viterbi node n = get viterbi node 0 i n delta = initial weight any initial state = !any initial state logger warning viterbi no initial states! ip = 0 ip < lattice length 1 ip++ i = 0 i < num states i++ lattice ip i == || lattice ip i delta == transducer i m p o s s i b l e w e i g h t state s = t get state i transition iterator iter = s transition iterator input ip output ip logger loggable level f i n e logger fine starting viterbi transition iteration from state + s get name + on input + input get ip iter has next state destination = iter next logger loggable level f i n e logger fine viterbi input pos= +ip + source= +s get name + dest= +destination get name + viterbi node destination node = get viterbi node ip+1 destination get index destination node output = iter get output weight = lattice ip i delta + iter get weight ip == lattice length 2 weight += destination get weight weight > destination node delta logger loggable level f i n e logger fine viterbi input pos= +ip + source dest= +destination get name + weight increased to +weight+ source= + s get name destination node delta = weight destination node max weight predecessor = lattice ip i get delta ip state index lattice != get viterbi node ip state index delta runtime attempt to called get delta when lattice not stored list< sequence pair alignment< viterbi node>> viterbi node alignment cache = perform backward pass viterbi returning n best sequences viterbi nodes each viterbi node contains state output symbol and other note that length each viterbi node sequence input length+1 because first element sequence start state and first input output symbols occur on transition from a start state to next state these first input output symbols are stored in second viterbi node in sequence last viterbi node in sequence corresponds to state and has last input output symbols list< sequence pair alignment< viterbi node>> best viterbi node sequences n viterbi node alignment cache != viterbi node alignment cache size >= n viterbi node alignment cache num = 0 i = 0 i < t num states i++ lattice lattice length 1 i != lattice lattice length 1 i delta > transducer i m p o s s i b l e w e i g h t num final++ viterbi node nodes = viterbi node num f = 0 i = 0 i < t num states i++ lattice lattice length 1 i != lattice lattice length 1 i delta > transducer i m p o s s i b l e w e i g h t nodes f++ = lattice lattice length 1 i a star search = a star nodes lattice length t num states list< sequence pair alignment< viterbi node>> outputs = list< sequence pair alignment< viterbi node>> n i = 0 i < n search has next i++ gsc removing unnecessary cast search node ans = search next weight = ans get cost viterbi node seq = viterbi node lattice length commented out so we get start state viterbi node akm 12 2007 ans = ans get parent ans now corresponds to viterbi node after first transition j = 0 j < lattice length j++ viterbi node v = viterbi node ans get state v input position == j was == j+1 seq j = v ans = ans get parent outputs add sequence pair alignment< viterbi node> input sequence< viterbi node> seq weight viterbi node alignment cache = outputs outputs list< sequence pair alignment< state>> state alignment cache = perform backward pass viterbi returning n best sequences states note that length each state sequence input length+1 because first element sequence start state and first input output symbols occur on transition from a start state to next state last state in sequence corresponds to state list< sequence pair alignment< state>> best state alignments n state alignment cache != state alignment cache size >= n state alignment cache best viterbi node sequences n ensure that viterbi node alignment cache has at least size n list< sequence pair alignment< state>> ret = list< sequence pair alignment< state>> n i = 0 i < n i++ state ss = state lattice length sequence< viterbi node> vs = viterbi node alignment cache get i output j = 0 j < lattice length j++ ss j = vs get j state here where we grab state from viterbi node ret add sequence pair alignment< state> input sequence< state> ss viterbi node alignment cache get i get weight state alignment cache = ret ret sequence pair alignment< state> best state alignment best state alignments 1 get 0 list< sequence< state>> best state sequences n list< sequence pair alignment< state>> a = best state alignments n list< sequence< state>> ret = list< sequence< state>> n i = 0 i < n i++ ret add a get i output ret sequence< state> best state sequence best state alignments 1 get 0 output list< sequence pair alignment< object>> output alignment cache = list< sequence pair alignment< object>> best output alignments n output alignment cache != output alignment cache size >= n output alignment cache best viterbi node sequences n ensure that viterbi node alignment cache has at least size n list< sequence pair alignment< object>> ret = list< sequence pair alignment< object>> n i = 0 i < n i++ ss = lattice length 1 sequence< viterbi node> vs = viterbi node alignment cache get i output j = 0 j < lattice length 1 j++ ss j = vs get j+1 output here where we grab output from viterbi node destination ret add sequence pair alignment< object> input sequence< object> ss viterbi node alignment cache get i get weight output alignment cache = ret ret sequence pair alignment< object> best output alignment best output alignments 1 get 0 list< sequence< object>> best output sequences n best output alignments n ensure that output alignment cache has at least size n list< sequence< object>> ret = list< sequence< object>> n i = 0 i < n i++ ret add output alignment cache get i output ret t o d o consider caching result sequence< object> best output sequence best output alignments 1 get 0 output best weight best output alignments 1 get 0 get weight increment states and transitions a count 1 0 along best state sequence provides a so called viterbi training approximation increment transducer transducer incrementor incrementor we are only going to increment along single best path get 0 below we could consider having a increment transducer transducer incrementor incrementor counts where number n best paths to increment would be determined counts length sequence pair alignment< viterbi node> viterbi node alignment = best viterbi node sequences 1 get 0 sequence length = viterbi node alignment output size sequence length == viterbi node alignment input size not sure works unequal input output lengths increment initial state incrementor increment initial state viterbi node alignment output get 0 state 1 0 increment state incrementor increment state viterbi node alignment output get sequence length 1 state 1 0 ip = 0 ip < viterbi node alignment input size 1 ip++ transition iterator iter = viterbi node alignment output get ip state transition iterator input ip output ip xxx assumes that a transition completely identified and made unique its destination state and output may not be true! num increments = 0 iter has next iter next equals viterbi node alignment output get ip+1 state iter get output equals viterbi node alignment output get ip output incrementor increment transition iter 1 0 num increments++ num increments > 1 illegal state more than one satisfying transition found num increments == 0 illegal state no satisfying transition found elementwise accuracy sequence reference output accuracy = 0 sequence output = best output sequence reference output size == output size i = 0 i < output size i++ logger fine token accuracy ref +reference output get i + viterbi +output get i reference output get i to equals output get i to accuracy++ logger info number correct + accuracy + out + output size accuracy output size token accuracy sequence reference output print writer out sequence output = best output sequence accuracy = 0 test reference output size == output size i = 0 i < output size i++ logger fine token accuracy ref +reference output get i + viterbi +output get i test = output get i to out != out test reference output get i to equals test accuracy++ logger info number correct + accuracy + out + output size accuracy output size factory max lattice factory serializable max lattice max lattice transducer trans sequence input sequence sequence output sequence max lattice trans input sequence output sequence serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n read input stream in i o not found in read 