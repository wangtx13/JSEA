2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> types logging arrays types matrix logger deprecated very sparsely used and i think we can get rid it akm 1 2008 t o d o remove classpublic matrix2 dense matrix logger logger = logger get logger matrix2 get name nr nc matrix2 values nr nc values length == nr nc values = values nr = nr nc = nc matrix2 nr nc nr nc nr nc matrix2 values nr = values length nc = values 0 length i = 1 i < nr i++ values i length != nc illegal argument trying to initialize matrix having columns to different lengths values = nr nc i = 0 i < nr i++ arraycopy values i 0 values i nc nc matrix2 value nr nc nr = nr nc = nc values = nr nc arrays fill values value get num dimensions 2 get dimensions sizes sizes 0 = nr sizes 1 = nc 2 value row index col index values nc row index + col index copy into starting index arraycopy values 0 starting index values length copy contents into matrix2 starting at index i in and continuing to fill all matrix2 copy from starting index arraycopy starting index values 0 values length set value row index col index value values nc row index + col index = value size matches constant matrix m m matrix2 matrix2 m nr == nr matrix2 m nc == nc other dims = 10 num dimensions = get dimensions other dims num dimensions == 2 other dims 0 == nr other dims 1 == nc size matches matrix2 m m nr == nr m nc == nc get num rows nr get num cols nc matrix2 transpose matrix2 ret = matrix2 nc nr i = 0 i < nr i++ j = 0 j < nc j++ ret values j nr+i = values i nc+j ret matrix value indices indices length == 2 values indices 0 nc+indices 1 set value indices val indices length == 2 values indices 0 nc+indices 1 = val access using a single index single index indices indices length == 2 indices indices 0 nc+indices 1 single to indices i indices indices length == 2 i < nc nr indices 0 = i nc indices 1 = i%nc single value i values i set single i value values i = value single size nc nr constant matrix clone matrix clone matrix2 matrix2 clone matrix2 matrix2 ret = matrix2 nr nc arraycopy values 0 ret values 0 values length ret set all v i = 0 i < values length i++ values i = v selected it reverses selection fselection implies that all features are selected all values will be changed unless selected set all v feature selection fselection selected fselection == selected == logger info matrix2 set all using feature selection==null set all v logger info matrix2 set all using feature selection i = 0 i < values length i++ fselection contains i ^ !if selected values i = v selected it reverses selection fselection implies that all features are selected all values in row will be changed unless selected row set all ri v feature selection fselection selected ri < nr fselection == selected == ci = 0 ci < nc ci++ values ri nc+ci = v xxx temporary check full selection fselection next deselected index 0 == nc ci = 0 ci < nc ci++ fselection contains ci ^ !if selected values ri nc+ci = v plus equals ri ci value ri < nr ci < nc values ri nc+ci += value row plus equals ri vector v factor ri < nr vli = 0 vli < v num locations vli++ out matrix2 values length= +values length+ index= + ri nc+v index at location vli + ri= +ri+ nc= +nc+ v index at location +vli+ = +v index at location vli values ri nc+v index at location vli += v value at location vli factor added fuchun row plus equals ri v factor ri < nr vli = 0 vli < nc vli++ values ri nc+vli += v factor column plus equals ci vector v factor ci < nc vli = 0 vli < v num locations vli++ values v index at location vli nc+ci += v value at location vli factor added fuchun column plus equals ci v factor ci < nc vli = 0 vli < nr vli++ values vli nc+ci += v factor row dot product ri vector v ret = 0 cil = 0 cil < v num locations cil++ ci = v index at location cil just skip it ci beyond boundaries matrix everything outside assumed to have zero value ci < nc ret += values ri nc+ci v value at location cil ret skip all column indices higher than max ci lets you store non vocabulary based in high column indices without fearing that they may later be accident dictionary grows you may pass selection row dot product ri vector v max ci feature selection selection ret = 0 selection != cil = 0 cil < v num locations cil++ ci = v index at location cil selection contains ci ci < nc ci <= max ci ret += values ri nc+ci v value at location cil cil = 0 cil < v num locations cil++ ci = v index at location cil ci < nc ci <= max ci ret += values ri nc+ci v value at location cil ret two norm squared ret = 0 i = 0 i < values length i++ ret += values i values i ret print i = 0 i < nr i++ j = 0 j < nc j++ out print + values i nc+j out to buffer sb = buffer i = 0 i < nr i++ j = 0 j < nc j++ sb append + values i nc+j sb append sb to 