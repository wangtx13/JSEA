2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e test junit framework assertion failed junit framework test junit framework test junit framework test suite random logging logger io i o io reader io buffered reader inference types general utils model reader types dirichlet types matrix types matrixn types tests test serializable random gnu trove t list torture tests inference in g r m m well actually they re not all that torturous but hopefully they re at least somewhat disconcerting author <a href= mailto casutton > charles sutton< a> $ test inference v 1 1 2007 10 22 21 37 40 exp $ test inference test logger logger = logger get logger test inference get name a p p x e p s i l o n = 0 15 algorithms = brute force inferencer variable elimination junction tree inferencer appx algs = t r p loopy b p only used log joint test now all algs = brute force inferencer junction tree inferencer t r p variable elimination loopy b p tree algs = tree b p list models list undirected model models factor graph trees factor tree margs test inference name name undirected model create chain graph variable vars = variable 5 undirected model model = undirected model add all variables to model i = 0 i < 5 i++ vars i = variable 2 add some links probs = 0 9 0 1 0 1 0 9 i = 0 i < 4 i++ variable pair = vars i vars i + 1 table factor pot = table factor pair probs model add factor pot e e print stack trace model undirected model create triangle variable vars = variable 3 i = 0 i < 3 i++ vars i = variable 2 undirected model model = undirected model vars pots = 0 2 0 8 0 1 0 9 0 7 0 3 0 5 0 5 0 6 0 4 0 8 0 2 0 35 0 65 pots = model add factor vars 0 vars 1 pots 0 model add factor vars 1 vars 2 pots 1 model add factor vars 2 vars 0 pots 2 table factor pot = table factor variable vars 0 pots 3 model add factor pot model table factor random edge potential random r variable v1 variable v2 max1 = v1 get num outcomes max2 = v2 get num outcomes matrix phi = matrixn max1 max2 i = 0 i < v1 get num outcomes i++ j = 0 j < v2 get num outcomes j++ phi set value i j r next rescale r next table factor variable v1 v2 phi table factor random node potential random r variable v max = v get num outcomes matrix phi = matrixn max i = 0 i < v get num outcomes i++ phi set single value i rescale r next table factor variable v phi scale d into range 0 2 0 8 rescale d 0 2 + 0 6 d undirected model create random graph num v num outcomes random r variable vars = variable num v i = 0 i < num v i++ vars i = variable num outcomes undirected model model = undirected model vars i = 0 i < num v i++ has one = j = i + 1 j < num v j++ r next has one = model add factor random edge potential r vars i vars j vars i has no edge potential add a node potential to keep things simple we ll require potential to be normalized !has one factor pot = random node potential r vars i pot normalize model add factor pot ensure exactly one connected component i = 0 i < num v i++ j = i + 1 j < num v j++ !model connected vars i vars j factor ptl = random edge potential r vars i vars j model add factor ptl model undirected model create random grid w h max outcomes random r variable vars = variable w h undirected model mdl = undirected model w h i = 0 i < w i++ j = 0 j < h j++ vars i j = variable r next max outcomes 1 + 2 i = 0 i < w i++ j = 0 j < h j++ factor ptl i < w 1 ptl = random edge potential r vars i j vars i + 1 j mdl add factor ptl j < h 1 ptl = random edge potential r vars i j vars i j + 1 mdl add factor ptl mdl undirected model create random tree nnodes max outcomes random r variable vars = variable nnodes undirected model mdl = undirected model nnodes i = 0 i < nnodes i++ vars i = variable r next max outcomes 1 + 2 add some random edges i = 0 i < nnodes i++ j = i + 1 j < nnodes j++ !mdl connected vars i vars j r next factor ptl = random edge potential r vars i vars j mdl add factor ptl ensure exactly one connected component i = 0 i < nnodes i++ j = i + 1 j < nnodes j++ !mdl connected vars i vars j out forced edge + i + + j factor ptl = random edge potential r vars i vars j mdl add factor ptl mdl list create test models random r = random 42 these models are all small so that we can run brute force inferencer on them factor graph mdls = factor graph create triangle create chain graph create random graph 3 2 r create random graph 3 3 r create random graph 6 3 r create random graph 8 2 r create random grid 3 2 4 r create random grid 4 3 2 r list arrays list mdls test uniform joint factor graph mdl = random graphs create uniform chain 3 expected = math log 8 i = 0 i < all algs length i++ inferencer inf = inferencer all algs i instance inf compute marginals mdl assignment iterator it = mdl assignment iterator it has next assignment assn = it assignment actual = inf lookup log joint assn equals incorrect joint inferencer +inf expected actual 1e 5 it advance test joint consistent i = 0 i < all algs length i++ mdl idx = 0 mdl idx < models length mdl idx++ mdl idx = 13 inferencer inf = inferencer all algs i instance factor graph mdl = models mdl idx inf compute marginals mdl assignment assn = assignment mdl mdl num variables equals math log inf lookup joint assn inf lookup log joint assn 1e 5 unsupported operation e loopy b p only handles edge ptls logger warning skipping + mdl idx + + i + + e e test factorized joint inferencer infs = inferencer all algs length models length i = 0 i < all algs length i++ mdl = 0 mdl < models length mdl++ inferencer alg = inferencer all algs i instance alg t r p t r p alg set random seed 1231234 alg compute marginals models mdl infs i mdl = alg unsupported operation e loopy b p only handles edge ptls logger warning skipping + mdl + + i + + e e ensure that lookup log joint consistent alg1 = 0 brute force alg2 = 1 alg2 < all algs length alg2++ mdl = 0 mdl < models length mdl++ inferencer inf1 = infs alg1 mdl inferencer inf2 = infs alg2 mdl inf1 == || inf2 == iterator it = models mdl assignment iterator it has next assignment assn = assignment it next joint1 = inf1 lookup log joint assn joint2 = inf2 lookup log joint assn logger finest log joint + inf1 + + inf2 + model + mdl + assn + assn + i n f1 + joint1 + + i n f2 + joint2 + log joint not equal btwn + general utils name inf1 + + and + general utils name inf2 + + model + mdl + + i n f1 + joint1 + + i n f2 + joint2 + math abs joint1 joint2 < 0 2 joint3 = inf1 lookup joint assn log joint joint not consistent + model + mdl + + assn maths almost equals joint3 math exp joint1 unsupported operation e var elim doesn t compute log joints let it slide logger warning skipping + inf1 + > + inf2 + + e test marginals factor joints = factor models length inferencer appx inferencers = construct all appx inferencers num exact algs = algorithms length num appx algs = appx inferencers length num algs = num exact algs + num appx algs mdl = 0 mdl < models length mdl++ joints mdl = factor num algs query every known graph every known alg i = 0 i < algorithms length i++ mdl = 0 mdl < models length mdl++ inferencer alg = inferencer algorithms i instance logger fine computing marginals model + mdl + alg + alg alg compute marginals models mdl joints mdl i = collect all marginals models mdl alg logger fine checking that results are consistent now make sure exact marginals are consistent same model mdl = 0 mdl < models length mdl++ max v = models mdl num variables vrt = 0 vrt < max v vrt++ alg1 = 0 alg1 < algorithms length alg1++ alg2 = 0 alg2 < algorithms length alg2++ factor joint1 = joints mdl alg1 vrt factor joint2 = joints mdl alg2 vrt time we get here a joint only there was an unsupported operation joint1 != joint2 != joint1 almost equals joint2 assertion failed e out test f a i l e d out model + mdl + vertex + vrt out algs + alg1 + and + alg2 + not consistent out m a r g i n a l from + alg1 out joint1 out m a r g i n a l from + alg2 out joint2 out marginals from + alg1 + i = 0 i < max v i++ out joints mdl alg1 i out marginals from + alg2 + i = 0 i < max v i++ out joints mdl alg2 i models mdl dump e compare all approximate algorithms against brute force logger fine checking approximate algorithms alg2 = 0 brute force appx idx = 0 appx idx < appx inferencers length appx idx++ inferencer alg = appx inferencers appx idx mdl = 0 mdl < models length mdl++ logger finer running inference alg + alg + model + mdl alg compute marginals models mdl unsupported operation e loopy b p does not support vertex potentials we ll let that slide alg belief propagation logger warning skipping model + mdl + alg + alg + inference unsupported e lookup all marginals vrt = 0 alg1 = num exact algs + appx idx max v = models mdl num variables joints mdl alg1 = factor max v iterator it = models mdl variables set iterator it has next vrt++ variable var = variable it next logger finer lookup marginal model + mdl + vrt + var + alg + alg factor ptl = alg lookup marginal var joints mdl alg1 vrt = ptl duplicate vrt = 0 vrt < max v vrt++ factor joint1 = joints mdl alg1 vrt factor joint2 = joints mdl alg2 vrt joint1 almost equals joint2 a p p x e p s i l o n assertion failed e out appx marginal test f a i l e d out inferencer + alg out model + mdl + vertex + vrt out joint1 dump to out joint2 dump to models mdl dump out all marginals i = 0 i < max v i++ out joints mdl alg1 i dump to out correct marginals i = 0 i < max v i++ out joints mdl alg2 i dump to e out tested + models length + undirected models inferencer construct all appx inferencers illegal access instantiation list algs = list appx algs length 2 i = 0 i < appx algs length i++ algs add appx algs i instance add a few that t fit algs add t r p set messager belief propagation sum product message strategy 0 8 algs add loopy b p set messager belief propagation sum product message strategy 0 8 algs add sampling inferencer gibbs sampler 10000 10000 algs add sampling inferencer exact sampler 1000 inferencer algs to inferencer algs size inferencer construct max product inferencers illegal access instantiation list algs = list algs add junction tree inferencer create max product algs add t r p create max product algs add loopy b p create max product inferencer algs to inferencer algs size factor collect all marginals factor graph mdl inferencer alg vrt = 0 num vertices = mdl num variables factor collector = factor num vertices iterator it = mdl variables set iterator it has next vrt++ variable var = variable it next collector vrt = alg lookup marginal var collector vrt != query model + mdl + vertex + var + alg + alg unsupported operation e allow unsupported inference to slide warning logger warning warning skipping model + mdl + alg + alg + inference unsupported collector test query random rand = random 15667 mdl idx = 0 mdl idx < models length mdl idx++ factor graph mdl = models mdl idx size = rand next 3 + 2 size = math min size mdl var set size collection vars = collection utils subset mdl variables set size rand variable var arr = variable vars to variable 0 assignment assn = assignment var arr size brute force inferencer brute = brute force inferencer factor joint = brute joint mdl marginal = joint marginalize vars value assn alg idx = 0 alg idx < appx algs length alg idx++ inferencer alg = inferencer appx algs alg idx instance alg t r p trp can t handle disconnected models which arise during query = alg query mdl assn equals failure on model +mdl idx+ alg +alg marginal a p p x e p s i l o n logger info test test query passed be careful that caching inference algorithms does not affect results here test serializable i = 0 i < algorithms length i++ inferencer alg = inferencer algorithms i instance test serialization alg alg i = 0 i < appx algs length i++ inferencer alg = inferencer appx algs i instance test serialization alg alg inferencer max algs = construct max product inferencers i = 0 i < max algs length i++ test serialization alg max algs i test serialization alg inferencer alg i o not found mdl idx = 0 mdl idx < models length mdl idx++ factor graph mdl = models mdl idx copy inferencer before calling b random seed issues inferencer alg2 = inferencer test serializable clone via serialization alg alg compute marginals mdl factor pre = collect all marginals mdl alg alg2 compute marginals mdl factor post2 = collect all marginals mdl alg2 compare marginals comparing marginals after serialzation on model +mdl pre post2 compare marginals msg factor pre factor post i = 0 i < pre length i++ factor ptl1 = pre i factor ptl2 = post i msg + + ptl1 dump to + + ptl2 dump to ptl1 almost equals ptl2 1e 3 really impossible after change to factor graph representation tests measurement numbers messages sent ignore test num messages mdl idx = 0 mdl idx < models length mdl idx++ undirected model mdl = models mdl idx t r p trp = t r p trp compute marginals mdl expected messages = mdl num variables 1 2 trp iterations used equals expected messages trp get total messages sent loopy b p loopy = loopy b p loopy compute marginals mdl expected messages = mdl get edge set size 2 loopy iterations used equals expected messages loopy get total messages sent undirected model create jt chain num nodes = 4 variable nodes = variable num nodes i = 0 i < num nodes i++ nodes i = variable 2 factor pots = table factor table factor variable nodes 0 nodes 1 1 2 5 4 table factor variable nodes 1 nodes 2 4 2 4 1 table factor variable nodes 2 nodes 3 7 3 6 9 i = 0 i < pots length i++ pots i normalize undirected model u graph = undirected model i = 0 i < num nodes 1 i++ u graph add factor pots i u graph j t h a i n t e s t t r e e = 2 create test trees random r = random 185 trees = factor graph random graphs create uniform chain 2 random graphs create uniform chain 4 create jt chain create random grid 5 1 3 r create random grid 6 1 2 r create random tree 10 2 r create random tree 10 2 r create random tree 8 3 r create random tree 8 3 r models list add all arrays list trees compute test tree margs tree margs = factor trees length brute force inferencer brute = brute force inferencer i = 0 i < trees length i++ factor graph mdl = trees i factor joint = brute joint mdl tree margs i = factor mdl num variables iterator it = mdl variables iterator it has next variable var = variable it next tree margs i mdl get index var = joint marginalize var test jt consistency mdl idx = 0 mdl idx < models length mdl idx++ undirected model mdl = models mdl idx junction tree inferencer jti = junction tree inferencer junction tree jt = jti build junction tree mdl iterator it = jt get vertices iterator it has next var set parent = var set it next iterator it2 = jt get children parent iterator it2 has next var set child = var set it2 next factor ptl = jt get sepset pot parent child set intersection = parent intersection child intersection equals ptl var set compare trp joint factor joint t r p trp assignment assn = prob1 = 0 0 prob2 = 0 0 var set all = hash var set joint var set iterator it = all assignment iterator it has next assn = assignment it next prob1 = trp lookup joint assn prob2 = joint value assn maths almost equals prob1 prob2 math abs prob1 prob2 < 0 01 assertion failed e out t e s t f a i l u r e in compare trp joint out at out assn out expected + prob2 out t r p + prob1 out expected joint out joint out t r p dump trp dump e test trp undirected model model = create triangle t r p trp = t r p set terminator t r p iteration terminator 200 brute force inferencer brute = brute force inferencer factor joint = brute joint model trp compute marginals model check joint discrete potential joint = brute joint model compare trp joint joint trp check all marginals iterator it = model variables iterator it has next variable var = variable it next factor marg1 = trp lookup marginal var factor marg2 = joint marginalize var marg1 almost equals marg2 a p p x e p s i l o n iterator it = model factors iterator it has next factor factor = factor it next factor marg1 = trp lookup marginal factor var set factor marg2 = joint marginalize factor var set marg1 almost equals marg2 a p p x e p s i l o n assertion failed e out t e s t f a i l u r e in compare trp margs out marg1 out marg2 out complete model model dump out t r p margs trp dump out all correct margs iterator it2 = model variables iterator it2 has next variable v2 = variable it2 next brute compute marginals model out brute lookup marginal v2 e test trp joint factor graph model = create triangle t r p trp = t r p set terminator t r p iteration terminator 25 trp compute marginals model each assignment to model check that t r p lookup log joint and t r p lookup joint are consistent var set all = hash var set model variables set iterator it = all assignment iterator it has next assignment assn = assignment it next log = trp lookup log joint assn prob = trp lookup joint assn maths almost equals math exp log prob logger info test trp joint passed tests that running t r p doesn t inadvertantly change potentials in original graph test trp non destructivity factor graph model = create triangle t r p trp = t r p t r p iteration terminator 25 brute force inferencer brute = brute force inferencer factor joint1 = brute joint model trp compute marginals model factor joint2 = brute joint model joint1 almost equals joint2 logger info test trp non destructivity passed test trp reuse t r p trp1 = t r p t r p iteration terminator 25 i = 0 i < models length i++ trp1 compute marginals models i hard to automatically right now logger info please ensure that all instantiations above run 25 iterations ensure that all edges touched works undirected model mdl = models 0 tree tree = trp1 almost random tree factory next tree mdl t r p trp2 = t r p t r p tree factory tree next tree factor graph mdl tree trp2 compute marginals mdl logger info ensure that above instantiation ran 1000 iterations a warning tree strs = < t r e e> + < v a r n a m e= v0 > + < f a t o r v a r s= v0 v1 > + < v a r n a m e= v1 > + < f a t o r> + < f a t o r v a r s= v0 v2 > + < v a r n a m e= v2 > + < f a t o r> + < v a r> + < t r e e> < t r e e> + < v a r n a m e= v1 > + < f a t o r v a r s= v0 v1 > + < v a r n a m e= v0 > + < f a t o r> + < f a t o r v a r s= v1 v2 > + < v a r n a m e= v2 > + < f a t o r> + < v a r> + < t r e e> < t r e e> + < v a r n a m e= v0 > + < f a t o r v a r s= v0 v1 > + < v a r n a m e= v1 > + < f a t o r v a r s= v1 v2 > + < v a r n a m e= v2 > + < f a t o r> + < v a r> + < f a t o r> + < v a r> + < t r e e> < t r e e> + < v a r n a m e= v2 > + < f a t o r v a r s= v2 v1 > + < v a r n a m e= v1 > + < f a t o r> + < f a t o r v a r s= v0 v2 > + < v a r n a m e= v0 > + < f a t o r> + < v a r> + < t r e e> test trp tree list factor graph model = create triangle model get variable 0 set label v0 model get variable 1 set label v1 model get variable 2 set label v2 list readers = list i = 0 i < tree strs length i++ readers add reader tree strs i t r p trp = t r p set terminator t r p convergence terminator set factory t r p tree list factory make from readers model readers trp compute marginals model inferencer jt = brute force inferencer jt compute marginals model compare marginals model trp jt verify that variable indices are consistent in undirectected models test undirected indices mdl idx = 0 mdl idx < models length mdl idx++ factor graph mdl = models mdl idx iterator it = mdl variables iterator it has next variable var1 = variable it next variable var2 = mdl get mdl get index var1 mismatch in variable index + var1 + vs + var2 + in model + mdl idx + + mdl var1 == var2 logger info test undirected indices passed tests that t r p and max product propagation same results when t r p runs exactly one iteration test trp viterbi equiv mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx tree b p maxprod = tree b p create max product t r p trp = t r p create max product set terminator t r p iteration terminator 1 maxprod compute marginals mdl trp compute marginals mdl t r p should same results viterbi iterator it = mdl variables iterator it has next variable var = variable it next factor max pot bp = maxprod lookup marginal var factor max pot trp = trp lookup marginal var max pot bp normalize max pot trp normalize t r p 1 iter maxprod propagation not same plain max prod! + trp + max pot trp dump to + plain maxprod + max pot bp dump to max pot bp almost equals max pot trp test trp on trees mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx inferencer bp = tree b p inferencer trp = t r p set terminator t r p iteration terminator 1 bp compute marginals mdl trp compute marginals mdl outcomes = mdl num variables assignment assn = assignment mdl outcomes equals bp lookup log joint assn trp lookup log joint assn 1e 5 arrays fill outcomes 1 assn = assignment mdl outcomes equals bp lookup log joint assn trp lookup log joint assn 1e 5 t r p should same results viterbi iterator it = mdl variables iterator it has next variable var = variable it next factor max pot bp = bp lookup marginal var factor max pot trp = trp lookup marginal var max pot bp normalize max pot trp normalize t r p 1 iter bp propagation not same plain max prod! + trp + max pot trp dump to + plain bp + max pot bp dump to max pot bp almost equals max pot trp tests that t r p and max product propagation same results when t r p allowed to run to convergence test trp viterbi equiv2 mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx inferencer maxprod = tree b p create max product t r p trp = t r p create max product maxprod compute marginals mdl trp compute marginals mdl t r p should same results viterbi iterator it = mdl variables iterator it has next variable var = variable it next factor max pot bp = maxprod lookup marginal var factor max pot trp = trp lookup marginal var t r p maxprod propagation not same plain max prod! + trp + max pot trp + plain maxprod + max pot bp max pot bp almost equals max pot trp test tree viterbi mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx brute force inferencer brute = brute force inferencer inferencer maxprod = tree b p create max product factor joint = brute joint mdl maxprod compute marginals mdl iterator it = mdl variables iterator it has next variable var = variable it next factor max pot = maxprod lookup marginal var factor max pot = joint extract max var max pot normalize max pot normalize maximization failed! normalized + max pot + + max pot max pot almost equals max pot logger info test tree viterbi passed + trees length + models test jt viterbi junction tree inferencer jti = junction tree inferencer mdl idx = 0 mdl idx < models length mdl idx++ undirected model mdl = models mdl idx brute force inferencer brute = brute force inferencer junction tree inferencer maxprod = junction tree inferencer create max product junction tree jt = maxprod build junction tree mdl factor joint = brute joint mdl maxprod compute marginals jt iterator it = mdl variables iterator it has next variable var = variable it next factor max pot raw = maxprod lookup marginal var factor max pot raw = joint extract max var factor max pot = max pot raw duplicate normalize factor max pot = max pot raw duplicate normalize maximization failed on model + mdl idx + ! normalized + max pot dump to + + max pot dump to max pot almost equals max pot 0 01 logger info test jt viterbi passed test m m test query test tree viterbi test trp viterbi equiv test trp viterbi equiv2 test max marginals xxx fails because t r p termination i e always succeeds termination iteration termination 10 but usually fails termination convergence terminator 1e 12 1000 something about selection random spanning trees??? test max marginals mdl idx = 0 mdl idx < models length mdl idx++ mdl idx = 4 factor graph mdl = models mdl idx mdl idx != 3 visualizer show model mdl mdl dump out e n d m d l +mdl idx+ brute force inferencer brute = brute force inferencer factor joint = brute joint mdl foo = current time millis out foo inferencer algs = construct max product inferencers inf idx = 0 inf idx < algs length inf idx++ inferencer inf = algs inf idx inf t r p t r p inf set random seed 42 inf compute marginals mdl iterator it = mdl variables iterator it has next variable var = variable it next factor max pot = inf lookup marginal var factor max pot = joint extract max var max pot argmax != max pot argmax logger warning argmax not equal on model + mdl idx + inferencer + inf + ! factors + max pot + + max pot err dump model + mdl idx + mdl dump max pot argmax == max pot argmax logger info test max marginals passed test belief propagation mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx inferencer prop = tree b p out mdl prop compute marginals mdl iterator it = mdl variables iterator it has next variable var = variable it next factor marg1 = tree margs mdl idx mdl get index var factor marg2 = prop lookup marginal var test failed on graph + mdl idx + vertex + var + + model + mdl + expected + marg1 dump to + actual + marg2 dump to marg1 almost equals marg2 0 011 assertion failed e out e get message out m o d e l mdl dump out m e s s a g e s belief propagation prop dump e logger info test belief propagation passed test bp joint mdl idx = 0 mdl idx < trees length mdl idx++ factor graph mdl = trees mdl idx inferencer bp = tree b p brute force inferencer brute = brute force inferencer brute compute marginals mdl bp compute marginals mdl assignment iterator it = mdl assignment iterator it has next assignment assn = assignment it next equals brute lookup joint assn bp lookup joint assn 1e 15 eventially should be folded into test marginals test joint etc test directed jt directed model bn = create directed model brute force inferencer brute = brute force inferencer brute compute marginals bn junction tree inferencer jt = junction tree inferencer jt compute marginals bn compare marginals comparing junction tree to brute on directed model! bn brute jt directed model create directed model n u m o u t o m e s = 2 randoms random = randoms 13413 dirichlet dirichlet = dirichlet n u m o u t o m e s 1 0 p a = dirichlet random vector random p b = dirichlet random vector random t list p = t list n u m o u t o m e s n u m o u t o m e s n u m o u t o m e s i = 0 i < n u m o u t o m e s n u m o u t o m e s i++ p add dirichlet random vector random variable vars = variable variable n u m o u t o m e s variable n u m o u t o m e s variable n u m o u t o m e s directed model mdl = directed model mdl add factor p t table factor vars 0 p a vars 0 mdl add factor p t table factor vars 1 p b vars 1 mdl add factor p t table factor vars p to vars 2 mdl compare marginals msg factor graph fg inferencer inf1 inferencer inf2 i = 0 i < fg num variables i++ variable var = fg get i factor ptl1 = inf1 lookup marginal var factor ptl2 = inf2 lookup marginal var msg + + ptl1 dump to + + ptl2 dump to ptl1 almost equals ptl2 1e 5 set up models list = create test models create test trees models = undirected model models list to undirected model compute test tree margs test multiply table factor p1 = table factor variable out p1 variable vars = variable variable 2 variable 2 probs = 1 3 5 6 table factor p2 = table factor vars probs factor p3 = p1 multiply p2 should be equal + p2 + + p3 p2 almost equals p3 t o d o not sure how to test anymore test multiplication potentials where variables are in a different order test multiplication2 variable vars = variable variable 2 variable 2 probs1 = 2 4 1 6 probs2a = 3 7 6 5 probs2b = 3 6 7 5 multinomial potential ptl1a = multinomial potential vars probs1 multinomial potential ptl1b = multinomial potential vars probs1 multinomial potential ptl2a = multinomial potential vars probs2a variable vars2 = variable vars 1 vars 0 multinomial potential ptl2b = multinomial potential vars2 probs2b ptl1a multiply ptl2a ptl1b multiply ptl2b ptl1a almost equals ptl1b test log marginalize factor graph mdl = models 0 iterator it = mdl variables iterator variable v1 = variable it next variable v2 = variable it next random rand = random 3214123 i = 0 i < 10 i++ factor ptl = random edge potential rand v1 v2 factor logmarg1 = log table factor table factor ptl marginalize v1 factor marglog1 = log table factor table factor ptl marginalize v1 log marg failed! correct +marglog1+ log marg +logmarg1 logmarg1 almost equals marglog1 factor logmarg2 = log table factor table factor ptl marginalize v2 factor marglog2 = log table factor table factor ptl marginalize v2 logmarg2 almost equals marglog2 test log normalize factor graph mdl = models 0 iterator it = mdl variables iterator variable v1 = variable it next variable v2 = variable it next random rand = random 3214123 i = 0 i < 10 i++ factor ptl = random edge potential rand v1 v2 factor norm1 = log table factor table factor ptl factor norm2 = ptl duplicate norm1 normalize norm2 normalize log normalize failed! correct +norm2+ log normed +norm1 norm1 almost equals norm2 test sum log prob random rand = random 3214123 i = 0 i < 10 i++ v1 = rand next v2 = rand next sum1 = math log v1 + v2 sum2 = maths sum log prob math log v1 math log v2 out summing +v1+ + +v2 equals sum1 sum2 0 00001 test infinite cost variable vars = variable 3 i = 0 i < vars length i++ vars i = variable 2 factor graph mdl = factor graph vars mdl add factor vars 0 vars 1 2 6 4 8 mdl add factor vars 1 vars 2 1 0 0 1 mdl dump inferencer bp = tree b p bp compute marginals mdl below should be except potentials have different ranges bp lookup marginal vars 1 almost equals bp lookup marginal vars 2 test jt caching clear all caches i = 0 i < models length i++ factor graph model = models i model set inference cache junction tree inferencer factor margs = factor models length stime1 = date get time i = 0 i < models length i++ factor graph model = models i junction tree inferencer inf = junction tree inferencer inf compute marginals model margs i = factor model num variables iterator it = model variables iterator j = 1 it has next variable var = variable it next j++ margs i j = inf lookup marginal var etime1 = date get time diff1 = etime1 stime1 logger info pre cache took +diff1+ ms stime2 = date get time i = 0 i < models length i++ factor graph model = models i junction tree inferencer inf = junction tree inferencer inf compute marginals model iterator it = model variables iterator j = 1 it has next variable var = variable it next j++ margs i j almost equals inf lookup marginal var etime2 = date get time diff2 = etime2 stime2 logger info post cache took +diff2+ ms diff2 < diff1 test find variable factor graph mdl = models 0 variable vars = variable mdl num variables iterator it = mdl variables iterator it has next variable var = variable it next name = var get label var == mdl find variable name mdl find variable xsdfasdf == test lookup marginal inferencer inf = tree b p factor graph mdl = trees j t h a i n t e s t t r e e variable var = mdl get 0 inf compute marginals mdl previously unsupported operation exptected to lookup marginal variable clique size 1 var set var set = hash var set variable var factor ptl1 = inf lookup marginal var set factor ptl2 = inf lookup marginal var ptl1 almost equals ptl2 variable var2 = mdl get 1 variable var3 = mdl get 2 var set c2 = hash var set variable var var2 var3 inf lookup marginal c2 fail expected an unsupported operation clique +c2 unsupported operation e eventually should be moved to models but t r p currently chokes on disconnected model test disconnected model variable vars = variable 4 i = 0 i < vars length i++ vars i = variable 2 factor graph mdl = undirected model vars random r = random 67 factor ptls = factor 4 factor normed = factor 4 i = 0 i < vars length i++ ptls i = random node potential r vars i normed i = ptls i duplicate normed i normalize mdl add factor ptls i mdl dump inferencer inf = loopy b p inf compute marginals mdl i = 0 i < vars length i++ factor marg = inf lookup marginal vars i marginals not equal! +normed i + +marg marg almost equals normed i assignment iterator it = mdl assignment iterator it has next assignment assn = assignment it next prob = 1 0 i = 0 i < vars length i++ prob = normed i value assn equals prob inf lookup joint assn 1e 5 time marginalization random r = random 7732847 variable vars = variable variable 2 variable 2 table factor ptl = random edge potential r vars 0 vars 1 stime = current time millis i = 0 i < 1000 i++ factor marg = ptl marginalize vars 0 factor marg2 = ptl marginalize vars 1 etime = current time millis logger info marginalization 2 outcome took + etime stime + ms variable vars45 = variable variable 45 variable 45 table factor ptl45 = random edge potential r vars45 0 vars45 1 stime = current time millis i = 0 i < 1000 i++ factor marg = ptl45 marginalize vars45 0 factor marg2 = ptl45 marginalize vars45 1 etime = current time millis logger info marginalization 45 outcome took + etime stime + ms using profiling run junction tree mdl idx = 0 mdl idx < models length mdl idx++ factor graph model = models mdl idx junction tree inferencer inf = junction tree inferencer inf compute marginals model iterator it = model variables iterator it has next variable var = variable it next inf lookup marginal var test destructive assignment variable vars = variable 2 variable 2 assignment assn = assignment vars 0 1 equals 0 assn get vars 0 equals 1 assn get vars 1 assn set value vars 0 1 equals 1 assn get vars 0 equals 1 assn get vars 1 test loopy convergence random r = random 67 factor graph mdl = create random grid 5 5 2 r loopy b p loopy = loopy b p loopy compute marginals mdl loopy iterations used > 8 test singleton graph variable v = variable 2 factor graph mdl = factor graph variable v mdl add factor table factor v 1 2 t r p trp = t r p trp compute marginals mdl factor ptl = trp lookup marginal v dbl = table factor ptl to value equals 2 dbl length equals 0 33333 dbl 0 1e 4 equals 0 66666 dbl 1 1e 4 test loopy caching factor graph mdl1 = models 4 factor graph mdl2 = models 5 variable var = mdl1 get 0 loopy b p inferencer = loopy b p inferencer set use caching inferencer compute marginals mdl1 factor orig ptl = inferencer lookup marginal var 2 < inferencer iterations used confuse inferencer inferencer compute marginals mdl2 make sure we have cached correct results inferencer compute marginals mdl1 factor snd ptl = inferencer lookup marginal var note that we can t use an epsilon here that s less than our convergence criteria huh? original potential +orig ptl+ after +snd ptl orig ptl almost equals snd ptl 1e 4 equals 1 inferencer iterations used test junction tree connected from root junction tree inferencer jti = junction tree inferencer jti compute marginals models 0 jti compute marginals models 1 junction tree jt = jti lookup junction tree list reached = list linked list queue = linked list queue add jt get root !queue empty var set current = var set queue remove first queue add all jt get children current reached add current equals jt cluster potentials size reached size test bp large models timing timing = timing undirected model mdl = random graphs create uniform chain 800 factor graph mdl = random graphs create uniform chain 8196 timing tick model creation belief propagation inf = loopy b p inf compute marginals mdl out memory e out o u t o f m e m o r y messages sent +inf get total messages sent e timing tick inference time random sched b p test trp large models timing timing = timing undirected model mdl = random graphs create uniform chain 800 factor graph mdl = random graphs create uniform chain 8192 timing tick model creation inferencer inf = t r p inf compute marginals mdl timing tick inference time t r p test bp dual edge factor variable vars = variable variable 2 variable 2 variable 2 variable 2 random r = random factor tbl1 = create edge ptl vars 0 vars 1 r factor tbl2a = create edge ptl vars 1 vars 2 r factor tbl2b = create edge ptl vars 1 vars 2 r factor tbl3 = create edge ptl vars 2 vars 3 r factor graph fg = factor graph vars fg add factor tbl1 fg add factor tbl2a fg add factor tbl2b fg add factor tbl3 inferencer inf = t r p inf compute marginals fg var set vs = tbl2a var set factor marg1 = inf lookup marginal vs factor prod = table factor multiply all fg factors factor marg2 = prod marginalize vs marg2 normalize factors not equal! b p +marg1 dump to + e x a t +marg2 dump to marg1 almost equals marg2 factor create edge ptl variable var1 variable var2 random r dbls = 4 i = 0 i < dbls length i++ dbls i = r next table factor variable var1 var2 dbls grid str = v a r alpha u o n t i n u o u s + alpha ~ uniform 1 0 1 0 + u ~ uniform 2 0 2 0 + x00 ~ unary u + x10 ~ unary u + x01 ~ unary u + x11 ~ unary u + x00 x01 ~ potts alpha + x00 x10 ~ potts alpha + x01 x11 ~ potts alpha + x10 x11 ~ potts alpha test jt constant i o factor graph master fg = model reader read model buffered reader reader grid str junction tree inferencer jt = junction tree inferencer assignment assn = master fg sample continuous vars randoms 3214 factor graph fg = factor graph master fg slice assn jt compute marginals fg test suite test suite test inference test suite suite length > 0 suite = test suite i = 0 i < length i++ suite add test test inference i suite = test suite suite junit textui test runner run suite 