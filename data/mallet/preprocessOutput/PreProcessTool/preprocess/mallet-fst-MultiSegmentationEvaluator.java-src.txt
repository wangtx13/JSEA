2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e evaluate segmentation f1 several different tags marked in o i b format example tags might be b p e r s o n i p e r s o n o b l o a t i o n i l o a t i o n o author andrew mc callum <a href= mailto >mccallum edu< a> io print stream list logging logger text decimal format types feature vector types instance types instance list types sequence types token sequence logger evaluates a transducer model computes precision recall and f1 scores considers segments that span across multiple tokens multi segmentation evaluator transducer evaluator logger logger = logger get logger segmentation evaluator get name equals called on these to determine token start or continuation a segment a tag not equal to any these an other not segment segment start tags segment tags segment start or tags multi segmentation evaluator instance list instance lists instance list descriptions segment start tags segment tags instance lists instance list descriptions segment start tags = segment start tags segment tags = segment tags segment start tags length == segment tags length multi segmentation evaluator instance list instance list1 description1 segment start tags segment tags instance list instance list1 description1 segment start tags segment tags multi segmentation evaluator instance list instance list1 description1 instance list instance list2 description2 segment start tags segment tags instance list instance list1 instance list2 description1 description2 segment start tags segment tags multi segmentation evaluator instance list instance list1 description1 instance list instance list2 description2 instance list instance list3 description3 segment start tags segment tags instance list instance list1 instance list2 instance list3 description1 description2 description3 segment start tags segment tags evaluate instance list transducer trainer tt instance list data description transducer model = tt get transducer num correct tokens total tokens num segments num predicted segments num correct segments all index = segment start tags length num segments = all index+1 num predicted segments = all index+1 num correct segments = all index+1 total tokens = num correct tokens = 0 n = 0 n < num segments length n++ num segments n = num predicted segments n = num correct segments n = 0 i = 0 i < data size i++ instance instance = data get i sequence input = sequence instance get data tokens = instance get source != tokens = instance get source to sequence output = sequence instance get target input size == output size sequence pred output = model transduce input pred output size == output size start pred start 1 non start otherwise index into segment start tag j = 0 j < output size j++ total tokens++ output get j equals pred output get j num correct tokens++ start = pred start = 1 count segment starts n = 0 n < segment start tags length n++ segment start tags n equals output get j num segments n ++ num segments all index ++ start = n count predicted segment starts n = 0 n < segment start tags length n++ segment start tags n equals pred output get j num predicted segments n ++ num predicted segments all index ++ pred start = n start != 1 start == pred start truth and prediction both agree that same segment tag type starting now m = pred = m = j+1 m < output size m++ = segment tags pred start equals output get m pred = segment tags pred start equals pred output get m !true || !pred == pred they agree about a segment ending somehow num correct segments pred start ++ num correct segments all index ++ end sequence m == output size == pred num correct segments pred start ++ num correct segments all index ++ decimal format f = decimal format 0 #### logger info description + tokenaccuracy= +f format num correct tokens total tokens n = 0 n < num correct segments length n++ logger info n < all index ? segment start tags n to o v e r a l l + precision = num predicted segments n == 0 ? 1 num correct segments n num predicted segments n recall = num segments n == 0 ? 1 num correct segments n num segments n f1 = recall+precision == 0 0 ? 0 0 2 0 recall precision recall + precision logger info +description+ segments true= +num segments n + pred= +num predicted segments n + correct= +num correct segments n + misses= + num segments n num correct segments n + alarms= + num predicted segments n num correct segments n logger info +description+ precision= +f format precision + recall= +f format recall + f1= +f format f1 number incorrect segments in <code>pred output< code> output truth pred output predicted number incorrect segments num incorrect segments sequence output sequence pred output num correct tokens total tokens num segments num predicted segments num correct segments all index = segment start tags length num segments = all index+1 num predicted segments = all index+1 num correct segments = all index+1 total tokens = num correct tokens = 0 n = 0 n < num segments length n++ num segments n = num predicted segments n = num correct segments n = 0 pred output size == output size 1 non start otherwise index into segment start tag start pred start j = 0 j < output size j++ total tokens++ output get j equals pred output get j num correct tokens++ start = pred start = 1 count segment starts n = 0 n < segment start tags length n++ segment start tags n equals output get j num segments n ++ num segments all index ++ start = n count predicted segment starts n = 0 n < segment start tags length n++ segment start tags n equals pred output get j num predicted segments n ++ num predicted segments all index ++ pred start = n start != 1 start == pred start truth and prediction both agree that same segment tag type starting now m = pred = m = j+1 m < output size m++ = segment tags pred start equals output get m pred = segment tags pred start equals pred output get m !true || !pred == pred they agree about a segment ending somehow num correct segments pred start ++ num correct segments all index ++ end sequence m == output size == pred num correct segments pred start ++ num correct segments all index ++ wrong = 0 n=0 n < num correct segments length n++ incorrect segment either pos or neg wrong += num segments n num correct segments n wrong tests segmentation using an list predicted sequences instead a link transducer predicted sequence t include in stats useful analysis data list instances to be segmented predicted sequences predictions description description trial viterbi output stream where to print viterbi paths batch test instance list data list< sequence> predicted sequences description print stream viterbi output stream num correct tokens total tokens num segments num predicted segments num correct segments all index = segment start tags length num segments = all index+1 num predicted segments = all index+1 num correct segments = all index+1 token sequence source token sequence = total tokens = num correct tokens = 0 n = 0 n < num segments length n++ num segments n = num predicted segments n = num correct segments n = 0 i = 0 i < data size i++ viterbi output stream != viterbi output stream viterbi path +description+ instance # +i instance instance = data get i sequence input = sequence instance get data tokens = instance get source != tokens = instance get source to sequence output = sequence instance get target input size == output size sequence pred output = sequence predicted sequences get i pred output == skip instance pred output size == output size start pred start 1 non start otherwise index into segment start tag j = 0 j < output size j++ total tokens++ output get j equals pred output get j num correct tokens++ start = pred start = 1 count segment starts n = 0 n < segment start tags length n++ segment start tags n equals output get j num segments n ++ num segments all index ++ start = n count predicted segment starts n = 0 n < segment start tags length n++ segment start tags n equals pred output get j num predicted segments n ++ num predicted segments all index ++ pred start = n start != 1 start == pred start truth and prediction both agree that same segment tag type starting now m = pred = m = j+1 m < output size m++ = segment tags pred start equals output get m pred = segment tags pred start equals pred output get m !true || !pred == pred they agree about a segment ending somehow num correct segments pred start ++ num correct segments all index ++ end sequence m == output size == pred num correct segments pred start ++ num correct segments all index ++ viterbi output stream != feature vector fv = feature vector input get j viterbi output stream tokens at j + +true output get j to + +pred output get j to + + fv to source token sequence != viterbi output stream print source token sequence get j get text + viterbi output stream output get j to + +pred output get j to + + fv to decimal format f = decimal format 0 #### logger info description + tokenaccuracy= +f format num correct tokens total tokens n = 0 n < num correct segments length n++ logger info n < all index ? segment start tags n to o v e r a l l + precision = num predicted segments n == 0 ? 1 num correct segments n num predicted segments n recall = num segments n == 0 ? 1 num correct segments n num segments n f1 = recall+precision == 0 0 ? 0 0 2 0 recall precision recall + precision logger info segments true= +num segments n + pred= +num predicted segments n + correct= +num correct segments n + misses= + num segments n num correct segments n + alarms= + num predicted segments n num correct segments n logger info precision= +f format precision + recall= +f format recall + f1= +f format f1 