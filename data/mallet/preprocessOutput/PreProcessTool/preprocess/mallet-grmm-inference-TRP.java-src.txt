2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e inference gnu trove t hash set gnu trove t hash map gnu trove t hash map logging logger logging level io 3pq jgrapht undirected graph 3pq jgrapht graph 3pq jgrapht edge 3pq jgrapht traverse breadth first iterator 3pq jgrapht graph simple graph jdom document jdom j dom jdom element jdom input s a x builder types logger wainwright s t r p schedule loopy b p in general graphical models author charles sutton $ t r p v 1 1 2007 10 22 21 37 49 exp $ t r p belief propagation logger logger = logger get logger t r p get name report spanning trees = tree factory factory termination condition terminator random random = random make sure that we ve all edges before we terminate t hash map factor touched has converged verbose output directory = t r p t r p tree factory f f t r p termination condition cond cond t r p tree factory f termination condition cond factory = f terminator = cond t r p create max product t r p trp = t r p trp set messager max product message strategy trp accessors t r p set terminator termination condition cond terminator = cond t r p set factory tree factory factory factory = factory xxx should be static? set random seed seed random = random seed set verbose output directory verbose output directory verbose output directory = verbose output directory converged has converged init graph factor graph m init graph m num nodes = m num variables factor touched = t hash map num nodes has converged = factory == factory = almost random tree factory terminator == terminator = convergence terminator terminator reset types tree graph to tree graph g perhaps handle gracefully?? cas g vertex set size <= 0 runtime empty graph tree tree = types tree root = g vertex set iterator next tree add root iterator it1 = breadth first iterator g root it1 has next v1 = it1 next iterator it2 = g edges v1 iterator it2 has next edge edge = edge it2 next v2 = edge opposite vertex v1 tree get parent v1 != v2 tree add node v1 v2 tree get parent v2 == v1 tree tree generation strategies t r p <p > t r p works repeatedly doing exact inference over spanning tree original graph but trees can be chosen arbitrarily in fact they t need to be spanning trees any acyclic substructure will users t r p can tell it which strategy to use passing in an tree factory tree factory serializable types tree next tree factor graph mdl works around what appears to be a bug in open j graph connected sets simple union find map obj2set = t hash map set find set obj set container = set obj2set get obj container != container set set = t hash set set add obj obj2set put obj set set union obj1 obj2 set set1 = find set obj1 set set2 = find set obj2 set1 add all set2 iterator it = set2 iterator it has next obj = it next obj2set put obj set1 no pair connected var set var set i = 0 i < var set size i++ j = i + 1 j < var set size j++ variable v1 = var set get i variable v2 = var set get j find set v1 == find set v2 union all factor factor var set var set = factor var set i = 0 i < var set size i++ variable var = var set get i union var factor always adds edges that have not been touched after that adds random edges almost random tree factory tree factory tree next tree factor graph full graph simple union find union find = simple union find list edges = list full graph factors list good edges = list full graph num variables collections shuffle edges random first add all edges that haven t been used so far iterator it = edges iterator it has next factor factor = factor it next var set var set = factor var set !is factor touched factor union find no pair connected var set good edges add factor union find union all factor it remove now add many other edges possible iterator it = edges iterator it has next factor factor = factor it next var set var set = factor var set union find no pair connected var set good edges add factor union find union all factor iterator it = good edges iterator it has next factor factor = factor it next touch factor factor undirected graph g = simple graph iterator it = full graph variables iterator it has next variable var = variable it next g add vertex var iterator it = good edges iterator it has next factor factor = factor it next g add vertex factor iterator vit = factor var set iterator vit has next variable var = variable vit next g add edge factor var tree tree = graph to tree g report spanning trees out s p a n n i n g t r e e out tree dump to out e n d t r e e tree e e print stack trace runtime e serial u = 7461763414516915264 l generates spanning trees cyclically from a predefined collection tree list factory tree factory list lst iterator it tree list factory list l lst = l it = lst iterator tree list factory types tree arr lst = list arrays list arr it = lst iterator tree list factory make from readers factor graph fg list reader list list tree list = list iterator it = reader list iterator it has next reader reader = reader it next document doc = s a x builder build reader element tree elt = doc get root element element root elt = element tree elt get children get 0 tree tree = read tree rec fg root elt out tree dump to tree list add tree j dom e runtime e i o e runtime e tree list factory tree list list list each should be an xml document describing a tree tree list factory read from files factor graph fg list list list tree list = list iterator it = list iterator it has next tree = it next document doc = s a x builder build tree element tree elt = doc get root element element root elt = element tree elt get children get 0 tree list add read tree rec fg root elt j dom e runtime e i o e runtime e tree list factory tree list tree read tree rec factor graph fg element elt list subtrees = list iterator it = elt get children iterator it has next element child = element it next tree subtree = read tree rec fg child subtrees add subtree parent = obj from elt fg elt tree make from subtree parent subtrees obj from elt factor graph fg element elt type = elt get name type equals v a r vname = elt get attribute value n a m e fg find variable vname type equals f a t o r var set str = elt get attribute value v a r s vnames = var set str split \\s+ variable vars = variable vnames length i = 0 i < vnames length i++ vars i = fg find variable vnames i fg factor hash var set vars runtime can t figure out element +elt types tree next tree factor graph mdl no more trees rewind !it has next it = lst iterator types tree it next termination conditions will need to be subclassed from outside? will such subclasses need access to state t r p? termination condition cloneable serializable takes instances trp a parameter so that a t r p instance cloned and terminator copied over it will still work should t r p trp reset boy i hate cloning clone clone not supported iteration terminator termination condition current max reset current = 0 iteration terminator m max = m reset should t r p trp current++ current >= max logger finest t r p quitting iteration + current + >= + max current <= max clone clone not supported clone xxx delta currently ignored convergence terminator termination condition delta = 0 01 convergence terminator convergence terminator delta delta = delta reset should t r p trp old messages != retval = !check convergence trp copy messages trp retval retval = !trp has converged delta trp copy old messages retval clone clone not supported clone runs until convergence but doesn t stop until all edges have been used at least once and always stops after 1000 iterations convergence terminator termination condition convergence terminator cterminator iteration terminator iterminator msg convergence terminator 0 001 1000 convergence terminator delta max iter cterminator = convergence terminator delta iterminator = iteration terminator max iter msg = t r p quitting over + max iter + iterations reset iterminator reset cterminator reset terminate converged or at insanely high # iterations should t r p trp not all touched = !trp all edges touched !iterminator should trp logger warning msg not all touched logger warning t r p warning not all edges used! not all touched cterminator should trp clone clone not supported convergence terminator dup = convergence terminator clone dup iterminator = iteration terminator iterminator clone dup cterminator = convergence terminator cterminator clone dup and now heart t r p compute marginals factor graph m reset messages sent at start init graph m iter = 0 terminator should logger finer t r p iteration + iter++ types tree tree = factory next tree m propagate tree dump iter iter tree iter used = iter logger info t r p used + iter + iterations done graph m dump iter iter tree tree verbose output directory != output messages writer writer = writer verbose output directory iter + iter + txt dump print writer writer writer close writer bf writer = writer verbose output directory beliefs + iter + txt dump beliefs print writer bf writer bf writer close output spanning tree writer tree writer = writer verbose output directory tree + iter + txt tree writer write tree to tree writer write tree writer close i o e e print stack trace dump beliefs print writer writer vi = 0 vi < mdl current num variables vi++ variable var = mdl current get vi factor mrg = lookup marginal var writer mrg dump to writer propagate types tree tree root = tree get root lambda propagation tree root pi propagation tree root sends b p messages starting from children to parents uses constant stack space lambda propagation types tree tree root linked list open list = linked list linked list closed list = linked list open list add all tree get children root !open list empty var = open list remove first open list add all tree get children var closed list add first var now open list contains all nodes except root in reverse topological order send messages iterator it = closed list iterator it has next child = it next parent = tree get parent child send message mdl current child parent sends b p messages starting from parents to children uses constant stack space pi propagation types tree tree root linked list open list = linked list open list add root !open list empty current = open list remove first list children = tree get children current iterator it = children iterator it has next child = it next send message mdl current current child open list add child send message factor graph fg parent child logger loggable level f i n e r logger finer sending message +parent+ > +child parent factor send message fg factor parent variable child parent variable send message fg variable parent factor child all edges touched iterator it = mdl current factors iterator it has next factor factor = factor it next idx = mdl current get index factor num touches = get num touches idx num touches == 0 logger finest t r p continuing factor + idx + not touched touch factor factor factor idx = mdl current get index factor increment touches idx factor touched factor factor idx1 = mdl current get index factor get num touches idx1 > 0 get num touches idx1 = factor touched get idx1 == ? 0 value increment touches idx1 nt = get num touches idx1 factor touched put idx1 nt + 1 factor query directed model m variable var unsupported operation g r m m doesn t yet directed models xxx could get moved up to inferencer mdl current did assignment best assignment outcomes = mdl current num variables i = 0 i < outcomes length i++ variable var = mdl current get i table factor ptl = table factor lookup marginal var outcomes i = ptl argmax assignment mdl current outcomes deep copy termination condition clone t r p dup = t r p clone terminator != dup terminator = termination condition terminator clone dup clone not supported e should never happen runtime e serialization serial u = 1 seralization incompatible changes are made to these classes then smarts can be added to these backward compatibility write output stream out i o out write read input stream in i o not found in read 