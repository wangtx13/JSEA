2010 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised constraints gnu trove t list gnu trove t hash map list bit set hash map sum lattice semi supervised state label map types feature vector types feature vector sequence types instance types instance list a set constraints on individual input feature label pairs to be used g e and penalizes l 2^2 difference between model and target distributions multiple constraints are grouped together here to make things more efficient author gregory druck one label l2 range g e constraints g e constraint maps between input feature indices and constraints t hash map< one label l2 ind g e constraint> constraints state label map map cache set constrained features that fire at last feature vector in preprocess call t list cache one label l2 range g e constraints constraints = t hash map< one label l2 ind g e constraint> cache = t list one label l2 range g e constraints t hash map< one label l2 ind g e constraint> constraints state label map map constraints = constraints map = map cache = t list add constraint fi lower upper weight !constraints contains key fi constraints put fi one label l2 ind g e constraint constraints get fi add lower upper weight one state constraint set state label map state label map map map = map pre process feature vector fv cache reset quick fi cache constrained input features loc = 0 loc < fv num locations loc++ fi = fv index at location loc constraints contains key fi cache add fi constraints contains key fv get alphabet size cache add fv get alphabet size find examples that contain constrained input features bit set pre process instance list data count ii = 0 fi feature vector fv bit set bit set = bit set data size instance instance data feature vector sequence fvs = feature vector sequence instance get data ip = 0 ip < fvs size ip++ fv = fvs get ip loc = 0 loc < fv num locations loc++ fi = fv index at location loc constraints contains key fi constraints get fi count += 1 bit set set ii constraints contains key fv get alphabet size bit set set ii constraints get fv get alphabet size count += 1 ii++ bit set get composite constraint feature value feature vector fv ip si1 si2 value = 0 li2 = map get label index si2 i = 0 i < cache size i++ value += constraints get cache get quick i get gradient contribution li2 value get value value = 0 0 fi constraints keys one label l2 ind g e constraint constraint = constraints get fi constraint count > 0 0 value due to current constraint label index = 0 label index < map get num labels ++label index value = constraint get value contribution label index ! na n value ! infinite value value zero expectations fi constraints keys constraints get fi expectation = constraints get fi get num constrained labels compute expectations list< sum lattice> lattices gammas t list cache = t list i = 0 i < lattices size i++ lattices get i == sum lattice lattice = lattices get i feature vector sequence fvs = feature vector sequence lattice get input gammas = lattice get gammas ip = 0 ip < fvs size ++ip cache reset quick feature vector fv = fvs get feature vector ip fi loc = 0 loc < fv num locations loc++ fi = fv index at location loc binary constraint features constraints contains key fi cache add fi constraints contains key fv get alphabet size cache add fv get alphabet size s = 0 s < map get num states ++s = map get label index s != state label map s t a r t l a b e l gamma prob = math exp gammas ip+1 s j = 0 j < cache size j++ constraints get cache get quick j increment expectation gamma prob g e constraint copy one label l2 range g e constraints constraints map one label l2 ind g e constraint index count list< double> lower list< double> upper list< double> weights hash map< integer> label map expectation one label l2 ind g e constraint lower = list< double> upper = list< double> weights = list< double> label map = hash map< integer> index = 0 count = 0 add label lower upper weight lower add lower upper add upper weights add weight label map put label index index++ increment expectation value label map contains key i = label map get expectation i += value get value contribution label map contains key i = label map get count != 0 ex = expectation i count ex < lower get i weights get i math pow lower get i ex 2 ex > upper get i weights get i math pow upper get i ex 2 0 get num constrained labels index get gradient contribution label map contains key i = label map get count != 0 ex = expectation i count ex < lower get i 2 weights get i lower get i count expectation i count count ex > upper get i 2 weights get i upper get i count expectation i count count 0 