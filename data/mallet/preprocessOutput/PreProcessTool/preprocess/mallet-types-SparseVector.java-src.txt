2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types arrays io reflect reflect invocation target property list a vector that allocates memory only non zero values when you create a sparse vector you pass in a list indices these are only elements vector you will be allowed to change rest are fixed at 0 to sparse vector uses concept a location which an in range 0 num locations which can be mapped to index and value a non zero element vector a sparse vector can be sparse or dense depending on whether or not an indices specified at construction time sparse vector dense mapping from location to index identity mapping type value an element in a sparse vector or feature vector can be or binary 0 0 or 1 0 depending on whether an doubles specified at contruction time author andrew mc callum <a href= mailto >mccallum edu< a> sparse vector constant matrix vector serializable vector sparse then both indices and values are sparse indices into these arrays are called ``locations in below indices maps locations to indices virtual dense that s being represented value maps locations to values indices then vector dense values then vector binary has infinite at least one value = inf or + inf indices vector will be dense values vector will be binary capacity and size arguments are used augmentable feature vector sparse vector indices values capacity size copy check indices sorted remove duplicates size was pretty much ignored??? why? length length = size capacity < length capacity = length size <= length ! values == || indices == || indices length == values length illegal argument attempt to create sparse non binary sparse vector mismatching values indices + indices length = +indices length+ values length = +values length copy || capacity > length indices == indices = indices = capacity arraycopy indices 0 indices 0 length values == values = values = capacity arraycopy values 0 values 0 length indices = indices values = values check indices sorted sort indices also removes duplicates remove duplicates remove duplicates 0 create a dense vector sparse vector values copy values values length values length copy sparse vector values values sparse vector size fill value value size fill value sparse vector indices values copy check indices sorted remove duplicates indices values indices != ? indices length values length indices != ? indices length values length copy check indices sorted remove duplicates sparse vector indices values indices values sparse vector indices values copy indices values copy sparse vector indices values copy check indices sorted indices values copy check indices sorted create a vector that possibly binary or non binary sparse vector indices copy check indices sorted remove duplicates binary indices binary ? value indices length 1 0 indices length indices length copy check indices sorted remove duplicates create a binary vector sparse vector indices capacity size copy check indices sorted remove duplicates indices capacity size copy check indices sorted remove duplicates sparse vector indices copy check indices sorted indices copy check indices sorted sparse vector indices copy indices copy sparse vector indices indices an empty vector all zero values sparse vector 0 0 sparse vector alphabet dict property list pl binary grow alphabet pl == xxx fix sparse vector so that it can properly represent a vector that has all zeros does work? indices = 0 values = property list iterator iter binary == binary = all property list features are binary make a binary sparse vector even constructor argument binary will significantly save space well multiplication time later! akm 12 2007 iter = pl numeric iterator iter has next iter next property iter get numeric value != 1 0 binary = augmentable feature vector afv = augmentable feature vector dict binary afv print out sparse vector binary= +binary pl print iter = pl numeric iterator iter has next iter next property out sparse vector adding +iter get key + +iter get numeric value index = dict lookup index iter get key grow alphabet index >=0 afv add index iter get numeric value out sparse vector afv adding +iter get key + afv num locations= +afv num locations afv print xxx not so efficient? sparse vector sv = afv to sparse vector out sparse vector sv num locations= +sv num locations indices = sv indices values = sv values sparse vector alphabet dict property list pl binary dict pl binary value length value ret = length arrays fill ret value ret binary values == make binary unsupported operation not yet make non binary unsupported operation not yet a e s s o r s get num dimensions 1 xxx what we length? it could be higher than index get dimensions sizes indices == sizes 0 = values length xxx pretty unsatisfactory since there may be zero values above location sizes 0 = indices indices length 1 1 necessary s v m implementation! dmetzler but be careful allowed to be null! cas get indices indices necessary s v m implementation! dmetzler but be careful allowed to be null! cas get values values xxx just number non zero entries different behavior than matrix2!! num locations values == ? indices == ? 0 indices length values length location index indices == index arrays binary search indices index value at location location values == ? 1 0 values location index at location location indices == ? location indices location value indices indices length == 1 indices == values indices 0 values location indices 0 value index indices == values index index out bounds e 0 0 loc = location index loc < 0 0 0 values == 1 0 values loc add to accumulator scale indices == i = 0 i < values length i++ accumulator i += values i scale values == i = 0 i < indices length i++ accumulator indices i += scale i = 0 i < indices length i++ accumulator indices i += values i scale add to accumulator add to accumulator 1 0 single index indices indices length == 1 indices 0 single to indices i indices indices 0 = i single value i value i single size indices == values length indices length == 0 0 just highest index that will have non zero value full size dimension unknown indices indices length 1 to to to on one line buffer sb = buffer i = 0 i < values length i++ sb append indices == ? i indices i sb append = sb append values i !on one line sb append sb append sb to l o n i n g constant matrix clone matrix indices == sparse vector values sparse vector indices values constant matrix clone matrix zeroed indices == sparse vector values length indices = indices length arraycopy indices 0 indices 0 indices length sparse vector indices values length m u t a t o r s each index i that present in vector set i += v i v has indices that are not present in these are just ignored plus equals sparse sparse vector v plus equals sparse v 1 0 each index i that present in vector set i += factor v i v has indices that are not present in these are just ignored plus equals sparse sparse vector v factor special dense sparse vector indices == dense plus equals sparse v factor loc1 = 0 loc2 = 0 num locations1 = num locations num locations2 = v num locations loc1 < num locations1 loc2 < num locations2 idx1 = index at location loc1 idx2 = v index at location loc2 idx1 == idx2 values loc1 += v value at location loc2 factor ++loc1 ++loc2 idx1 < idx2 ++loc1 idx2 not present in ignore ++loc2 each index i that present in vector set i = v i v has indices that are not present in these are just ignored times equals sparse sparse vector v times equals sparse v 1 0 each index i that present in vector set i = factor v i v has indices that are not present in these are just ignored times equals sparse sparse vector v factor special dense sparse vector indices == dense times equals sparse v factor loc1 = 0 loc2 = 0 loc1 < num locations loc2 < v num locations idx1 = index at location loc1 idx2 = v index at location loc2 idx1 == idx2 values loc1 = v value at location loc2 factor ++loc1 ++loc2 idx1 < idx2 ++loc1 idx2 not present in ignore ++loc2 each index i that present in vector set i = factor v i v has indices that are not present in these are set to zero times equals sparse zero sparse vector v factor special dense sparse vector indices == dense times equals sparse v factor loc1 = 0 loc2 = 0 loc1 < num locations loc2 < v num locations idx1 = index at location loc1 idx2 = v index at location loc2 idx1 == idx2 values loc1 = v value at location loc2 factor ++loc1 ++loc2 idx1 < idx2 idx1 not present in v zero values loc1 = 0 ++loc1 idx2 not present in ignore ++loc2 scale all elements same factor times equals factor i = 0 i < values length i++ values i = factor dense plus equals sparse sparse vector v factor maxloc = v num locations loc = 0 loc < maxloc loc++ idx = v index at location loc idx >= values length values idx += v value at location loc factor dense times equals sparse sparse vector v factor maxloc = v num locations loc = 0 loc < maxloc loc++ idx = v index at location loc idx >= values length values idx = v value at location loc factor increments index value illegal argument index not present increment value index value illegal argument loc = location index loc >= 0 values loc += value illegal argument trying to set value that isn t present in sparse vector sets every present index in vector to v set all v i = 0 i < values length i++ values i = v sets value at given index illegal argument index not present set value index value illegal argument indices == values index = value loc = location index loc < 0 illegal argument can t insert values into a sparse vector values loc = value sets value at given location set value at location location value values location = value copy values from an into vector should have same size vector yanked from dense vector copy from a copy from a 0 copy values from an starting at a particular location into vector must have at least many values beyond starting location there are in vector next uncopied location in copy from a starting location arraycopy a starting location values 0 values length starting location + values length applies argument to each value in a non binary vector should both accept a an argument and a illegal argument argument has an inappropriate signature unsupported operation vector binary illegal access inaccessible throwable an it relayed map f illegal access throwable values == unsupported operation binary values may not be altered via map f get parameter types length!=1 || f get parameter types 0 != || f get type != illegal argument signature must be \ f x \ i=0 i<values length i++ values i = f values i value invocation target e e get target copy contents vector into an starting at a particular location next available location in copy into starting location arraycopy values 0 starting location values length starting location + values length v e t o r o p e r a t i o n s dot product v ret = 0 values == i = 0 i < indices length i++ ret += v indices i i = 0 i < indices length i++ ret += values i v indices i ret dot product constant matrix m m sparse vector dot product sparse vector m m dense vector dot product dense vector m illegal argument unrecognized matrix type +m get dot product dense vector v v has infinite || has infinite extended dot product v ret = 0 values == i = 0 i < indices length i++ ret += v value indices i i = 0 i < indices length i++ ret += values i v value indices i na n ret extended dot product v ret sets inf 0 = 0 inf 0 = 0 extended dot product dense vector v ret = 0 values == i = 0 i < indices length i++ ret += v value indices i i = 0 i < indices length i++ infinite values i v value indices i ==0 0 has infinite = infinite v value indices i values i ==0 0 v has infinite = ret += values i v value indices i ret dot product sparse vector v v has infinite || has infinite extended dot product v ret decide in which direction to dot product a heuristic choice based on efficiency and it could certainly be more complicated v indexed sparse vector ret = v dot product num locations > v num locations ret = dot product internal v ret = dot product internal v na n ret extended dot product v ret dot product internal sparse vector v sparse vector v ret = 0 num locs = v num locations v binary i = 0 i < num locs i++ ret += v value v index at location i i = 0 i < num locs i++ v1 = v value at location i v2 = v value v index at location i ret += v1 v2 ret sets inf 0 = 0 inf 0 = 0 extended dot product sparse vector v ret = 0 0 sparse vector v = sparse vector v = ensures minimal computational effort num locations > v num locations v = v v = v = v = v i = 0 i < v num locations i++ v1 = v value at location i v2 = v value v index at location i infinite v1 v2==0 0 v has infinite = infinite v2 v1==0 0 v has infinite = ret += v1 v2 ret sparse vector vector add sparse vector v scale indices != sparse sparse vector ind = v get indices val = v get values indices = ind length+indices length vals = ind length+indices length i = 0 i < indices length i++ indices i = indices i vals i = values i i = 0 i < ind length i++ indices i+indices length = ind i vals i+indices length = scale val i sparse vector indices vals indices = values length vals = values length dense sparse vector cur pos = 0 i = 0 i < values length i++ val = values i +scale v value i val != 0 0 indices cur pos = i vals cur pos++ = val sparse vector indices vals one norm ret = 0 values == indices length i = 0 i < values length i++ ret += values i ret abs norm ret = 0 values == indices length i = 0 i < values length i++ ret += math abs values i ret two norm ret = 0 values == math sqrt indices length i = 0 i < values length i++ ret += values i values i math sqrt ret infinity norm values == 1 0 max = n e g a t i v e i n f i n i t y i = 0 i < values length i++ math abs values i > max max = math abs values i max print values == binary sparsevector i = 0 i < indices length i++ out sparse vector +indices i + = 1 0 i = 0 i < values length i++ idx = indices == ? i indices i out sparse vector +idx+ = +values i na n values == matrix ops na n values i = 0 i < values length i++ na n values i gsc similar to na n but checks infinite values infinite values == matrix ops infinite values gsc any value either na n or infinite na n or infinite values == matrix ops na n or infinite values sort indices sort indices modified limin yao indices == it s dense and thus definition sorted values == arrays sort indices just bubble sort efficient when already mostly sorted note that we bubble sort from end forward most efficient when we have added a few additional items to end a previously sorted list we could be much smarter we remembered highest index that was already sorted i = indices length 1 i >= 0 i swapped = j = 0 j < i j++ indices j > indices j+1 swap both indices and values f f = indices j indices j = indices j+1 indices j+1 = f values != v v = values j values j = values j+1 values j+1 = v swapped = !swapped values == num duplicates = 0 i = 1 i < indices length i++ indices i 1 == indices i num duplicates++ num duplicates > 0 remove duplicates num duplicates argument zero special value meaning that function should count them remove duplicates num duplicates num duplicates == 0 i = 1 i < indices length i++ indices i 1 == indices i num duplicates++ num duplicates == 0 indices = indices length num duplicates values = values == ? indices length num duplicates indices 0 = indices 0 values != values 0 = values 0 i = 1 j = 1 i < indices length i++ indices i == indices i 1 values != values j 1 += values i indices j = indices i values != values j = values i j++ indices = indices values = values serialization serial u = 2 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o augmentable feature vector be sure to sort compress our data before we write it augmentable feature vector sort indices out write u r r e n t s e r i a l v e r s i o n out write indices == ? 1 indices length out write values == ? 1 values length indices != i = 0 i < indices length i++ out write indices i values != i = 0 i < values length i++ out write values i read input stream in i o not found = in read indices size = in read values size = in read has infinite = indices size >= 0 indices = indices size i = 0 i < indices size i++ indices i = in read values size >= 0 values = values size i = 0 i < values size i++ values i = in read infinite values i has infinite = 