2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> types io i o io input stream io output stream io serializable property list augmentable feature vector feature vector serializable size max index valid indices or values value max sorted index indices != top values and indices may be unsorted indices xxx also make constructors dense vectors and add appropriate functionality in below to make a binary vector pass values augmentable feature vector alphabet dict indices values capacity size copy check indices sorted remove duplicates dict indices values capacity size copy check indices sorted remove duplicates set size and max sorted index not already set via sort indices and remove duplicates ! check indices sorted ! remove duplicates size = size max sorted index = size 1 augmentable feature vector alphabet dict indices values capacity copy check indices sorted dict indices values capacity indices length copy check indices sorted augmentable feature vector alphabet dict indices values capacity copy dict indices values capacity indices length copy augmentable feature vector alphabet dict indices values capacity dict indices values capacity indices length augmentable feature vector alphabet dict values capacity dict values capacity values length augmentable feature vector alphabet dict values dict values values length values length augmentable feature vector alphabet dict capacity binary yyy dict capacity binary ? capacity capacity 0 augmentable feature vector alphabet dict binary dict 4 binary augmentable feature vector alphabet dict dict augmentable feature vector feature vector fv alphabet fv dictionary fv indices fv values fv indices == ? fv values length fv indices length fv indices == ? fv values length fv indices length augmentable feature vector feature sequence fs binary fs get alphabet binary i = fs size 1 i >= 0 i add fs get index at position i 1 0 augmentable feature vector alphabet dict property list pl binary grow alphabet dict binary pl == property list iterator iter = pl numeric iterator iter has next iter next property out augmentable vector +dict size + adding +iter get key + +iter get numeric value index = dict lookup index iter get key grow alphabet index >= 0 add index iter get numeric value augmentable feature vector alphabet dict property list pl binary dict pl binary adds all indices that are present in some other feature vector value 1 0 beware that may have unintended effects <tt>fv dictionary != dictionary< tt> add feature vector fv loc = 0 loc < fv num locations loc++ index = fv index at location loc mdredze jhu 3 5 10 use values instead assuming fv binary value = fv value at location loc location index == 1 add index 1 0 add index value adds all features from some other feature vector weight 1 0 names added features are generated adding a prefix to their names in original feature vector does not require that <tt>fv dictionary< tt> equal <tt>this dictionary< tt> fv a feature vector to add from its feature names must be strings prefix to add when generating feature names add feature vector fv prefix alphabet other dict = fv get alphabet loc = 0 loc < fv num locations loc++ idx = fv index at location loc other name = other dict lookup idx add prefix+other name 1 0 adds all features from some other feature vector weight 1 0 names added features are generated adding a prefix to their names in original feature vector does not require that <tt>fv dictionary< tt> equal <tt>this dictionary< tt> fv a feature vector to add from its feature names must be strings prefix to add when generating feature names binary <tt>fv< tt> binary add feature vector fv prefix binary binary add fv prefix alphabet other dict = fv get alphabet loc = 0 loc < fv num locations loc++ idx = fv index at location loc val = fv value at location loc other name = other dict lookup idx add prefix+other name val aims to be cheap constant time when indices != add index value values == value != 1 0 illegal argument trying to add non 1 0 value + dictionary lookup index + = +value+ to binary vector index >= 0 indices == index >= values length length = index + 10 ??? values = length ??? arraycopy values 0 values 0 values length values = values values index = value size <= index values index += value size <= index size = index+1 size == indices length length indices length == 0 length = 4 indices length < 4 length = indices length 2 indices length < 100 length = indices length 3 2 length = indices length + 150 values != values = length arraycopy values 0 values 0 values length values = values indices = length arraycopy indices 0 indices 0 indices length indices = indices out indices length= +indices length+ size= +size indices size = index values != values size = value size++ add key value out augmentable feature vector dictionary = +dictionary+ size = +dictionary size index = dictionary lookup index key out augmentable feature vector index +key+ = +index index != 1 add index value add index values != illegal argument trying to add binary feature to real valued vector index >= 0 add index 1 0 num locations indices == values length size size 1 != max sorted index sort indices size location index indices == index size 1 != max sorted index sort indices arrays binary search indices index doesn t work because unused portion at end i = 0 i < size i++ indices i == index i indices i > index 1 1 value at location location indices == values location size 1 != max sorted index sort indices value at location location index at location location indices == location size 1 != max sorted index sort indices location < size index at location location value index indices == values index size 1 != max sorted index sort indices loc = location index loc >= 0 values == 1 0 values loc 0 add to accumulator scale indices != size 1 != max sorted index sort indices indices == i = 0 i < size i++ accumulator i += values i scale values == i = 0 i < size i++ accumulator indices i += scale i = 0 i < size i++ accumulator indices i += values i scale add to accumulator add to accumulator 1 0 set value index value indices != size 1 != max sorted index sort indices values != indices == index < size values index = value values location index = value set value at location location value location < size values location = value constant matrix clone matrix augmentable feature vector alphabet dictionary indices values indices length size constant matrix clone matrix zeroed indices == augmentable feature vector dictionary values length indices = indices length arraycopy indices 0 indices 0 indices length augmentable feature vector dictionary indices values length values length values length single size indices == ? values length size == 0 ? 0 indices size 1 sparse vector to sparse vector size 1 != max sorted index sort indices out augmentable feature vector to sparse vector size= +size sparse vector indices values size size feature vector to feature vector indices != size 1 != max sorted index sort indices feature vector alphabet dictionary indices values size size dot product dense vector v indices != size 1 != max sorted index sort indices ret = 0 values == i = 0 i < size i++ ret += v value indices i indices == i = 0 i < size i++ ret += values i v value i i = 0 i < size i++ ret += values i v value indices i ret dot product sparse vector v v augmentable feature vector dot product augmentable feature vector v indices != size 1 != max sorted index sort indices ret = 0 vl = 0 vnl = v num locations values == i = 0 i < size i++ vl < vnl v index at location vl < indices i vl++ vl < vnl v index at location vl == indices i ret += v value at location vl indices == i = 0 i < vnl i++ index = v index at location i index < size ret += v value at location i values index loc = 0 loc < size loc++ vl < vnl v index at location vl < indices loc vl++ vl < vnl v index at location vl == indices loc ret += values loc v value indices loc ret dot product augmentable feature vector v indices != size 1 != max sorted index sort indices v indices != v size 1 != v max sorted index v sort indices ret = 0 vl = 0 vnl = v size values == v values == i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i ret += 1 0 i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i ret += v values vl indices == i = 0 i < vnl i++ index = v index at location i index < size ret += v value at location i values index v values == i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i ret += values i i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i ret += values i v values vl ret plus equals augmentable feature vector v factor indices != size 1 != max sorted index sort indices v indices != v size 1 != v max sorted index v sort indices vl = 0 vnl = v size values != indices == v indices == vnl = math min vnl size i = 0 i < vnl i++ values i += v values i v indices != i = 0 i < vnl i++ index = v indices i index < values length values index += v values i factor index >= size size = index+1 indices != v indices == i = 0 i < size i++ indices i < vnl values i += v values indices i xxx we should check to there were more higher indices in v that didn t get added! v indices != v values == v indices != v values == i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i values i += factor xxx we should check to there were more higher indices in v that didn t get added! v indices != v values != i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i values i += v values vl factor xxx we should check to there were more higher indices in v that didn t get added! but only adds to those entries that have locations i e are already non zero plus equals sparse vector v factor v augmentable feature vector plus equals augmentable feature vector v factor v get get name needs to be checked! indices != size 1 != max sorted index sort indices vl = 0 values != indices == v indices == indices == v indices == v values != s = math min size v values length i = 0 i < s i++ values i += v values i factor xxx we aren t adding in values indices higher than size ! indices == v indices != v values == indices == v indices != v values == i = 0 i < v indices length i++ index = v indices i index < size values index += factor xxx we aren t adding in values indices higher than size ! indices == v indices != v values != i = 0 i < v indices length i++ index = v indices i index < size values index += v values i factor xxx we aren t adding in values indices higher than size ! indices != v indices == indices != v indices == v values != i = 0 i < size i++ indices i < v values length values i += v values indices i factor xxx we aren t adding in values indices higher than size ! indices != v indices != vnl = v indices length v values == indices != v indices != v values == i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i values i += v values vl factor xxx we should check to there were more higher indices in v that didn t get added! indices != v indices != v values != i = 0 i < size i++ vl < vnl v indices vl < indices i vl++ vl < vnl v indices vl == indices i values i += v values vl factor xxx we should check to there were more higher indices in v that didn t get added! plus equals sparse vector v plus equals v 1 0 set all v values != i = 0 i < values length i++ values i = v one norm size 1 != max sorted index sort indices ret = 0 values == size i = 0 i < size i++ ret += values i ret two norm size 1 != max sorted index sort indices ret = 0 values == math sqrt size i = 0 i < size i++ ret += values i values i math sqrt ret infinity norm size 1 != max sorted index sort indices values == 1 0 max = n e g a t i v e i n f i n i t y i = 0 i < size i++ math abs values i > max max = math abs values i max print out a s v size= +size+ dict size= +dictionary size + values length= +values length+ indices length= +indices length size 1 != max sorted index sort indices print sort indices indices == vector dense so indices are already sorted size == 0 assume called from constructor initialize member vars size = indices length max sorted index = 1 just bubble sort efficient when already mostly sorted note that we bubble sort from end forward most efficient when we have added a few additional items to end a previously sorted list note that we remember highest index that was already sorted max sorted index note that max sorted index may be 1 here so first time through outer loop just falls through immediately when termination condition inner loop met i = max sorted index+1 i < size i++ j = i j > 0 j indices j < indices j 1 swap both indices and values f f = indices j indices j = indices j 1 indices j 1 = f values != v v = values j values j = values j 1 values j 1 = v remove duplicates 0 max sorted index = size 1 argument zero special value meaning that function should count them otherwise it assumes they have been counted elsewhere and that num duplicates how many that count yeilded note that relies on indices being sorted first remove duplicates num duplicates indices == out print a f v remove duplicates i = 0 i < size i++ out print + dictionary lookup indices i + = + indices i out num duplicates= +num duplicates num duplicates == 0 i = 1 i < size i++ indices i 1 == indices i num duplicates++ num duplicates == 0 indices length num duplicates > 0 size= +size+ indices length= +indices length+ num duplicates= +num duplicates indices = size num duplicates values = values == ? size num duplicates indices 0 = indices 0 indices length >= size i = 0 j = 0 i < size 1 i++ indices i == indices i+1 values != values j += values i indices j = indices i values != values j += values i j++ i == size 2 values != values j += values i+1 indices j = indices i+1 indices = indices values = values size = num duplicates max sorted index = size 1 serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write size out write max sorted index read input stream in i o not found = in read size = in read max sorted index = in read 