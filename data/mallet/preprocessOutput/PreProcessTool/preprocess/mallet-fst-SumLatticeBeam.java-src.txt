list logging level logging logger transducer state transducer transition iterator types dense vector types label alphabet types label vector types matrix ops types sequence types sequence pair logger p a l n e w b e a m forward backward sum lattice beam sum lattice p a l like lattice but using max product to get viterbi path p a l these worked well nettalk beam width = 10 k leps = 005 use forward backward beam = beam width = 3 k leps = 0 rmin = 0 1 nstates expl cur iter = 0 tct iter = 0 number times we have been called iteration cur avg nstates expl get beam width beam width set beam width beam width beam width = beam width get tct iter tct iter set cur iter cur iter cur iter = cur iter tct iter = 0 inc iter tct iter++ set k leps k leps k leps = k leps set rmin rmin rmin = rmin get nstates expl nstates expl get use forward backward beam use forward backward beam set use forward backward beam state use forward backward beam = state logger logger = logger get logger sum lattice beam get name ip == input position op == output position i == state index transducer t weight sequence input output lattice node nodes indexed ip i lattice length cur beam width p a l can be adapted maximizer confused xxx now that we are incrementing here directly there isn t necessarily a need to save all these arrays log probability being in state i at input position ip gammas indexed ip i xis indexed ip i j saved only save xis label vector labelings indexed op created only output alphabet non in constructor lattice node get lattice node ip state index nodes ip state index == nodes ip state index = lattice node ip t get state state index nodes ip state index you may pass output meaning that lattice not constrained to match output sum lattice beam transducer t sequence input sequence output transducer incrementor incrementor t input output incrementor you may pass output meaning that lattice not constrained to match output sum lattice beam transducer t sequence input sequence output transducer incrementor incrementor save xis t input output incrementor save xis output alphabet non will create a label vector each position in output sequence indicating probability over possible outputs at that time index sum lattice beam transducer t sequence input sequence output transducer incrementor incrementor save xis label alphabet output alphabet t = t logger loggable level f i n e logger fine starting lattice logger fine input ip = 0 ip < input size ip++ logger fine + input get ip logger fine output output == logger fine op = 0 op < output size op++ logger fine + output get op logger fine initialize some structures input = input output = output xxx not very efficient when lattice actually sparse especially when number states large and sequence lattice length = input size +1 num states = t num states nodes = lattice node lattice length num states xxx yipes could get big something sparse might be better? gammas = lattice length num states save xis xis = lattice length num states num states output counts = output alphabet != output counts = lattice length output alphabet size i = 0 i < num states i++ ip = 0 ip < lattice length ip++ gammas ip i = transducer i m p o s s i b l e w e i g h t save xis j = 0 j < num states j++ ip = 0 ip < lattice length ip++ xis ip i j = transducer i m p o s s i b l e w e i g h t forward pass logger fine starting foward pass at least one initial state = i = 0 i < num states i++ initial weight = t get state i get initial weight out forward pass initial weight = +initial weight initial weight < transducer i m p o s s i b l e w e i g h t get lattice node 0 i alpha = initial weight out nodes 0 i alpha= +nodes 0 i alpha at least one initial state = at least one initial state == logger warning there are no starting states! p a l a sorted list our beam experiments n best slist slists = n best slist lattice length p a l used stats nstates expl = lattice length p a l used to adapt beam optimizer getting confused tct iter++ cur iter == 0 cur beam width = num states tct iter > 1 cur iter != 0 cur beam width = math min math round cur avg nstates expl 2 num states out doubling minimum beam size to +cur beam width cur beam width = beam width cur beam width = beam width ip = 0 ip < lattice length 1 ip++ p a l add to construct beam p a l sets up sorted list slists ip = n best slist num states p a l set slists ip set k l min e cur beam width slists ip set k leps k leps slists ip set rmin rmin i = 0 i< num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t state s = t get state i p a l give n b viterbi node weight position n b back node cnode = n b back node nodes ip i alpha i slists ip push cnode p a l unlike std n best beam we now filter list based on a k l divergence like measure use which computes cumulative log sum and finds point at which sum within k leps k l max pos=1 rmin pos=1 k leps > 0 k l max pos = slists ip get k lpos nstates expl ip = k l max pos k leps == 0 rmin > 0 rmin pos = slists ip get t h rpos slists ip set rmin rmin rmin pos = slists ip get t h rpos s t r a w m a n nstates expl ip = rmin pos trick negative values k leps mean use max k l an rmin slists ip set k leps k leps k l max pos = slists ip get k lpos rmin pos = slists ip get t h rpos rmin > 0 rmin pos = slists ip get t h rpos slists ip set rmin rmin rmin pos = slists ip get t h rpos s t r a w m a n k l max pos > rmin pos nstates expl ip = k l max pos nstates expl ip = rmin pos out nstates expl ip + p a l contemplating setting values to something tmppos i = nstates expl ip +1 i < slists ip size i++ tmppos = slists ip get pos index i nodes ip tmppos alpha = transducer i m p o s s i b l e w e i g h t nodes ip tmppos = faster and seems to work same done contemplation i = 0 i < num states i++ jj=0 jj< nstates expl ip jj++ i = slists ip get pos index jj p a l dont need anymore should be taken care in lists nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t xxx we end up doing a lot we could save a list non ones state s = t get state i transition iterator iter = s transition iterator input ip output ip logger loggable level f i n e logger fine starting foward transition iteration from state + s get name + on input + input get ip to + and output + output==null ? output get ip to iter has next state destination = iter next state logger loggable level f i n e logger fine forward lattice input pos= +ip + source= +s get name + dest= +destination get name + lattice node destination node = get lattice node ip+1 destination get index destination node output = iter get output transition weight = iter get weight logger loggable level f i n e logger fine transition weight= +transition weight + nodes +ip+ +i+ alpha= +nodes ip i alpha + destination node alpha= +destination node alpha destination node alpha = transducer sum log prob destination node alpha nodes ip i alpha + transition weight out destination node alpha < +destination node alpha out mean nodes explored + matrix ops mean nstates expl cur avg nstates expl = matrix ops mean nstates expl calculate total cost lattice normalizer weight = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes lattice length 1 i != note actually we could sum at any ip index choice lattice length 1 arbitrary out ending alpha state +i+ = +nodes lattice length 1 i alpha out ending beta state +i+ = +t get state i weight weight = transducer sum log prob weight nodes lattice length 1 i alpha + t get state i get weight weight now an unnormalized weight entire lattice weight >= 0 weight = +weight sequence has infinite weight just usefully avoids calling any increment x it also relies on fact that gammas and alpha and beta values are already initialized to values that reflect infinite weight xxx although perhaps not all alphas betas exactly correctly reflecting? weight == transducer i m p o s s i b l e w e i g h t backward pass i = 0 i < num states i++ nodes lattice length 1 i != state s = t get state i nodes lattice length 1 i beta = s get weight gammas lattice length 1 i = nodes lattice length 1 i alpha + nodes lattice length 1 i beta weight incrementor != p = math exp gammas lattice length 1 i p > transducer i m p o s s i b l e w e i g h t ! na n p p= +p+ gamma= +gammas lattice length 1 i incrementor increment state s p ip = lattice length 2 ip >= 0 ip i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t note that skipping here based on alpha means that beta values won t be correct but since alpha infinite anyway it shouldn t matter state s = t get state i transition iterator iter = s transition iterator input ip output ip iter has next state destination = iter next state logger loggable level f i n e logger fine backward lattice input pos= +ip + source= +s get name + dest= +destination get name + j = destination get index lattice node destination node = nodes ip+1 j destination node != transition weight = iter get weight ! na n transition weight transition weight >= 0 not necessarily old beta = nodes ip i beta ! na n nodes ip i beta nodes ip i beta = transducer sum log prob nodes ip i beta destination node beta + transition weight ! na n nodes ip i beta dest beta= +destination node beta+ trans= +transition weight+ sum= + destination node beta+transition weight + old beta= +old beta xi = nodes ip i alpha + transition weight + nodes ip+1 j beta weight save xis xis ip i j = xi ! na n nodes ip i alpha ! na n transition weight ! na n nodes ip+1 j beta ! na n weight incrementor != || output alphabet != p = math exp xi p > transducer i m p o s s i b l e w e i g h t ! na n p xis +ip+ +i+ +j+ = +xi incrementor != incrementor increment transition iter p output alphabet != output index = output alphabet lookup index iter get output output index >= 0 xxx assumes that ip == op ! output counts ip output index += p out r f lattice output counts +ip+ +output index+ += +p gammas ip i = nodes ip i alpha + nodes ip i beta weight p a l check normalization checknorm = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes ip i != note actually we could sum at any ip index choice lattice length 1 arbitrary out ending alpha state +i+ = +nodes lattice length 1 i alpha out ending beta state +i+ = +t get state i weight checknorm = transducer sum log prob checknorm gammas ip i out check gamma sum= +checknorm p a l done check normalization p a l normalize i = 0 i < num states i++ nodes ip i != gammas ip i = gammas ip i checknorm out check gamma sum= +checknorm p a l normalization incrementor != i = 0 i < num states i++ p = math exp gammas 0 i p > transducer i m p o s s i b l e w e i g h t ! na n p incrementor increment initial state t get state i p output alphabet != labelings = label vector lattice length ip = lattice length 2 ip >= 0 ip math abs 1 0 matrix ops sum output counts ip < 0 000001 labelings ip = label vector output alphabet output counts ip sequence get input input p a l a simple node holding a weight and position state n b back node weight pos n b back node weight pos weight = weight pos = pos n best slist list list = list max elements k l min elements k l max pos k leps rmin n best slist max elements max elements = max elements set k l min e k l min elements k l min elements = k l min elements size list size empty list empty pop list remove 0 get pos index ii n b back node tn = n b back node list get ii tn pos get weight index ii n b back node tn = n b back node list get ii tn weight set k leps k leps k leps = k leps set rmin rmin rmin = rmin get t h rpos n b back node tn lc1 lc2 tn = n b back node list get 0 lc1 = tn weight tn = n b back node list get list size 1 lc2 = tn weight minc = lc1 lc2 minc t h r = minc minc rmin i=1 i<list size i++ tn = n b back node list get i lc1 = tn weight lc2 lc1 > minc t h r i+1 list size get t h rpos s t r a w m a n n b back node tn lc1 lc2 tn = n b back node list get 0 lc1 = tn weight minc t h r = lc1 rmin minc = lc1 lc2 minc t h r = minc minc rmin i=1 i<list size i++ tn = n b back node list get i lc1 = tn weight lc1 < minc t h r i+1 list size get k lpos k leps = 0 1 s n l p s n l p = max elements worstc n b back node tn tn = n b back node list get list size 1 worstc = tn weight i=0 i<list size i++ tn = n b back node list get i n o t e sometimes we can have positive numbers ! lc = tn weight lc = tn weight worstc lc >0 asdf=1 i==0 s n l p i = lc s n l p i = transducer sum log prob s n l p i 1 lc normalize i=0 i<list size i++ s n l p i = s n l p i s n l p list size 1 s n l p i < k leps k l max pos = i+1 k l max pos >= k l min elements k l max pos list size >= k l min elements k l min elements k l max pos = list size k l max pos list push n b back node vn tc = vn weight at end = i=0 i<list size i++ n b back node tn = n b back node list get i lc = tn weight tc < lc list add i vn at end = at end list add vn p a l list too big remove first largest weight element list size > max elements list remove max elements f = o total weight o next best state index at end = i=0 i<list size i++ a search node n best temp node = a search node n best list get i f1 = temp node total weight temp node next best state index f < f1 list add i o at end = at end list add o list p a l end n best slist culotta constrained lattice create constrained lattice such that all paths pass through labeling <code> required segment < code> indicated <code> constrained sequence < code> input sequence input sequence output sequence output sequence required segment segment sequence that must be labelled constrained sequence lattice must have labels sequence from <code> required segment start < code> to <code> required segment end < code> correctly sum lattice beam transducer t sequence input sequence sequence output sequence segment required segment sequence constrained sequence t input sequence output sequence transducer incrementor make constraints t input sequence output sequence required segment constrained sequence make constraints transducer t sequence input sequence sequence output sequence segment required segment sequence constrained sequence constrained sequence size != input sequence size illegal argument constrained sequence size + constrained sequence size + != input sequence size + input sequence size + constraints tells lattice which states must emit which observations positive values say all paths must pass through state index negative values say all paths must not pass through state index 0 means we t care initialize to 0 include 1 extra node start state constraints = constrained sequence size + 1 = 0 < constraints length c++ constraints = 0 i=required segment get start i <= required segment get end i++ si = t state index constrained sequence get i si == 1 logger warning could not find state + constrained sequence get i + check that state labels match start tages and in tags and that all labels are seen in training data illegal argument could not find state + constrained sequence get i + check that state labels match start tags and in tags constraints i+1 = si + 1 set additional negative constraint to ensure state after segment not a tag xxx segment length=1 actually constrains sequence to b tag b tag instead intended constraint b tag i tag fix below unsafe but will have to now f i x e d b e l o w end tag = constrained sequence get required segment get end required segment get end +2 < constraints length required segment get start == required segment get end segment has length 1 end tag starts b end tag = i + end tag substring 1 end tag length ! end tag starts i || end tag starts 0 illegal argument constrained lattice requires that states are tagged in b i o format statei = state index end tag statei == 1 no i tag b tag statei = state index constrained sequence get required segment get start constraints required segment get end + 2 = statei + 1 required segment get end + 2 < constraints length end tag = required segment get in tag to statei = t state index end tag statei == 1 illegal argument could not find state + end tag + check that state labels match start tags and in tags constraints required segment get end + 2 = statei + 1 print states logger fine segment + required segment sequence to + constrained sequence + constrained sequence + constraints i=0 i < constraints length i++ logger fine constraints i + logger fine constraints culotta constructor constrained lattice create a lattice that constrains its transitions such that <position label> pairs in constraints are adhered to constraints an where each entry index required label at that position an entry 0 means there are no constraints on that <position label> positive values mean path must pass through that state negative values mean path must not pass through that state n o t e constraints length must be equal to output size + 1 a lattice has one extra position initial state generally should be unconstrained since it does not produce an observation sum lattice beam transducer t sequence input sequence output transducer incrementor incrementor label alphabet output alphabet constraints t = t logger loggable level f i n e logger fine starting lattice logger fine input ip = 0 ip < input size ip++ logger fine + input get ip logger fine output output == logger fine op = 0 op < output size op++ logger fine + output get op logger fine initialize some structures input = input output = output xxx not very efficient when lattice actually sparse especially when number states large and sequence lattice length = input size +1 num states = t num states nodes = lattice node lattice length num states xxx yipes could get big something sparse might be better? gammas = lattice length num states xxx move to an ivar so we can save it? but what? commenting out because it s a memory hog and not used right now uncomment and conditionalize a flag ever needed cas xis = lattice length num states num states output counts = output alphabet != output counts = lattice length output alphabet size i = 0 i < num states i++ ip = 0 ip < lattice length ip++ gammas ip i = transducer i m p o s s i b l e w e i g h t commenting out xis cas j = 0 j < num states j++ ip = 0 ip < lattice length ip++ xis ip i j = transducer i m p o s s i b l e w e i g h t forward pass logger fine starting constrained foward pass ensure that at least one state has initial weight less than infinity so we can start from there at least one initial state = i = 0 i < num states i++ initial weight = t get state i get initial weight out forward pass initial weight = +initial weight initial weight > transducer i m p o s s i b l e w e i g h t get lattice node 0 i alpha = initial weight out nodes 0 i alpha= +nodes 0 i alpha at least one initial state = at least one initial state == logger warning there are no starting states! ip = 0 ip < lattice length 1 ip++ i = 0 i < num states i++ logger fine ip= + ip+ i= + i check node possible at <position label> not skip it constraints ip > 0 must be in state indexed constraints ip 1 constraints ip 1 != i logger fine current state does not match positive constraint position= +ip+ constraint= + constraints ip 1 + curr state= +i constraints ip < 0 must not be in state indexed constraints ip constraints ip +1 == i logger fine current state does not match negative constraint position= +ip+ constraint= + constraints ip +1 + curr state= +i nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t xxx we end up doing a lot we could save a list non ones nodes ip i == logger fine nodes ip i n u l l nodes ip i alpha == transducer i m p o s s i b l e w e i g h t logger fine nodes ip i alpha inf logger fine i n f i n i t e weight or n u l l skipping state s = t get state i transition iterator iter = s transition iterator input ip output ip logger loggable level f i n e logger fine starting forward transition iteration from state + s get name + on input + input get ip to + and output + output==null ? output get ip to iter has next state destination = iter next state legal transition = check constraints to node at <ip i> can transition to destination ip+1 < constraints length constraints ip+1 > 0 constraints ip+1 1 != destination get index logger fine destination state does not match positive constraint assigning infinite weight position= + ip+1 + constraint= + constraints ip+1 1 + source = +i+ destination= +destination get index legal transition = ip+1 < constraints length constraints ip+1 < 0 constraints ip+1 +1 == destination get index logger fine destination state does not match negative constraint assigning infinite weight position= + ip+1 + constraint= + constraints ip+1 +1 + destination= +destination get index legal transition = logger loggable level f i n e logger fine forward lattice input pos= +ip + source= +s get name + dest= +destination get name + lattice node destination node = get lattice node ip+1 destination get index destination node output = iter get output transition weight = iter get weight legal transition logger loggable level f i n e logger fine transition weight= +transition weight + nodes +ip+ +i+ alpha= +nodes ip i alpha + destination node alpha= +destination node alpha destination node alpha = transducer sum log prob destination node alpha nodes ip i alpha + transition weight out destination node alpha < +destination node alpha logger fine set alpha lattice node at ip = + ip+1 + state index = + destination get index + destination node alpha = + destination node alpha an illegal transition according to our constraints so set its prob to 0 n o alpha s are unnormalized weights set to inf destination node alpha = 0 0 destination node alpha = transducer i m p o s s i b l e w e i g h t logger fine illegal transition from state + i + to state + destination get index + setting alpha to inf calculate total weight lattice normalizer weight = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes lattice length 1 i != note actually we could sum at any ip index choice lattice length 1 arbitrary out ending alpha state +i+ = +nodes lattice length 1 i alpha out ending beta state +i+ = +t get state i weight constraints lattice length 1 > 0 i != constraints lattice length 1 1 constraints lattice length 1 < 0 i == constraints lattice length 1 +1 logger fine summing lattice weight state= +i+ alpha= +nodes lattice length 1 i alpha + weight = +t get state i get weight weight = transducer sum log prob weight nodes lattice length 1 i alpha + t get state i get weight weight now an unnormalized weight entire lattice weight >= 0 weight = +weight sequence has infinite weight just usefully avoids calling any increment x it also relies on fact that gammas and alpha and beta values are already initialized to values that reflect infinite weight xxx although perhaps not all alphas betas exactly correctly reflecting? weight == transducer i m p o s s i b l e w e i g h t backward pass i = 0 i < num states i++ nodes lattice length 1 i != state s = t get state i nodes lattice length 1 i beta = s get weight gammas lattice length 1 i = nodes lattice length 1 i alpha + nodes lattice length 1 i beta weight incrementor != p = math exp gammas lattice length 1 i p >= 0 p <= 1 0 ! na n p p= +p+ gamma= +gammas lattice length 1 i incrementor increment state s p ip = lattice length 2 ip >= 0 ip i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t note that skipping here based on alpha means that beta values won t be correct but since alpha infinite anyway it shouldn t matter state s = t get state i transition iterator iter = s transition iterator input ip output ip iter has next state destination = iter next state logger loggable level f i n e logger fine backward lattice input pos= +ip + source= +s get name + dest= +destination get name + j = destination get index lattice node destination node = nodes ip+1 j destination node != transition weight = iter get weight ! na n transition weight transition weight >= 0 not necessarily old beta = nodes ip i beta ! na n nodes ip i beta nodes ip i beta = transducer sum log prob nodes ip i beta destination node beta + transition weight ! na n nodes ip i beta dest beta= +destination node beta+ trans= +transition weight+ sum= + destination node beta+transition weight + old beta= +old beta xis ip i j = nodes ip i alpha + transition weight + nodes ip+1 j beta weight ! na n nodes ip i alpha ! na n transition weight ! na n nodes ip+1 j beta ! na n weight incrementor != || output alphabet != xi = nodes ip i alpha + transition weight + nodes ip+1 j beta weight p = math exp xi p >= 0 p <= 1 0 ! na n p xis +ip+ +i+ +j+ = + xi incrementor != incrementor increment transition iter p output alphabet != output index = output alphabet lookup index iter get output output index >= 0 xxx assumes that ip == op ! output counts ip output index += p out r f lattice output counts +ip+ +output index+ += +p gammas ip i = nodes ip i alpha + nodes ip i beta weight incrementor != i = 0 i < num states i++ p = math exp gammas 0 i p >= 0 0 p <= 1 0 ! na n p incrementor increment initial state t get state i p output alphabet != labelings = label vector lattice length ip = lattice length 2 ip >= 0 ip math abs 1 0 matrix ops sum output counts ip < 0 000001 labelings ip = label vector output alphabet output counts ip get total weight ! na n weight weight no weight an unnormalized weight get probability math exp weight get gamma weight input position state s gammas input position s get index get gamma probability input position state s math exp gammas input position s get index get xis xis get gammas gammas get xi probability ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index math exp xis ip i j get xi weight ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index xis ip i j length lattice length get alpha ip state s lattice node node = get lattice node ip s get index node alpha get beta ip state s lattice node node = get lattice node ip s get index node beta label vector get labeling at position output position labelings != labelings output position transducer get transducer t a container some about a particular input position and state lattice node input position output position not really needed until we deal asymmetric epsilon state state output alpha = transducer i m p o s s i b l e w e i g h t beta = transducer i m p o s s i b l e w e i g h t lattice node input position state state input position = input position state = state alpha == transducer i m p o s s i b l e w e i g h t xxx remove check factory sum lattice factory bw factory beam width bw = beam width sum lattice sum lattice transducer trans sequence input sequence output transducer incrementor incrementor save xis label alphabet output alphabet sum lattice beam trans input output incrementor save xis output alphabet beam width = bw 