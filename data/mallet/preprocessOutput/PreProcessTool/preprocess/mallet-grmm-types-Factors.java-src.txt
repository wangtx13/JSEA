2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types inference inferencer flops types gnu trove t list gnu trove t list a utility containing utility dealing factors especially table factor created mar 17 2005 author < a h r e f= mailto casutton edu>casutton edu< a> $ factors v 1 1 2007 10 22 21 37 44 exp $ factors p t normalize cpt table factor ptl variable var sums = ptl num locations arrays fill sums n e g a t i v e i n f i n i t y compute normalization factor each neighbor assignment var set neighbors = hash var set ptl var set neighbors remove var assignment iterator it = ptl assignment iterator it has next it advance assignment assn = it assignment assignment nbr assn = assignment assn marginalize out var idx = nbr assn single index sums idx += ptl phi assn sums idx = maths sum log prob ptl log value assn sums idx and then normalize potential assignment iterator it = ptl assignment iterator it has next it advance assignment assn = it assignment old val = ptl log value assn old val = ptl phi assn assignment nbr assn = assignment assn marginalize out var log z = sums nbr assn single index ptl set phi assn old val log z infinite old val infinite log z 0 0 = 0 ptl set log value assn n e g a t i v e i n f i n i t y ptl set log value assn old val log z p t ptl var factor average factor ptl1 factor ptl2 weight complete hack table factor mptl1 = table factor ptl1 table factor mptl2 = table factor ptl2 table factor hacky mixture mptl1 mptl2 weight one distance factor bel1 factor bel2 set vs1 = bel1 var set set vs2 = bel2 var set !vs1 equals vs2 illegal argument attempt to take distancebetween mismatching potentials +bel1+ and +bel2 dist = 0 assignment iterator it = bel1 assignment iterator it has next assignment assn = it assignment dist += math abs bel1 value assn bel2 value assn it advance dist table factor retain mass discrete factor ptl alpha idxs = ptl num locations vals = ptl num locations i = 0 i < idxs length i++ idxs i = ptl index at location i vals i = ptl log value i ranked feature vector rfv = ranked feature vector alphabet idxs vals t list idx list = t list t list val list = t list mass = n e g a t i v e i n f i n i t y log alpha = math log alpha rank = 0 rank < rfv num locations rank++ idx = rfv get index at rank rank val = rfv value idx mass = maths sum log prob mass val idx list add idx val list add val mass > log alpha szs = compute sizes ptl sparse matrixn m = sparse matrixn szs idx list to val list to table factor result = table factor compute vars ptl result set values m result compute sizes factor result nv = result var set size szs = nv i = 0 i < nv i++ variable var = result get variable i szs i = var get num outcomes szs variable compute vars factor result nv = result var set size variable vars = variable nv i = 0 i < nv i++ variable var = result get variable i vars i = var vars given a joint over two variables their mutual factor a joint must be normalized and over exactly two variables mutual inforamiton mutual factor factor var set vs = factor var set vs size != 2 illegal argument factor must have size 2 factor marg1 = factor marginalize vs get 0 factor marg2 = factor marginalize vs get 1 result = 0 iterator it = factor assignment iterator it has next assignment assn = assignment it next result += factor value assn factor log value assn marg1 log value assn marg2 log value assn result k l table factor f1 table factor f2 result = 0 assumes same var set loc = 0 loc < f1 num locations loc++ val1 = f1 value at location loc val2 = f2 value f1 index at location loc val1 > 1e 5 result += val1 math log val1 val2 result a factor <tt> f = alpha f1 + 1 alpha f2< tt> factor mix table factor f1 table factor f2 alpha table factor hacky mixture f1 f2 alpha euclidean distance table factor f1 table factor f2 result = 0 assumes same var set loc = 0 loc < f1 num locations loc++ val1 = f1 value at location loc val2 = f2 value f1 index at location loc result += val1 val2 val1 val2 math sqrt result l1 distance table factor f1 table factor f2 result = 0 assumes same var set loc = 0 loc < f1 num locations loc++ val1 = f1 value at location loc val2 = f2 value f1 index at location loc result += math abs val1 val2 result adapter that allows an inferencer to be treated it were a factor inf an inferencer on which compute marginals has been called a factor factor factor inferencer inf skeleton factor value assignment assn factor factor = inf lookup marginal assn var set factor value assn factor marginalize variable vars inf lookup marginal hash var set vars factor marginalize collection vars inf lookup marginal hash var set vars factor marginalize variable var inf lookup marginal hash var set variable var factor marginalize out variable var unsupported operation factor marginalize out var set varset unsupported operation var set var set unsupported operation variable discrete vars factor fg list vars = list var set vs = fg var set vi = 0 vi < vs size vi++ variable var = vs get vi !var continuous vars add var variable vars to variable vars size variable continuous vars factor fg list vars = list var set vs = fg var set vi = 0 vi < vs size vi++ variable var = vs get vi var continuous vars add var variable vars to variable vars size corr factor factor factor var set size != 2 illegal argument corr only works on factors size 2 tried +factor variable v0 = factor var set get 0 variable v1 = factor var set get 1 e x y = 0 0 assignment iterator it = factor assignment iterator it has next assignment assn = assignment it next val0 = assn get v0 val1 = assn get v1 e x y += factor value assn val0 val1 e x = mean factor marginalize v0 e y = mean factor marginalize v1 e x y e x e y mean factor factor factor var set size != 1 illegal argument mean only works on factors size 1 tried +factor variable v0 = factor var set get 0 mean = 0 0 assignment iterator it = factor assignment iterator it has next assignment assn = assignment it next val0 = assn get v0 mean += factor value assn val0 mean factor multiply all collection factors factor first = factor factors iterator next factors size == 1 first duplicate get all variables var set vs = hash var set iterator it = factors iterator it has next factor phi = factor it next vs add all phi var set define a potential over neighbors n o d e factor result = first duplicate iterator it = factors iterator it has next factor phi = factor it next result multiply phi result dist linf table factor f1 table factor f2 sum1 = f1 logsum sum2 = f2 logsum matrix m1 = f1 get log value matrix matrix m2 = f2 get log value matrix matrix dist linf m1 m2 dist value linf table factor f1 table factor f2 sum1 = f1 logsum sum2 = f2 logsum matrix m1 = f1 get value matrix matrix m2 = f2 get value matrix matrix dist linf m1 m2 matrix dist linf matrix m1 matrix m2 max = 0 nl1 = m1 single size nl2 = m2 single size nl1 != nl2 p o s i t i v e i n f i n i t y l = 0 l < nl1 l++ val1 = m1 single value l val2 = m2 single value l diff = val1 > val2 ? val1 val2 val2 val1 max = diff > max ? diff max max range measure from ihler et al log range table factor f1 table factor f2 min = m a x v a l u e max = 0 matrix m1 = f1 get log value matrix matrix m2 = f2 get log value matrix nl1 = m1 single size nl2 = m2 single size nl1 != nl2 p o s i t i v e i n f i n i t y l = 0 l < nl1 l++ val1 = m1 single value l val2 = m2 single value l diff = val1 > val2 ? val1 val2 val2 val1 max = diff > max ? diff max min = diff < min ? diff min max min 