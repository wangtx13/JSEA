2003 university pennsylvania m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e io io input stream io output stream io reader io input stream io output stream io reader list random logging logger regex pattern types alphabet types augmentable feature vector types feature vector types feature vector sequence types instance types instance list types label alphabet types label sequence types sequence pipe pipe pipe iterator line group iterator command option logger s trains tests or runs a generic r f based sequence tagger <p> training and test files consist blocks lines one block each instance separated blank lines each block lines should have first form specified input link simple tagger sentence2 feature vector sequence a variety command line options control operation program described in comments link #main author fernando pereira <a href= mailto pereira cis upenn >pereira cis upenn edu< a> 1 0 simple tagger logger logger = logger get logger simple tagger get name no <code> simple tagger< code> allowed simple tagger converts an external encoding a sequence elements binary features to a link feature vector sequence target processing on training or labeled test data it extracts element labels from external encoding to create a target link label sequence two external encodings are supported <ol> <li> a link containing lines whitespace separated tokens < li> <li> a link <code> < code> < li> < ol> both represent rows tokens when target processing on last token in each row label sequence element represented row all other tokens in row or all tokens in row not target processing are names features that are on sequence element described row converts an external encoding a sequence elements binary features to a link feature vector sequence target processing on training or labeled test data it extracts element labels from external encoding to create a target link label sequence two external encodings are supported <ol> <li> a link containing lines whitespace separated tokens < li> <li> a link <code> < code> < li> < ol> both represent rows tokens when target processing on last token in each row label sequence element represented row all other tokens in row or all tokens in row not target processing are names features that are on sequence element described row simple tagger sentence2 feature vector sequence pipe gdruck previously there was no serial u that would have been automatically generated compiler therefore other changes should not serialization serial u = 2059308802200728625 l creates a <code> simple tagger sentence2 feature vector sequence< code> instance simple tagger sentence2 feature vector sequence alphabet label alphabet parses a representing a sequence rows tokens into an arrays tokens sentence a <code> string< code> corresponding arrays tokens parse sentence sentence lines = sentence split tokens = lines length i = 0 i < lines length i++ tokens i = lines i split tokens instance pipe instance carrier input data = carrier get data alphabet features = get data alphabet label alphabet labels label sequence target = tokens input data tokens = parse sentence input data input data tokens = input data illegal argument not a or got + input data feature vector fvs = feature vector tokens length target processing labels = label alphabet get target alphabet target = label sequence labels tokens length l = 0 l < tokens length l++ n features target processing tokens l length < 1 illegal state missing label at line + l + instance +carrier get name n features = tokens l length 1 target add tokens l n features n features = tokens l length list< integer> feature indices = list< integer> f = 0 f < n features f++ feature index = features lookup index tokens l f gdruck data alphabet s growth stopped feature index will be 1 ignore these features feature index >= 0 feature indices add feature index feature indices arr = feature indices size index = 0 index < feature indices size index++ feature indices arr index = feature indices get index fvs l = feature induction option value ? augmentable feature vector features feature indices arr feature indices arr length feature vector features feature indices arr carrier set data feature vector sequence fvs target processing carrier set target target carrier set target label sequence get target alphabet carrier command option gaussian variance option = command option simple tagger gaussian variance d e i m a l 10 0 gaussian prior variance used training command option train option = command option simple tagger train true|false whether to train command option test option = command option simple tagger test lab or seg=start 1 1 start n n test measuring labeling or segmentation start i i accuracy command option model option = command option simple tagger model f i l e n a m e filename reading train run or saving train model command option training fraction option = command option simple tagger training proportion d e i m a l 0 5 fraction data to use training in a random split command option random seed option = command option simple tagger random seed i n t e g e r 0 random seed randomly selecting a proportion instance list training command option orders option = command option simple tagger orders o m m a s e p d e i m a l s 1 list label markov orders and backoff command option forbidden option = command option simple tagger forbidden r e g e x p \\s label1 label2 transition forbidden it matches command option allowed option = command option simple tagger allowed r e g e x p label1 label2 transition allowed only it matches command option option = command option simple tagger label s t r i n g o label initial context and uninteresting tokens command option iterations option = command option simple tagger iterations i n t e g e r 500 number training iterations command option viterbi output option = command option simple tagger viterbi output true|false print viterbi periodically during training command option connected option = command option simple tagger fully connected true|false include all allowed transitions even those not in training data command option weights option = command option simple tagger weights sparse|some dense|dense some dense use sparse some dense using a heuristic or dense features on transitions command option training option = command option simple tagger training true|false training from model specified model command option n best option = command option simple tagger n best i n t e g e r 1 how many answers to output command option cache size option = command option simple tagger cache size i n t e g e r 100000 how much state to memoize in n best decoding command option include input option = command option simple tagger include input true|false whether to include input features when printing decoding output command option feature induction option = command option simple tagger feature induction true|false whether to perform feature induction during training command option num threads = command option simple tagger threads i n t e g e r 1 number threads to use r f training command option list command options = command option list training testing and running a generic tagger command option gaussian variance option train option iterations option test option training fraction option model option random seed option orders option forbidden option allowed option option viterbi output option connected option weights option training option n best option cache size option include input option feature induction option num threads create and train a r f model from given training data optionally testing it on given test data training training data testing test data possibly <code>null< code> eval accuracy evaluator possibly <code>null< code> orders label markov orders and backoff label label forbidden regular expression specifying impossible label transitions <em>current< em><code> < code><em>next< em> <code>null< code> indicates no forbidden transitions allowed regular expression specifying allowed label transitions <code>null< code> indicates everything allowed that not forbidden connected whether to include even transitions not occurring in training data iterations number training iterations var gaussian prior variance trained model r f train instance list training instance list testing transducer evaluator eval orders label forbidden allowed connected iterations var r f crf pattern forbidden pat = pattern compile forbidden pattern allowed pat = pattern compile allowed crf == crf = r f training get pipe pipe start name = crf add order n states training orders label forbidden pat allowed pat connected i = 0 i < crf num states i++ crf get state i set initial weight transducer i m p o s s i b l e w e i g h t crf get state start name set initial weight 0 0 logger info training on + training size + instances testing != logger info testing on + testing size + instances num threads value > 0 num threads value > 1 r f trainer threaded label likelihood crft = r f trainer threaded label likelihood crf num threads value crft set gaussian prior variance var weights option value equals dense crft set use sparse weights crft set use some unsupported trick weights option value equals some dense crft set use sparse weights crft set use some unsupported trick weights option value equals sparse crft set use sparse weights crft set use some unsupported trick runtime unknown weights option + weights option value feature induction option value illegal argument multi threaded feature induction not yet supported converged i = 1 i <= iterations i++ converged = crft train training 1 i % 1 == 0 eval != change 1 to higher to evaluate less often eval evaluate crft viterbi output option value i % 10 == 0 viterbi writer instance list training testing training testing evaluate crft converged crft shutdown r f trainer label likelihood crft = r f trainer label likelihood crf crft set gaussian prior variance var weights option value equals dense crft set use sparse weights crft set use some unsupported trick weights option value equals some dense crft set use sparse weights crft set use some unsupported trick weights option value equals sparse crft set use sparse weights crft set use some unsupported trick runtime unknown weights option + weights option value feature induction option value crft train feature induction training testing eval iterations 10 20 500 0 5 converged i = 1 i <= iterations i++ converged = crft train training 1 i % 1 == 0 eval != change 1 to higher to evaluate less often eval evaluate crft viterbi output option value i % 10 == 0 viterbi writer instance list training testing training testing evaluate crft converged crf test a transducer on given test data evaluating accuracy given evaluator model a <code> transducer< code> eval accuracy evaluator testing test data test transducer trainer tt transducer evaluator eval instance list testing eval evaluate instance list tt testing testing apply a transducer to an input sequence to produce k highest scoring output sequences model <code> transducer< code> input input sequence k number answers to k highest scoring output sequences sequence apply transducer model sequence input k sequence answers k == 1 answers = sequence 1 answers 0 = model transduce input max lattice lattice = max lattice model input cache size option value answers = lattice best output sequences k to sequence 0 answers command line wrapper to train test or run a generic r f based tagger command line arguments options shell and quoting should be added needed <dl> <dt><code> help< code> <em>boolean< em>< dt> <dd> print command line option usage give <code>true< code> longer documentation <code>false< code> < dd> <dt><code> prefix code< code> <em> code< em>< dt> <dd> you want run before any other interpreted note that text interpreted without modification so unlike some other options you need to include any necessary s < dd> <dt><code> gaussian variance< code> <em>positive number< em>< dt> <dd> gaussian prior variance used training 10 0 < dd> <dt><code> train< code> <em>boolean< em>< dt> <dd> whether to train <code>false< code> < dd> <dt><code> iterations< code> <em>positive integer< em>< dt> <dd> number training iterations 500 < dd> <dt><code> test< code> <code>lab< code> or <code>seg=< code><em>start 1< em><code> < code><em>continue 1< em><code> < code> <code> < code><em>start n< em><code> < code><em>continue n< em>< dt> <dd> test measuring labeling or segmentation <em>start i< em> <em>continue i< em> accuracy no testing < dd> <dt><code> training proportion< code> <em>number between 0 and 1< em>< dt> <dd> fraction data to use training in a random split 0 5 < dd> <dt><code> model file< code> <em>filename< em>< dt> <dd> filename reading train run or saving train model < dd> <dt><code> random seed< code> <em>integer< em>< dt> <dd> random seed randomly selecting a proportion instance list training 0 < dd> <dt><code> orders< code> <em>comma separated integers< em>< dt> <dd> list label markov orders and backoff 1 < dd> <dt><code> forbidden< code> <em>regular expression< em>< dt> <dd> <em>label 1< em><code> < code><em>label 2< em> matches expression corresponding transition forbidden <code>\\s< code> nothing forbidden < dd> <dt><code> allowed< code> <em>regular expression< em>< dt> <dd> <em>label 1< em><code> < code><em>label 2< em> does not match expression corresponding expression forbidden <code> < code> everything allowed < dd> <dt><code> label< code> <em>string< em>< dt> <dd> label initial context and uninteresting tokens <code> o< code> < dd> <dt><code> viterbi output< code> <em>boolean< em>< dt> <dd> print viterbi periodically during training <code>false< code> < dd> <dt><code> fully connected< code> <em>boolean< em>< dt> <dd> include all allowed transitions even those not in training data <code>true< code> < dd> <dt><code> weights< code> <em>sparse|some dense|dense< em>< dt> <dd> create sparse some dense using a heuristic or dense features on transitions <code>some dense< code> < dd> <dt><code> n best< code> <em>positive integer< em>< dt> <dd> number answers to output when applying model 1 < dd> <dt><code> include input< code> <em>boolean< em>< dt> <dd> whether to include input features when printing decoding output <code>false< code> < dd> <dt><code> threads< code> <em>positive integer< em>< dt> <dd> number threads r f training 1 < dd> < dl> remaining arguments <ul> <li><em>training data file< em> training < li> <li><em>training and test data file< em> training and testing random split< li> <li><em>training data file< em> <em>test data file< em> training and testing from separate files< li> <li><em>test data file< em> testing< li> <li><em>input data file< em> applying to data unlabeled < li> < ul> an occurs reader training = test = instance list training data = test data = num evaluations = 0 iterations between evals = 16 rest = command options process options rest == length command options print usage illegal argument missing data s train option value training = reader rest test option value != rest < length 1 test = reader rest args+1 test = reader rest pipe p = r f crf = transducer evaluator eval = training option value || !train option value model option value == command options print usage illegal argument missing model option input stream s = input stream input stream model option value crf = r f s read s close p = crf get input pipe p = simple tagger sentence2 feature vector sequence p get target alphabet lookup index option value train option value p set target processing training data = instance list p training data add thru pipe line group iterator training pattern compile ^\\s $ logger info number features in training data +p get data alphabet size test option value != test != test data = instance list p test data add thru pipe line group iterator test pattern compile ^\\s $ random r = random random seed option value instance list training lists = training data split r training fraction option value 1 training fraction option value training data = training lists 0 test data = training lists 1 test option value != p set target processing test data = instance list p test data add thru pipe line group iterator test pattern compile ^\\s $ p set target processing test data = instance list p test data add thru pipe line group iterator test pattern compile ^\\s $ logger info number predicates +p get data alphabet size test option value != test option value starts lab eval = token accuracy evaluator instance list training data test data training testing test option value starts seg= pairs = test option value substring 4 split pairs length < 1 command options print usage illegal argument missing segment start labels + test option value start tags = pairs length tags = pairs length i = 0 i < pairs length i++ pair = pairs i split \\ pair length != 2 command options print usage illegal argument incorrectly specified segment start and end labels + pairs i start tags i = pair 0 tags i = pair 1 eval = multi segmentation evaluator instance list training data test data training testing start tags tags command options print usage illegal argument invalid test option + test option value p target processing alphabet targets = p get target alphabet buffer buf = buffer labels i = 0 i < targets size i++ buf append append targets lookup i to logger info buf to train option value crf = train training data test data eval orders option value option value forbidden option value allowed option value connected option value iterations option value gaussian variance option value crf model option value != output stream s = output stream output stream model option value s write crf s close crf == model option value == command options print usage illegal argument missing model option input stream s = input stream input stream model option value crf = r f s read s close eval != test noop transducer trainer crf eval test data include input = include input option value i = 0 i < test data size i++ sequence input = sequence test data get i get data sequence outputs = apply crf input n best option value k = outputs length = a = 0 a < k a++ outputs a size != input size logger info failed to decode input sequence + i + answer + a = ! j = 0 j < input size j++ buffer buf = buffer a = 0 a < k a++ buf append outputs a get j to append include input feature vector fv = feature vector input get j buf append fv to out buf to out training != training close test != test close 