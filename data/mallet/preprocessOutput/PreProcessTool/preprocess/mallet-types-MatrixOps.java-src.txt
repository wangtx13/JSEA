2003 m a l l e t m achine languag e ~mccallum 1 0 furtherinformation ` l i e n s e types random io output stream writer io print writer a utility functions manipulating arrays matrix ops sets every element a to a given value m to modify v value set all m v arrays fill m v set dest source x x x huh? statement won t work pass value buddy cas source length != dest length dest = source length arraycopy source 0 dest 0 source length multiplies every element in an a scalar m factor scalar times equals m factor i=0 i < m length i++ m i = factor calculates schur hadamard product j j w times equals m1 m2 m1 length == m2 length unequal lengths i=0 i < m1 length i++ m1 i = m2 i adds a scalar to every element in an m toadd scalar plus equals m toadd i=0 i < m length i++ m i += toadd plus equals m1 m2 m1 length == m2 length unequal lengths i=0 i < m1 length i++ infinite m1 i infinite m2 i m1 i m2 i < 0 m1 i = 0 0 m1 i += m2 i plus equals m1 m2 factor m1 length == m2 length unequal lengths i=0 i < m1 length i++ m1i = m1 i m2i = m2 i infinite m1i infinite m2i m1 i m2 i < 0 m1 i = 0 0 m1 i += m2 i factor plus equals m1 m2 factor m1 length == m2 length unequal lengths i=0 i < m1 length i++ j=0 j < m1 i length j++ m1 i j += m2 i j factor log m i = 0 i < m length i++ m i = math log m i deprecated use dot product dot m1 m2 m1 length == m2 length m1 length != m2 length ret = 0 0 i=0 i < m1 length i++ ret += m1 i m2 i ret dot product m1 m2 m1 length == m2 length m1 length != m2 length ret = 0 0 i=0 i < m1 length i++ ret += m1 i m2 i ret abs norm m ret = 0 i = 0 i < m length i++ ret += math abs m i ret two norm m ret = 0 i = 0 i < m length i++ ret += m i m i math sqrt ret two norm squared m ret = 0 i = 0 i < m length i++ ret += m i m i ret one norm m ret = 0 i = 0 i < m length i++ ret += m i ret one normalize m sum = one norm m i = 0 i < m length i++ m i = sum sum normalize m one normalize m infinity norm m ret = n e g a t i v e i n f i n i t y i = 0 i < m length i++ math abs m i > ret ret = math abs m i ret abs normalize m norm = abs norm m norm > 0 i = 0 i < m length i++ m i = norm norm two normalize m norm = two norm m norm > 0 i = 0 i < m length i++ m i = norm norm substitute m old value value i = m length 1 i >= 0 i m i == old value m i = value selected it reverses selection fselection implies that all features are selected all values in row will be changed unless selected row set all m nc ri v feature selection fselection selected fselection == selected == ci = 0 ci < nc ci++ m ri nc+ci = v xxx temporary check full selection fselection next deselected index 0 == nc ci = 0 ci < nc ci++ fselection contains ci ^ !if selected m ri nc+ci = v row dot product m nc ri vector v max ci feature selection selection row dot product m nc ri v 1 max ci selection row dot product m nc ri vector v factor max ci feature selection selection ret = 0 selection != size = v num locations cil = 0 cil < size cil++ ci = v index at location cil selection contains ci ci < nc ci <= max ci ret += m ri nc+ci v value at location cil factor size = v num locations cil = 0 cil < size cil++ ci = v index at location cil ci <= max ci ret += m ri nc+ci v value at location cil factor ret row plus equals m nc ri vector v factor vli = 0 vli < v num locations vli++ m ri nc+v index at location vli += v value at location vli factor na n m i = 0 i < m length i++ na n m i gsc similar to nan but checks inifinite values infinite m i = 0 i < m length i++ infinite m i gsc any value in either na n or infinite na n or infinite m i = 0 i < m length i++ infinite m i || na n m i gsc any value in greater than 0 0 0 0 non zero m i = 0 i < m length i++ math abs m i > 0 0 gsc any value in 0 0 0 0 zero m i = 0 i < m length i++ math abs m i == 0 0 t o d o same one norm and should be removed sum m sum = 0 i = 0 i < m length i++ sum += m i sum sum m sum = 0 i = 0 i < m length i++ j = 0 j < m i length j++ sum += m i j sum sum m sum = 0 i = 0 i < m length i++ sum += m i sum p a l t o d o should be removed because feature vector already has one norm a k m sum vector v sum = 0 vli = 0 vli < v num locations vli++ sum = sum + v value at location vli sum mean m sum = 0 i = 0 i < m length i++ sum += m i sum m length standard deviation stddev m mean = mean m s = 0 i = 0 i < m length i++ s += m i mean m i mean math sqrt s m length some prefer dividing m length 1 but also stderr m stddev m math sqrt m length gsc variance variance m mean = mean m s = 0 i = 0 i < m length i++ s += m i mean m i mean s m length some prefer dividing m length 1 but also prints a to standard output m to print print m print print writer output stream writer out m prints a to given print writer out writer to print ouput to m to print print print writer out m i = 0 i < m length i++ out print + m i out print arr i = 0 i < arr length i++ doubles = arr i print doubles print a space separated elements m an any type to m buffer sb = buffer n=java reflect get length m 1 i = 0 i<n i++ sb append reflect get m i sb append n>=0 sb append reflect get m n sb to print in rows arr i = 0 i < arr length i++ v = arr i out +i+ +arr i set all m v i = 0 i < m length i++ j = 0 j < m i length j++ k = 0 k < m i j length k++ m i j k = v set all m v i = 0 i < m length i++ j = 0 j < m i length j++ m i j = v print arr i = 0 i < arr length i++ print arr i print m i = 0 i < m length i++ out print + m i out random vector n random r ret = n i = 0 i < n i++ ret i = r next ret times equals m factor i = 0 i < m length i++ j = 0 j < m i length j++ m i j = factor maximum elementwise absolute difference between two vectors same infinity norm v1 v2 that were legal v1 input vector v2 input vector max absdiff v1 v2 max = n e g a t i v e i n f i n i t y i = 0 i < v1 length i++ val = math abs v1 i v2 i val > max max = val max max m maxval = m 0 0 i=0 i < m length i++ j=0 j < m i length j++ m i j > maxval maxval = m i j maxval max elems max = m i n v a l u e i = 0 i < elems length i++ elem = elems i elem > max max = elem max max elems max = n e g a t i v e i n f i n i t y i = 0 i < elems length i++ elem = elems i elem > max max = elem max min elems min = p o s i t i v e i n f i n i t y i = 0 i < elems length i++ elem = elems i elem < min min = elem min max index elems max = n e g a t i v e i n f i n i t y max index = 1 i = 0 i < elems length i++ elem = elems i elem > max max = elem max index = i max index min index elems min = p o s i t i v e i n f i n i t y min index = 1 i = 0 i < elems length i++ elem = elems i elem < min min = elem min index = i min index append original value ret = original length + 1 arraycopy original 0 ret 0 original length ret original length = value ret max ds max = n e g a t i v e i n f i n i t y i = 0 i < ds length i++ j = 0 j < ds i length j++ ds i j > max max = ds i j max max index ds max indices = 1 1 max = n e g a t i v e i n f i n i t y i = 0 i < ds length i++ j = 0 j < ds i length j++ ds i j > max max = ds i j max indices 0 = i max indices 1 = j max indices exp normalize scores max = matrix ops max scores sum = 0 i = 0 i < scores length i++ sum += scores i = math exp scores i max i = 0 i < scores length i++ scores i = sum 