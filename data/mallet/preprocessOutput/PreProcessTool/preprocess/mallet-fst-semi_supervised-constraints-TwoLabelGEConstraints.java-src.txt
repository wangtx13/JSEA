2010 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised constraints gnu trove t list gnu trove t hash map list bit set sum lattice semi supervised state label map types feature vector types feature vector sequence types instance types instance list a set constraints on distributions over pairs consecutive labels conditioned on presence input features subclasses are to be used g e multiple constraints are grouped together here to make things more efficient author gregory druck two label g e constraints g e constraint list< two label g e constraint> constraints list t hash map constraints map state label map map t list cache two label g e constraints constraints list = list< two label g e constraint> constraints map = t hash map map = cache = t list two label g e constraints list< two label g e constraint> constraints list t hash map constraints map state label map map constraints list = constraints list constraints map = constraints map map = map cache = t list fi input feature index target target over pairs labels weight weight constraint add constraint fi target weight one state constraint set state label map state label map map map = map pre process feature vector fv cache reset quick fi loc = 0 loc < fv num locations loc++ fi = fv index at location loc constraints map contains key fi cache add constraints map get fi bit set pre process instance list data count bit set bit set = bit set data size ii = 0 instance instance data feature vector sequence fvs = feature vector sequence instance get data ip = 1 ip < fvs size ip++ fi constraints map keys binary constraint features fvs get ip location fi >= 0 constraints list get constraints map get fi count += 1 bit set set ii ii++ bit set get composite constraint feature value feature vector fv ip si1 si2 to avoid complications start state only consider transitions into states at position >= 1 ip == 0 0 value = 0 li1 = map get label index si1 li1 == state label map s t a r t l a b e l 0 li2 = map get label index si2 i = 0 i < cache size i++ value += constraints list get cache get quick i get value li1 li2 value get value zero expectations two label g e constraint constraint constraints list constraint expectation = map get num labels map get num labels compute expectations list< sum lattice> lattices xis t list cache = t list i = 0 i < lattices size i++ lattices get i == feature vector sequence fvs = feature vector sequence lattices get i get input sum lattice lattice = lattices get i xis = lattice get xis ip = 1 ip < fvs size ++ip cache reset quick feature vector fv = fvs get feature vector ip fi loc = 0 loc < fv num locations loc++ fi = fv index at location loc binary constraint features constraints map contains key fi cache add constraints map get fi prev = 0 prev < map get num states ++prev prev = map get label index prev prev != state label map s t a r t l a b e l curr = 0 curr < map get num states ++curr curr = map get label index curr curr != state label map s t a r t l a b e l prob = math exp xis ip prev curr j = 0 j < cache size j++ constraints list get cache get quick j expectation prev curr += prob two label g e constraint target expectation count weight two label g e constraint target weight target = target weight = weight expectation = count = 0 get value prev curr 