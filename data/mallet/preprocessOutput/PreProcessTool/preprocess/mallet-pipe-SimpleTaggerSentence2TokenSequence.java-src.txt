2003 university pennsylvania m a l l e t m achine languag e ~mccallum 1 0 furtherinformation ` l i e n s e author fernando pereira <a href= mailto pereira cis upenn >pereira cis upenn edu< a> modified kuzman ganchev to covert to token sequence rather than to feature vector sequence pipe io i o io input stream io output stream types converts an external encoding a sequence elements binary features to a link token sequence target processing on training or labeled test data it extracts element labels from external encoding to create a target link label sequence two external encodings are supported <ol> <li> a link containing lines whitespace separated tokens < li> <li> a link <code> < code> < li> < ol> <p > both represent rows tokens when target processing on last token in each row label sequence element represented row all other tokens in row or all tokens in row not target processing are names features that are on sequence element described row simple tagger sentence2 token sequence pipe set tokens features creates a <code> simple tagger sentence2 token sequence< code> instance we include tokens features simple tagger sentence2 token sequence label alphabet set tokens features = creates a <code> simple tagger sentence2 token sequence< code> instance which includes tokens features iff supplied argument simple tagger sentence2 token sequence inc label alphabet set tokens features = inc parses a representing a sequence rows tokens into an arrays tokens sentence a <code> string< code> corresponding arrays tokens parse sentence sentence lines = sentence split tokens = lines length i = 0 i < lines length i++ tokens i = lines i split \\s tokens first in or has length 0 make text in in length>0 in 0 takes an instance data type or and creates an instance type token sequence each token in sequence gets test line preceding it and once feature value 1 each feature in line example a b d e and target processing off then text would be a b first token and d e second also features a and b would be set first token and d and e second last element in current token taken target label so in previous example b would have been label first sequence instance pipe instance carrier input data = carrier get data alphabet features = get data alphabet label alphabet labels label sequence target = tokens token sequence ts = token sequence input data tokens = parse sentence input data input data tokens = input data illegal argument not a or got + input data feature vector fvs = feature vector tokens length target processing labels = label alphabet get target alphabet target = label sequence labels tokens length l = 0 l < tokens length l++ n features target processing tokens l length < 1 illegal state missing label at line + l + instance + carrier get name n features = tokens l length 1 target add tokens l n features n features = tokens l length token tok = token make text tokens l set tokens features f = 0 f < n features f++ tok set feature value tokens l f 1 0 f = 1 f < n features f++ tok set feature value tokens l f 1 0 ts add tok carrier set data ts target processing carrier set target target carrier serialization garbage serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write out write u r r e n t s e r i a l v e r s i o n read input stream in i o not found in read = in read 