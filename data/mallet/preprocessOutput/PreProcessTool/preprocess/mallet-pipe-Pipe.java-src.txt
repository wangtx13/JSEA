2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e pipe concurrent concurrent hash map concurrent concurrent map logging list iterator io rmi dgc v m types alphabet types alphabet carrying types instance types single instance iterator logger superclass all pipes which transform one data type to another pipes are most often used feature extraction <p> although pipe does not have any in order to use a pipe subclass you must override either link pipe or link iterator from former appropriate when pipe s processing an instance strictly one to one every instance coming in there exactly one instance coming out later appropriate when pipe s processing may result in more or fewer instances than arrive through its source iterator <p> a pipe operates on an link types instance which a carrier data a pipe reads from and writes to fields in instance when it requested to process instance it up to pipe which fields in instance it reads from and writes to but usually a pipe will read its input from and write its output to data field an instance <p> a pipe doesn t have any direct notion input or output it merely modifies instances that are handed to it a set helper classes which implement link iterator< instance> iterate over commonly encountered input data structures and feed elements these data structures to a pipe instances <p> a pipe frequently used in conjunction an link types instance list instances are added to list they are processed pipe associated instance list and processed instance kept in list <p> in one usage a link pipe iterator iterator given a list directories to operate over iterator walks through each directory creating an instance each and putting data from in data field instance directory stored in target field instance iterator feeds instances to an instance list which processes instances through its associated pipe and keeps results <p> pipes can be hierachically composed in a typical usage a serial pipe created which holds other pipes in an ordered list piping an instance through a serial pipe means piping instance through each child pipes in sequence <p> a pipe holds two separate alphabets one symbols feature names encountered in data fields instances processed through pipe and one symbols e g labels encountered in target fields <p> author andrew mc callum <a href= mailto >mccallum edu< a> pipe serializable alphabet carrying logger logger = logger get logger pipe get name alphabet data alphabet = alphabet target alphabet = data alphabet resolved = target alphabet resolved = target processing = v m instance = v m used in read resolve to distinguish persistent instances construct a pipe no data and target dictionaries pipe construct pipe data and target dictionaries note that since values data dict and target dict are that you specify one arguments here pipe step will not ever create any corresponding dictionary argument data dict alphabet that will be used data dictionary target dict alphabet that will be used target dictionary pipe alphabet data dict alphabet target dict data alphabet = data dict target alphabet = target dict each instance processed tested it then instance passes processing pipe usage to override in an anonymous inner sub pipe <code> serial pipes sp = serial pipes pipe sequence2 token sequence precondition instance inst inst sequence token sequence2 feature sequence < code> t o d o precondition doesn t seem like best name because we t fail we pass thru consider alternatives skip pass thru skip predicate t o d o actually we might really want multiple different like a drop instance and go on to next b pass through unchanged current precondition instance inst t o d o really should be but isn t historical reasons really should be but isn t historical reasons instance pipe instance inst unsupported operation pipes +this get get name + not guarantee one to one mapping instances use iterator from instead t o d o consider naming simply iterator given an instance iterator a instance iterator whose instances have also been processed pipe you override be sure to check and obey pipe s link skip instance iterator< instance> iterator from iterator< instance> source simple pipe instance iterator source a convenience that will pull all instances from source through pipe and results an instance instances from iterator< instance> source source = iterator from source !source has next instance 0 instance inst = source next !source has next instance inst list< instance> ret = list< instance> ret add inst source has next ret add source next instance ret to instance instances from instance inst instances from single instance iterator inst t o d o we really want to encourage behavior like this? consider removing only works properly pipe one to one instance instance from instance inst instance results = instances from inst results length == 0 results 0 set whether input taken from target field instance during processing argument t expect to find input material target set target processing look and process target target processing = look and process target iff pipe expects and processes in <tt>target< tt> slot target processing target processing pipe produces that use a alphabet that dictionary even particular pipe doesn t use a alphabet it may non passing through it use a dictionary should not be called until dictionary really needed because it may set off a chain events that resolve dictionaries an entire pipeline and generally resolution should not take place until pipeline completely in place and pipe being called xxx perhaps desire to wait until pipe being called unrealistic and unnecessary alphabet get data alphabet data alphabet alphabet get target alphabet target alphabet alphabet get alphabet get data alphabet alphabet get alphabets alphabet get data alphabet get target alphabet alphabets match alphabet carrying alphabet oas = get alphabets oas length == 2 oas 0 equals get data alphabet oas 1 equals get target alphabet set data alphabet alphabet d dict data alphabet != data alphabet size > 0 illegal state can t set pipe s data alphabet it already has one data alphabet = d dict data alphabet set data alphabet != data alphabet size > 0 set or check data alphabet alphabet a data alphabet == data alphabet = a ! data alphabet equals a illegal state data alphabets not match set target alphabet alphabet t dict target alphabet != illegal state can t set pipe s target alphabet it already has one target alphabet = t dict set or check target alphabet alphabet a target alphabet == target alphabet = a ! target alphabet equals a illegal state target alphabets not match preceeding pipe data alphabet notification alphabet a data alphabet == data alphabet = a preceeding pipe target alphabet notification alphabet a target alphabet == target alphabet = a v m get instance instance debugging instance iterator used to implement one to one pipe behavior simple pipe instance iterator iterator< instance> iterator< instance> source simple pipe instance iterator iterator< instance> source source = source has next source has next instance next instance input = source next !precondition input input pipe input link pipe that processes link instance s going through iterator pipe get pipe iterator< instance> get source iterator source remove illegal state not supported serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write data alphabet out write target alphabet out write data alphabet resolved out write target alphabet resolved out write target processing out write instance read input stream in i o not found = in read data alphabet = alphabet in read target alphabet = alphabet in read data alphabet resolved = in read target alphabet resolved = in read target processing = in read instance = v m in read concurrent map< v m object> deserialized entries = concurrent hash map< v m object> gets called after read it lets decide whether to itself or a previously read in we use a hash map instance ids to determine we have already read in stream read resolve stream out pipe read resolve instance id= + instance previous = deserialized entries get instance previous != out pipe read resolve resolving to previous instance instance id= + instance previous instance != prev = deserialized entries put absent instance prev != prev out pipe read resolve instance instance id= + instance 