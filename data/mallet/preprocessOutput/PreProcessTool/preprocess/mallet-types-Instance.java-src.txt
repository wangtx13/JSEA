2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e types logging io pipe pipe types labeling logger property list a example to be used in training testing or performance various algorithms <p> an instance contains four generic fields predefined name data target name and source data holds data represented `by instance target often a label associated instance name a identifying name instance such a filename and source human readable sourceinformation such original text <p> each field has no predefined type and may change type instance processed example data field may start off being a that represents a name and then be processed a link pipe pipe into a sequence representing contents and eventually to a feature vector holding indices into an link types alphabet holding words found in it up to each pipe which fields in instance it modifies most that pipe modifies data field <p> generally speaking there are two modes operation instances 1 an instance gets created and passed through a pipe and resulting data target name source fields are used generally done training instances 2 an instance gets created raw values in its slots then different users instance call piped copy their respective different pipes might be done test instances at performance time <p> rather than store an link types alphabet in instance we obtain it through pipe instance variable because pipe also indicates where data came from and how to interpret alphabet <p> instances can be made immutable locked although unlocked instances are mutable typically only that changes values in four slots inside pipes <p> note that constructing an instance a pipe argument means construct instance and then run it through pipe link types instance list uses when adding instances through a pipe input iterator pipe alphabet instance list author andrew mc callum <a href= mailto >mccallum edu< a> instance serializable alphabet carrying cloneable logger logger = logger get logger instance get name data input data in digested form e g a feature vector target output data in digested form e g a label name a readable name source e g m l analysis source input in a reproducable form e g enabling re print w p o s tags usually without target e g an un annotated region list property list properties = locked = in certain unusual circumstances you might want to create an instance without sending it through a pipe instance data target name source data = data target = target name = name source = source get data data get target target get name name get source source alphabet get data alphabet data alphabet carrying alphabet carrying data get alphabet alphabet get target alphabet target alphabet carrying alphabet carrying target get alphabet alphabet get alphabet get data alphabet alphabet get alphabets alphabet get data alphabet get target alphabet alphabets match alphabet carrying alphabet oas = get alphabets oas length == 2 oas 0 equals get data alphabet oas 1 equals get data alphabet locked locked lock locked = un lock locked = labeling get labeling target == || target labeling labeling target illegal state target not a labeling it a +target get get name set data d !locked data = d illegal state instance locked set target t !locked target = t illegal state instance locked set labeling labeling l test isn t strictly necessary but might some typos target == || target labeling !locked target = l illegal state instance locked set name n !locked name = n illegal state instance locked set source s !locked source = s illegal state instance locked clear source source = instance shallow copy instance ret = instance data target name source ret locked = locked ret properties = properties ret clone shallow copy setting and getting properties set property key value properties = property list add key value properties set numeric property key value properties = property list add key value properties deprecated property list get properties properties deprecated set property list property list p !locked properties = p illegal state instance locked get property key properties == ? properties lookup key get numeric property key properties == ? 0 0 properties lookup number key has property key properties == ? properties has property key serialization instance serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write data out write target out write name out write source out write properties out write locked read input stream in i o not found = in read data = in read target = in read name = in read source = in read properties = property list in read locked = in read 