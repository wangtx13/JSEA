2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> io i o io input stream io output stream io serializable list iterator logging logger types instance types instance list types sequence types sequence pair alignment pipe pipe logger sequences a base all sequence models analogous to link classify classifier transducer serializable variable name key ip = input position op = output position logger logger = logger get logger transducer get name z e r o o s t = 0 i n f i n i t e o s t = p o s i t i v e i n f i n i t y e r t a i n w e i g h t = p o s i t i v e i n f i n i t y t o d o remove because it should never be used results in na n s i m p o s s i b l e w e i g h t = n e g a t i v e i n f i n i t y a factory instance from which we can ask a sum lattice sum lattice factory sum lattice factory a factory instance from which we can ask a max lattice max lattice factory max lattice factory a pipe that should produce a sequence in data slot and possibly one in target slot also pipe input pipe a pipe that should expect transducer s output sequence in target slot and should produce something printable in source slot that indicates results transduction pipe output pipe initializes sum product and max product inference engines transducer sum lattice factory = sum lattice factory max lattice factory = max lattice factory transducer pipe input pipe pipe output pipe input pipe = input pipe output pipe = output pipe pipe get input pipe input pipe pipe get output pipe output pipe set sum lattice factory sum lattice factory fbf sum lattice factory = fbf set max lattice factory max lattice factory vf max lattice factory = vf sum lattice factory get sum lattice factory sum lattice factory max lattice factory get max lattice factory max lattice factory take input sequence from instance data and put output sequence in instance target like transduce instance but put best output sequence into instance target rather than instance data t o d o consider a different name instance label instance instance input pipe != instance = input pipe instance from instance t o d o use max lattice factory instead hardcoding instance set target max lattice sequence instance get data best output sequence output pipe != instance = output pipe instance from instance instance take input sequence from instance data and put output sequence in instance data instance transduce instance instance input pipe != instance = input pipe instance from instance t o d o use max lattice factory instead hardcoding instance set data max lattice sequence instance get data best output sequence output pipe != instance = output pipe instance from instance instance converts given sequence into another sequence according to transducer exmaple probabilistic transducer may something like viterbi here subclasses transducer may specify that they only accept special kinds sequence input input sequence sequence output transudcer sequence transduce sequence input max lattice factory max lattice sequence input best output sequence num states state get state index note that allowed to states impossible infinity initial weights iterator initial state iterator some transducers are generative meaning that you can get a sequence out them without giving them an input sequence in state transition iterator should all available transitions but attempts to obtain input and weight fields may an t o d o why could obtaining weight be a problem??? can iterate all transitions a generative transducer in state transition iterator should transitions that have valid input and cost fields here should imply that can iterate all transitions generative runs inference across all instances and average token accuracy average token accuracy instance list ilist accuracy = 0 i = 0 i < ilist size i++ instance instance = ilist get i sequence input = sequence instance get data sequence output = sequence instance get target input size == output size sequence predicted = max lattice factory max lattice input best output sequence path accuracy = sequences elementwise accuracy output predicted accuracy += path accuracy logger fine transducer path accuracy = +path accuracy accuracy ilist size treat costs they are log probabilies we will normalize them necessary sequence pair alignment generate path generative == illegal state transducer not generative list initial states = list iterator iter = initial state iterator iter has next initial states add iter next xxx not yet finished unsupported operation index input state name 1 name not found state index s i = 0 i < num states i++ state = get state i get name state equals s i 1 print states i = 0 i < num states i++ logger fine i + + get state i get name print logger fine transducer +this print states serialization transducer serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 gsc fixed serialization writing reading lattice factory write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write input pipe out write output pipe out write sum lattice factory out write max lattice factory read input stream in i o not found = in read input pipe = pipe in read output pipe = pipe in read sum lattice factory = sum lattice factory in read max lattice factory = max lattice factory in read an used to represent states transducer state serializable get name get index get initial weight set initial weight get weight set weight transducer get transducer pass negative positions a sequence to request epsilon transitions either input or output position 1 should be position in sequence after which we are trying to insert espilon transition transition iterator transition iterator sequence input input position sequence output output position pass negative input position a sequence to request epsilon transitions position 1 should be position in sequence after which we are trying to insert espilon transition transition iterator transition iterator sequence input input position transition iterator input input position 0 generative transducers all possible transitions independent input transition iterator transition iterator transition iterator 0 0 serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n read input stream in i o not found = in read to be called inference to indicate partial counts sufficient statistics that how much probability mass falling on a transition or in an initial state or a state incrementor increment transition transition iterator ti count increment initial state state s count increment state state s count an to iterate over states transducer transition iterator iterator< state> serializable has next deprecated what for? i ve forgotten akm 11 2007 number next 1 deprecated state next state destination state state next next state remove unsupported operation an specific index transition can be used to index into arrays per transition get index input symbol or appearing on transition get input output symbol or appearing on transition get output weight between infinity and infinity associated taking transition input output get weight state we were in before taking transition state get source state state we are in after taking transition state get destination state number input positions that transition consumes allows transition that consume variable amounts sequences get input position increment 1 number output positions that transition produces allows transition that consume variable amounts sequences get output position increment 1 transducer get transducer get source state get transducer i hate that i need there s really no other way cas describe transition cutoff serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n read input stream in i o not found suppress warnings unused = in read sum log prob we need to be able to sum probabilities that are represented weights which are log probabilities naively we would just convert them into probabilities sum them and then convert them back into weights would be sum log prob a b math log math exp a + math exp b but would fail when a or b too negative would have resolution to represent weight but not resolution to represent intermediate exponentiated weights and we would get infinity our answer what we want a getting sum exponentiating a number that not too large we can following starting equation above then sum prob = log exp a + exp b exp sum prob = exp a + exp b exp sum prob exp a = 1 + exp b exp a exp sum prob a = 1 + exp b a sum prob a = log 1 + exp b a sum prob = a + log 1 + exp b a we want to make sure that b a negative or a small positive number we can assure noticing that we could have equivalently derived sum prob = b + log 1 + exp a b and we can simply select among two alternative equations one that would have smallest or most negative exponent no longer needed sum neg log prob a b a == p o s i t i v e i n f i n i t y b == p o s i t i v e i n f i n i t y p o s i t i v e i n f i n i t y a > b b math log 1 + math exp b a a math log 1 + math exp a b <tt> math log math exp a + math exp b < tt> <p> <tt>a b< tt> represent weights sum log prob a b a == n e g a t i v e i n f i n i t y b == n e g a t i v e i n f i n i t y n e g a t i v e i n f i n i t y b b == n e g a t i v e i n f i n i t y a a > b a + math log 1 + math exp b a b + math log 1 + math exp a b less efficient sum log prob a b a == n e g a t i v e i n f i n i t y b == n e g a t i v e i n f i n i t y n e g a t i v e i n f i n i t y a > b a + math log 1 + math exp b a b + math log 1 + math exp a b 