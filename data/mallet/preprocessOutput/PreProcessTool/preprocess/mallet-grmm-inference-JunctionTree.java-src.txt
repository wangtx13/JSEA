2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e inference set hash set iterator collection list arrays types gnu trove t hash map gnu trove t hash set gnu trove t iterator datastructure a junction tree created tue sep 30 10 30 25 2003 author <a href= mailto casutton > charles sutton< a> $ junction tree v 1 1 2007 10 22 21 37 49 exp $ junction tree tree num nodes sepset sepset set s factor p set = s ptl = p set set factor ptl t hash map sepsets factor cpfs junction tree size num nodes = size sepsets = t hash map cpfs = factor size junction tree constructor add node parent1 child1 add node parent1 child1 var set parent = var set parent1 var set child = var set child1 set sepset = parent intersection child id1 = lookup index parent id2 = lookup index child put sepset id1 id2 sepset sepset sepset ptl sepset factor sepset ptl set sepset sepset empty use identity factor constant factor make identity factor table factor sepset hash idx idx id1 id2 id1 < 65536 id2 < 65536 id1 < id2 = id1 << 16 | id2 = id2 << 16 | id1 put sepset id1 id2 sepset sepset = hash idx idx id1 id2 sepsets put sepset sepset get sepset id1 id2 = hash idx idx id1 id2 sepset sepsets get p f accessors factor get p f var set cpfs lookup index set p f var set factor pot cpfs lookup index = pot clear p fs i = 0 i < cpfs length i++ cpfs i = table factor var set lookup vertex i t iterator it = sepsets iterator it has next it advance sepset sepset = sepset it value sepset ptl = sepset ptl sepset set set sepset potentials t hash set set = t hash set t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl set add ptl set set sepset pot factor pot var set v1 var set v2 id1 = lookup index v1 id2 = lookup index v2 get sepset id1 id2 ptl = pot factor get sepset pot var set v1 var set v2 id1 = lookup index v1 id2 = lookup index v2 get sepset id1 id2 ptl a collection all potentials cliques in junction tree i e these are in numerator jounction tre theorem #sepset potentials collection cluster potentials hash set h = hash set i = 0 i < cpfs length i++ cpfs i != h add cpfs i h set get sepset var set v1 var set v2 id1 = lookup index v1 id2 = lookup index v2 get sepset id1 id2 set factor lookup marginal variable var var set = find parent cluster var factor pot = get p f pot marginalize var lookup log joint assignment assn accum = 0 i = 0 i < cpfs length i++ cpfs i != phi = cpfs i log value assn accum += phi t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl phi = ptl log value assn accum = phi accum a cluster in tree that contains var var set find parent cluster variable var best = m a x v a l u e var set retval = xxx inefficient iterator it = get vertices iterator it has next var set = var set it next contains var weight < best retval = best = weight retval a cluster in tree that contains all vars in a collection var set find parent cluster collection vars best = m a x v a l u e var set retval = xxx inefficient iterator it = get vertices iterator it has next var set = var set it next contains all vars weight < best retval = best = weight retval a cluster in tree that contains exactly given variables or no such cluster var set find cluster variable vars list l = arrays list vars iterator it = get vertices iterator it has next var set c2 = var set it next c2 contains all l l contains all c2 c2 normalizes all potentials in tree both node and sepset normalize all n = cpfs length i = 0 i < n i++ cpfs i != cpfs i normalize t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl ptl normalize get var set lookup index debugging functions dump n = cpfs length will cause open j graph to print all our nodes and edges out dump to now lets print all cpfs out vertex p fs i = 0 i < n i++ cpfs i != out p f +i+ +cpfs i dump to and sepset potentials out sepset p fs t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl out ptl dump to out end j t dump log joint assignment assn accum = 0 i = 0 i < cpfs length i++ cpfs i != phi = cpfs i log value assn out p f +i+ accum = +accum t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl phi = ptl log value assn out sepset +ptl var set + accum +accum accum na n n = cpfs length i = 0 i < n i++ cpfs i na n and sepset potentials t iterator it = sepsets iterator it has next it advance factor ptl = sepset it value ptl ptl na n entropy entropy = 0 iterator it = cluster potentials iterator it has next factor ptl = factor it next entropy += ptl entropy iterator it = sepset potentials iterator it has next factor ptl = factor it next entropy = ptl entropy entropy users casutton graphical compactible decompact cpfs = factor num nodes clear p fs compact cpfs = junction tree 