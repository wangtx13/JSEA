2008 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised hash map iterator linked hash set types alphabet maps states in lattice to labels <p> when a custom state constructed training a r f it possible that several states map to same label in there will be a discrepancy between number states used in lattice and number output labels targets use mapping such an f s t used in training a r f model <p> number states in lattice expected to be equal to number output labels then set <tt>is one to one map< tt> to <tt>true< tt> in constructor <p> map associates state appropriate label indexing zero onwards <p> <b> note < b> add states to map in same order in which they are added to r f constructing f s t necessary to keep a correct mapping state indices in map to state indices used within r f author gaurav chandalia state label map s t a r t l a b e l = 2 mapping labels to integers alphabet state alphabet mapping state names to integers alphabet label alphabet a standard f s t used using one in r f in state and label alphabets are same one to one map key index identifying a state value index identifying a label that state maps to in state hash map< integer> state to label key index identifying a label value indices states that are associated label hash map< linked hash set< integer>> label to state state label map alphabet label alphabet one to one map label alphabet one to one map 1 initializes state and label maps <b> note < b> a standard f s t used using one in r f state and label alphabets are same in there will be a one to one mapping between states and labels also <tt>add states< tt> can no longer be used done when <tt>is one to one map< tt> <tt>true< tt> label alphabet target alphabet that maps label names to integers one to one map a one to one mapping states and labels to be created ignoring start label start state index index special s t a r t state or 1 state label map alphabet label alphabet one to one map start state index label alphabet = label alphabet one to one map = one to one map state to label = hash map< integer> label to state = hash map< linked hash set< integer>> one to one map use same alphabet state and label state alphabet = label alphabet alpha count = label alphabet size i = 0 i < alpha count i++ label = label alphabet lookup i label index = label alphabet lookup index label state to label put label index label index linked hash set< integer> state indices = linked hash set< integer> state indices add label index label to state put label index state indices state alphabet = alphabet alpha count = label alphabet size i = 0 i < alpha count i++ label = label alphabet lookup i label to state put label alphabet lookup index label linked hash set< integer> start state index != 1 add start state start state index there a special start state in r f that not in label set then we need to add it here constraints can then check a state maps to special s t a r t l a b e l and handle appropriately index index special start state in r f add start state index state to label put index s t a r t l a b e l <tt>true< tt> there a one to one mapping between states and labels and <tt>false< tt> otherwise one to one mapping one to one map number labels in map get num labels label to state size number states in map get num states state to label size label target alphabet alphabet get label alphabet label alphabet state alphabet alphabet get state alphabet state alphabet label index mapped to state index state index state index index label that mapped to state <tt> 1< tt> there no label index that maps to specified state get label index state index since no values are allowed in our map directly use get label index = state to label get state index label index == 1 label index state indices that map to label index label index label target index indices states that map to label <tt>null< tt> there are no states that map to label linked hash set< integer> get state indices label index label to state get label index adds a state to map state name name state label name label target name which state associated index associated state that was added illegal argument an invalid label name or a duplicate state name illegal state called when there a one to one mapping between states and labels add state state name label name one to one map illegal state trying to add a state when there a + one to one mapping between states + and labels get label index label index = label alphabet lookup index label name label index == 1 illegal argument invalid label + label name add state and get its index state index = state alphabet lookup index state name state index != 1 illegal argument duplicate state + state name state index = state alphabet lookup index state name add indices to label state and state label maps label to state get label index add state index pointer npe it possible that a label never seen in training data in that number labels will not be equal to size label target alphabet until state unseen label added to label alphabet constructing f s t add such a label here linked hash set< integer> state indices = linked hash set< integer> state indices add state index label to state put label index state indices state to label put state index label index state index 