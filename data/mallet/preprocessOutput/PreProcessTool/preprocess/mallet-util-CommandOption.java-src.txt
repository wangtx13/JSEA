2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> io reflect invocation target reflect bsh interpreter command option bsh interpreter interpreter maps a to command option that are owned it hash map class2options = hash map owner name argument eg input name display name argument type eg t r u e| f a l s e or f i l e name type argument present type required shortdoc longdoc full name did command option get processed or we just have value invoked = command option owner name name type required shortdoc longdoc owner = owner name = name name = name type = type required = required shortdoc = shortdoc longdoc = longdoc p = owner get full name = p != ? p to + name interpreter == interpreter = bsh interpreter owner != command option command option list options = command option list class2options get owner options == options = command option list class2options put owner options options add deprecated command option owner name name type required shortdoc owner name name type required shortdoc give command option opportunity to process index th argument in next unprocessed index process index out name + processing + index length == 0 index out index + + index there anything to process? index >= length || index == || index length < 2 || index at 0 != || index at 1 != index determine what command name opt full name = index substring 2 dot index = opt full name last index opt name = opt full name commands may have a prefix dot index != 1 opt name = opt full name substring 0 dot index owner get != ! owner get to ends opt name index opt name = opt full name substring dot index+1 does option name match name command option? ! name equals opt name index we have now determined that command option correct one invoked = index++ length > index index length < 2 || index at 0 != index at 1 != index = parse index required illegal argument missing argument option + opt name xxx not parallel behavior to above parse parse index xxx was index++ index bsh interpreter get interpreter interpreter process owner command option list options = command option list class2options get owner options == illegal argument no command options registered +owner options process list get list owner command option list options = command option list class2options get owner options == illegal argument no command options registered +owner options set summary owner summary command option list options = command option list class2options get owner options == illegal argument no command option list registered +owner options set summary summary get full name full name get name name value to value to command option was matched one processed arguments was invoked invoked called after command option matches an argument simply calls parse and index+1 unless index negative in which it calls parse and index parse index index < 0 parse index parse index index+1 parse to be overridden subclasses list command option list that called option post parsing command option list list that can provide command option list s which can be merged into other lists list providing command option list get command option list print option values owner command option list options = command option list class2options get owner i=0 i < options size i++ command option option = options get command option i out option get name + = + option value to list list options hash map map summary list summary options = list map = hash map summary = summary add command option help t r u e| f a l s e print command line option usage + give argument t r u e longer documentation post parsing command option list list print usage value exit 1 add command option prefix j a v a o d e you want run before any other interpreted note that text + interpreted without modification so unlike some other options + you need to include any necessary s when creating add command option config f i l e read command option values from a post parsing command option list list read from value list summary command option options summary add options set summary s summary = s size options size command option get command option index command option options get index add command option opt options add opt map put opt get full name opt add command option opts i = 0 i < opts length i++ add opts i add command option list opts i = 0 i < opts size i++ add opts get command option i add owner command option list options = command option list class2options get owner options == illegal argument no command options registered +owner add options load configuration from a filename ends xml interpreted a xml configuration otherwise it interpreted a text config eg key = value on each line note that text files can only use latin 1 en us characters xml files can be u t f 8 read from io configuration properties properties = properties configuration get name ends xml properties load from xml input stream configuration properties load input stream configuration enumeration keys = properties property names keys has more elements key = keys next element values = properties get property key split \\s+ found value = i = 0 i < options size i++ command option option = command option options get i option name equals key found value = option parse values 0 option invoked = e err unable to process configuration + e get message parse and process command line options in sub occurring after first non recognized that doesn t begin a dash process index = 0 index < length index = index i = 0 i < options size i++ command option o = command option options get i index = o process index index != index o post parsing index == index all command options had their chance to claim index th option but none them did print usage illegal argument unrecognized option + index + +args index index = index 0 process options index = 0 index < length index = index i = 0 i < options size i++ command option o = command option options get i index = o process index index != index o post parsing index == index index < length index length > 1 index at 0 == index at 1 == print usage illegal argument unrecognized option +args index index index = index length print usage print doc xxx fix to have nicer formatting later err summary i = 0 i < options size i++ command option o = command option options get i err + o name + + o name + + o shortdoc o longdoc != print doc err +o longdoc err +o value to log options logging logger logger i = 0 i < options size i++ command option o = command option options get i logger info o name+ = +o value to command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse == || equals ignore || equals 1 value = equals ignore || equals 0 value = illegal argument option should be true|false|0|1 instead found +arg value to to value value to to value command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse value = parse value to to value value to to value command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse elts = split value = elts length i = 0 i < elts length i++ value i = parse elts i value to buffer b = buffer sep = i = 0 i < value length i++ b append sep append to value i sep = b to value to buffer b = buffer sep = i = 0 i < value length i++ b append sep append to value i sep = b to command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse value = parse value to to value value to to value command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse elts = split value = elts length i = 0 i < elts length i++ value i = parse elts i value to buffer b = buffer sep = i = 0 i < value length i++ b append sep append to value i sep = b to value to buffer b = buffer sep = i = 0 i < value length i++ b append sep append to value i sep = b to command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse value = value to value value to value spaced strings command option value value spaced strings owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse index count = 0 value = index < length index length < 2 || index at 0 != index at 1 != count++ old value = value value = count old value != arraycopy old value 0 value 0 old value length value count 1 = index index++ index value to value == buffer sb = buffer i = 0 i < value length i++ sb append value i i < value length 1 sb append sb to value to value == val = i = 0 i < value length i++ val += value i + val command option io value value owner name name required io value shortdoc longdoc owner name name io required shortdoc longdoc value = value = value io value value parse value = io value to value == ? value to value to value == ? value to value a that can take on only a limited set values set command option value value set contents contents set owner name name required set contents index shortdoc longdoc owner name name io required shortdoc longdoc value = value = set contents index set contents = set contents buffer sb = buffer i = 0 i < set contents length i++ sb append set contents i sb append contents = sb to value value parse value = i = 0 i < set contents length i++ set contents i equals value = set contents i value == illegal argument unrecognized option argument \ +arg+ \ not in set +contents value to value value to value command option value value owner name name required value shortdoc longdoc owner name name required shortdoc longdoc value = value = value value value parse value = interpreter eval bsh eval e illegal argument interpreter eval +e value to value == ? value to value to value == ? value to from bean from bean owner name name required def value shortdoc longdoc owner name name required shortdoc longdoc value = value = def value value value parse parse something like max ent trainer gaussian prior variance=10 num iterations=20 out = + first split argument at commas fields = split massage constructor name so that max ent max ent trainer max ent trainer all call max ent trainer constructor name = fields 0 constructor name contains || constructor name contains contains or a pass it though parse parse + constructor name + use constructor to make call appropriate set that appeared comma separated find associated we just built = value get get find setters corresponding to parameter names i=1 i<fields length i++ name value pair = fields i split = parameter name = name value pair 0 parameter value = name value pair 1 todo check val present! parameter value parameter value = get interpreter eval parameter value bsh eval e illegal argument interpreter eval on parameter + parameter name + +e found setter = j=0 j<methods length j++ out + j + name + j get name out set + character to upper parameter name at 0 + parameter name substring 1 set + character to upper parameter name at 0 + parameter name substring 1 equals j get name j get parameter types length == 1 out matched + j get name ptypes = j get parameter types out parameter types k=0 k<ptypes length k++ out + k + = + ptypes k get name parameter list = parameter value out argument types k=0 k<parameter list length k++ out + k + = + parameter list k get get name j value parameter list illegal access e out illegal access + e illegal argument access calling setter +e invocation target e out illegal target + e illegal argument target calling setter +e found setter = !found setter out parameter + parameter name + not found on trainer + constructor name out available + constructor name j=0 j<methods length j++ j get name starts set j get parameter types length == 1 out character to lower j get name at 3 + j get name substring 4 illegal argument no setter found parameter + parameter name value to value == ? value to value to value == ? value to 