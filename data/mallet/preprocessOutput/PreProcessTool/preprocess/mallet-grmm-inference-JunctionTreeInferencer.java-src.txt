2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e inference 3pq jgrapht graph helper 3pq jgrapht undirected graph 3pq jgrapht alg connectivity inspector 3pq jgrapht graph simple graph 3pq jgrapht graph listenable undirected graph 3pq jgrapht traverse breadth first iterator types graphs types alphabet logger io i o io input stream io output stream logging level logging logger does inference in general graphical models using hugin junction tree algorithm created mon nov 10 23 58 44 2003 author <a href= mailto casutton > charles sutton< a> $ junction tree inferencer v 1 1 2007 10 22 21 37 49 exp $ junction tree inferencer inferencer logger logger = logger get logger junction tree inferencer get name in log space junction tree propagation propagator junction tree inferencer junction tree propagation create sum product inferencer junction tree inferencer constructor junction tree inferencer junction tree propagation propagator propagator = propagator junction tree inferencer create max product junction tree inferencer junction tree propagation create max product inferencer adjacent undirected graph g variable v1 variable v2 g get edge v1 v2 != junction tree jt current list cliques number edges that would be added to a graph a given vertex would be removed in triangulation procedure value number edges in elimination clique v that are not already present edges required undirected graph mdl variable v rating = 0 iterator it1 = neighbors iterator mdl v it1 has next variable neighbor1 = variable it1 next iterator it2 = neighbors iterator mdl v it2 has next variable neighbor2 = variable it2 next neighbor1 != neighbor2 !is adjacent mdl neighbor1 neighbor2 rating++ out v+ = +rating rating weight clique that would be added to a graph a given vertex would be removed in triangulation procedure value number edges in elimination clique v that are not already present weight required undirected graph mdl variable v rating = 1 iterator it1 = neighbors iterator mdl v it1 has next variable neighbor = variable it1 next rating = neighbor get num outcomes out v+ = +rating rating connect neighbors undirected graph mdl variable v iterator it1 = neighbors iterator mdl v it1 has next variable neighbor1 = variable it1 next iterator it2 = neighbors iterator mdl v it2 has next variable neighbor2 = variable it2 next neighbor1 != neighbor2 !is adjacent mdl neighbor1 neighbor2 mdl add edge neighbor1 neighbor2 e runtime e xx should refactor into collections any coll t proc iff a clique in l strictly contains find clique list l var set iterator it = l iterator it has next var set c2 = var set it next c2 contains all works like obscure <=> operator in perl cmp i1 i2 i1 < i2 1 i1 > i2 1 0 variable pick vertex to remove undirected graph mdl list lst iterator it = lst iterator variable best = variable it next best val1 = edges required mdl best best val2 = weight required mdl best it has next variable v = variable it next val = edges required mdl v val < best val1 best = v best val1 = val best val2 = weight required mdl v val == best val1 val2 = weight required mdl v val2 < best val2 best = v best val1 = val best val2 = val2 best adds edges to graph until it triangulated triangulate undirected graph mdl undirected graph mdl2 = dup graph mdl list vars = list mdl vertex set alphabet var map = make vertex map vars cliques = list debug logger loggable level f i n e r logger finer triangulating model +mdl ret = i = 0 i < vars size i++ variable next = variable vars get i ret += next to + + mdl get index next + logger finer ret !vars empty variable v = variable pick vertex to remove mdl2 vars logger finer triangulating vertex + v var set var set = bit var set v get universe graph helper neighbor list mdl2 v var set add v !find clique cliques var set cliques add var set logger loggable level f i n e r logger finer elim clique + var set + size + var set size + weight + var set weight must remove v from graph first because adding edges will change rating other vertices connect neighbors mdl2 v vars remove v mdl2 remove vertex v logger loggable level f i n e logger fine triangulation done cliques are tot size = 0 tot weight = 0 max size = 0 max weight = 0 iterator it = cliques iterator it has next var set = var set it next logger finer to tot size += size max size = math max size max size tot weight += weight max weight = math max weight max weight sz = cliques size logger fine jt created + sz + cliques size avg + tot size sz + max + max size + weight avg + tot weight sz + max + max weight alphabet make vertex map list vars alphabet map = alphabet vars size variable map lookup indices vars to map sepset size bit var set pair pair length == 2 pair 0 intersection size pair 1 sepset cost var set pair pair length == 2 pair 0 weight + pair 1 weight given two pairs cliques 1 pair o1 should be added to tree first we add pairs that have largest mass number vertices in to ensure that clique tree satifies running intersection property comparator sepset chooser = comparator compare o1 o2 o1 == o2 0 bit var set pair1 = bit var set o1 bit var set pair2 = bit var set o2 size1 = sepset size pair1 size2 = sepset size pair2 retval = cmp size1 size2 retval == 0 ties adding sepset smallest cost sum weights connected clusters cost1 = sepset cost pair1 cost2 = sepset cost pair2 retval = cmp cost1 cost2 still a tie? arbitrarily but consistently retval == 0 retval = cmp o1 hash o2 hash retval junction tree graph to jt undirected graph g junction tree jt = junction tree g vertex set size root = g vertex set iterator next jt add root iterator it1 = breadth first iterator g root it1 has next v1 = it1 next iterator it2 = graph helper neighbor list g v1 iterator it2 has next v2 = it2 next jt get parent v1 != v2 jt add node v1 v2 jt junction tree build jt structure tree set pq = tree set sepset chooser initialize pq all possible edges iterator it = cliques iterator it has next bit var set c1 = bit var set it next iterator it2 = cliques iterator it2 has next bit var set c2 = bit var set it2 next c1 == c2 pq add bit var set c1 c2 and add edges to jt that come to top queue and t cause a cycle xxx o k sucks openjgraph doesn t allow adding disconnected edges to a tree so what we ll create a graph frist then convert it to a tree listenable undirected graph g = listenable undirected graph simple graph first add every clique to graph iterator it = cliques iterator it has next var set = var set it next g add vertex connectivity inspector inspector = connectivity inspector g g add graph listener inspector then add n 1 edges num cliques = cliques size edges added = 0 edges added < num cliques 1 var set pair = var set pq first pq remove pair !inspector path pair 0 pair 1 g add edge pair 0 pair 1 edges added++ junction tree jt = graph to jt g logger loggable level f i n e r logger finer jt structure was + jt jt init jt cpts factor graph mdl junction tree jt iterator it = jt get vertices iterator it has next var set = var set it next discrete factor ptl = create blank factor jt set p f ptl jt set p f constant factor 1 0 iterator it = mdl factors iterator it has next factor ptl = factor it next var set parent = jt find parent cluster ptl var set parent != unable to find parent cluster ptl + ptl + in jt + jt factor cpf = jt get p f parent factor cpf = cpf multiply ptl jt set p f parent cpf debug jt na n runtime got a na n table factor create blank factor var set in log space log table factor table factor compute marginals factor graph mdl in log space = mdl get factor 0 log table factor build junction tree mdl propagator compute marginals jt current total messages sent += propagator get total messages sent compute marginals junction tree jt in log space = ?? jt current = jt propagator compute marginals jt current total messages sent += propagator get total messages sent constructs a junction tree from a given factor graph does not perform b p in resulting graph so gives you structure a jnuction tree but factors t correspond to marginals unless you call b p yourself mdl factor graph to compute j t junction tree build junction tree factor graph mdl jt current = junction tree mdl get inference cache junction tree inferencer jt current != jt current clear p fs graph g topology m r f that corresponds to factor graph mdl essentially means that we triangulate factor graphs converting to an m r f first i could have chosen to trianglualte factor graph directly but i didn t historical reasons i already had a triangulate m r fs not bipartite factor graphs note that call to mdl to graph perfectly valid factor graphs that are also directed models and has effect moralizing in that undirected graph g = graphs mdl to graph mdl triangulate g jt current = build jt structure mdl set inference cache junction tree inferencer jt current init jt cpts mdl jt current jt current undirected graph dup graph undirected graph original undirected graph copy = simple graph graph helper add graph copy original copy factor lookup marginal variable var propagator lookup marginal jt current var factor lookup marginal var set var set propagator lookup marginal jt current var set lookup log joint assignment assn jt current lookup log joint assn dump log joint assignment assn jt current dump log joint assn junction tree computed from last call to link #compute marginals caller must not modify value junction tree lookup junction tree jt current iterator neighbors iterator undirected graph g variable v graph helper neighbor list g v iterator dump jt current != out current junction tree jt current dump out n o current junction tree total messages sent = 0 total number messages inferencer has sent get total messages sent total messages sent serialization serial u = 1 seralization incompatible changes are made to these classes then smarts can be added to these backward compatibility write output stream out i o out write read input stream in i o not found in read junction tree inferencer 