2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e create features from features matching a regex within a window + current position example <br><code> features in window p = features in window p r e v 1 1 pattern compile p o s < code> <br> will create a pipe that adds a feature to current position each feature in previous starting p o s so previous position has p o s n n we add p r e v p o s n n last argument to constructor currently ignored alternative constructor matches all patterns so <br><code> features in window p = features in window s l r < code> <br> equivalent to <br><code> features in window p = features in window p r e v 1 1 pattern compile < code> <br> but more efficient since we t actually check using pattern author andrew mc callum <a href= mailto >mccallum edu< a> pipe tsf io regex pipe pipe types instance types token types token sequence property list features in window pipe serializable name prefix name prefix left left boundary right boundary pattern feature regex include begin end boundaries include current token = max window size = 20 property list startfs = property list max window size property list endfs = property list max window size init start end fs init start end fs i = 0 i < max window size i++ startfs i = property list add < s t a r t +i+ > 1 0 endfs i = property list add < e n d +i+ > 1 0 name prefix what to prepend to feature names left boundary offset left boundary window e g 1 means include previous word right boundary offset right boundary window e g 1 means include current position but not next feature regex add only features matching = always match include begin end boundaries ignored features in window name prefix left boundary offset right boundary offset pattern feature regex include begin end boundaries name prefix = name prefix left boundary = left boundary offset right boundary = right boundary offset feature regex = feature regex include begin end boundaries = include begin end boundaries equivalent to <br> <code> features in window name prefix left boundary offset right boundary offset < code> features in window name prefix left boundary offset right boundary offset name prefix left boundary offset right boundary offset instance pipe instance carrier token sequence ts = token sequence carrier get data ts size = ts size property list features = property list ts size i = 0 i < ts size i++ token t = ts get i property list pl = t get features features i = pl position = i + left boundary position < i + right boundary position++ position == i !include current token property list pl2 position < 0 pl2 = startfs position position >= ts size pl2 = endfs position ts size pl2 = ts get position get features property list iterator pl2i = pl2 iterator pl2i has next pl2i next key = pl2i get key feature regex == || feature regex matcher key matches features i = property list add name prefix left == || position i>0 ? name prefix name prefix left +key pl2i get numeric value features i i = 0 i < ts size i++ put property lists in place ts get i set features features i carrier serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write name prefix out write left boundary out write right boundary out write feature regex out write include begin end boundaries read input stream in i o not found = in read name prefix = in read left boundary = in read right boundary = in read feature regex = pattern in read include begin end boundaries = in read 