2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e create features from all possible conjunctions other possibly position offset features author andrew mc callum <a href= mailto >mccallum edu< a> pipe tsf io regex pipe pipe types instance types token types token sequence property list offset conjunctions pipe serializable conjunctions include original singletons include begin end boundaries pattern feature regex max window size = 50 property list startfs = property list max window size property list endfs = property list max window size init start end fs init start end fs i = 0 i < max window size i++ startfs i = property list add < s t a r t +i+ > 1 0 endfs i = property list add < e n d +i+ > 1 0 to include all old previous singleton features pass 0 a conjunction at current time step pass 0 0 a conjunction current and previous pass 0 1 a conjunction current and next two pass 0 1 2 offset conjunctions include original singletons pattern feature regex conjunctions conjunctions = conjunctions feature regex = feature regex include original singletons = include original singletons offset conjunctions include original singletons conjunctions include original singletons conjunctions offset conjunctions conjunctions conjunctions instance pipe instance carrier token sequence ts = token sequence carrier get data ts size = ts size property list oldfs = property list newfs = oldfs = property list ts size e err allocating oldfs + e newfs = property list ts size e err allocating newfs + e i = 0 i < ts size i++ oldfs i = ts get i get features include original singletons i = 0 i < ts size i++ newfs i = ts get i get features i = 0 i < ts size i++ j = 0 j < conjunctions length j++ allow conjunction offsets length n awc property list iterator iters = get offset iters conjunctions j ts size i oldfs iters == iter indices = iters length ii=0 ii < iter indices length ii++ iter indices ii = 1 newfs i = make conjunctions iters 0 conjunctions j ts size newfs i i oldfs iter indices put property lists in place i = 0 i < ts size i++ ts get i set features newfs i carrier recursively makes conjunctions iterating through features at each offset iters iterate over property lists at each offset curr index which offset we re currently on e g 1 in list 0 1 2 conjunctions list conjunctions j which offset list we re currently on e g 0 1 2 in list 0 1 0 1 2 ts size size token sequence newfs features tsi token sequence index oldfs old features iter indices counter to keep track how far in each iterator in iters features property list make conjunctions property list iterator iters curr index conjunctions j ts size property list newfs tsi property list oldfs iter indices iters length == curr index base add feature current conjunction iters avoid redundant doubling feature space include only upper triangle redundant conjunctions j iter indices newfs feature = value = 1 0 i=0 i < iters length i++ s = iters i get key feature regex != !feature regex matcher s matches newfs feature += i==0 ? + s + conjunctions j i ==0 ? + conjunctions j i value = iters i get numeric value err adding feature + feature newfs = property list add feature value newfs recursive step iters curr index has next iters curr index next iter indices curr index ++ newfs = make conjunctions iters curr index+1 conjunctions j ts size newfs tsi oldfs iter indices reset iterator at curr index iters curr index = get offset iter conjunctions j curr index ts size tsi oldfs iter indices curr index = 1 newfs current feature redundant? current feature determined current values in iter indices which tells us where we are in each property list iterator we test to ensure we only include upper triange conjunctions conjunctions conjunction j which offset we re on iter indices counters each property list iterator feature redundant redundant conjunctions j iter indices i=1 i < iter indices length i++ conjunctions j i 1 == conjunctions j i iter indices i <= iter indices i 1 get iterators each token in offset property list iterator get offset iters conjunctions j ts size tsi property list oldfs property list iterator iters = property list iterator conjunctions j length get iterators offsets iteri=0 iteri < iters length iteri++ iters iteri = get offset iter conjunctions j iteri ts size tsi oldfs iters iteri ==null iters property list iterator get offset iter conjunctions j iteri ts size tsi property list oldfs property list iterator iter tsi+conjunctions j iteri < 0 iter = startfs tsi+conjunctions j iteri 1 iterator conjunctions j iteri +tsi > ts size 1 iter = endfs tsi+conjunctions j iteri ts size iterator oldfs conjunctions j iteri +tsi == iter = iter = oldfs tsi+conjunctions j iteri iterator iter serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 0 n u l l i n t e g e r = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n size1 size2 size1 = conjunctions == ? n u l l i n t e g e r conjunctions length out write size1 size1 != n u l l i n t e g e r i = 0 i <size1 i++ size2 = conjunctions i == ? n u l l i n t e g e r conjunctions i length out write size2 size2 != n u l l i n t e g e r j = 0 j <size2 j++ out write conjunctions i j out write include original singletons out write feature regex add fuchun read input stream in i o not found size1 size2 = in read size1 = in read deserialization doesn t call unnamed initializer so it here startfs 0 == init start end fs size1 == n u l l i n t e g e r conjunctions = conjunctions = size1 i = 0 i < size1 i++ size2 = in read size2 == n u l l i n t e g e r conjunctions i = conjunctions i = size2 j = 0 j < size2 j++ conjunctions i j = in read include original singletons = in read feature regex = pattern in read add fuchun 