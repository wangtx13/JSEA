pipe list collection iterator pipe iterator empty instance iterator types instance a pipe that works like a rule list evaluate predicate on each pipe in first one that call that one called pipe and ignore remainder in called pipe will then get control source instance iterator until it produces an instance in other words it will be able to call next on source pipe often necessary to produce an instance you must be very careful that none iterators from pipes in rule list buffer any instances in other words they shouldn t call next to pre gather any instances they they themselves t consume and process immediately otherwise instances that should have been processed some other constituent pipe could get lost in buffering process author andrew mc callum <mccallum edu> deprecated not yet complete and seems quite dangerous and prone branching pipe pipe list< pipe> pipes branching pipe pipes = list< pipe> branching pipe pipe pipes pipes = list< pipe> pipes length i = 0 i < pipes length i++ pipes add pipes i branching pipe collection< pipe> pipe list pipes = list< pipe> pipe list peeking instance iterator iterator< instance> iterator< instance> source instance next instance = peeking instance iterator iterator< instance> source source = source has next source has next instance peek next next instance == !has next next instance == next instance = next next instance instance next next instance != instance tmp = next instance next instance = tmp source next remove illegal state iterator< instance> does not support remove gate keeping instance iterator iterator< instance> peeking instance iterator source pipe testing pipe gate keeping instance iterator peeking instance iterator source pipe testing pipe source = source testing pipe = testing pipe instance next make sure not an instance we were supposed to skip testing pipe precondition source peek next source next has next source has next testing pipe precondition source peek next remove illegal state iterator< instance> does not support remove branching instance iterator iterator< instance> peeking instance iterator source list< iterator< instance>> iterators branching instance iterator peeking instance iterator source source = peeking instance iterator source iterators = list< iterator< instance>> pipes size pipe p pipes iterators add gate keeping instance iterator source p has next source has next instance next instance input = source peek next i = 0 i < pipes size i++ pipes get i precondition input iterators get i next illegal state next instance satisfied none branches preconditions link pipe that processes link instance s going through iterator pipe get pipe iterator< instance> get source iterator source remove illegal state iterator< instance> does not support remove iterator< instance> iterator from iterator< instance> source pipes size == 0 source iterator< instance> ret = pipes get 0 iterator from source i = 1 i < pipes size i++ ret = pipes get i iterator from ret ret test branching pipe pipe sequence2 token sequence \\w skip instance inst ! inst sequence 