2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> share ner junit framework iterator random regex io optimize pipe pipe iterator pipe tsf types t u i command option gaussian variance option = command option t u i gaussian variance d e i m a l 10 0 gaussian prior variance used training command option hyperbolic slope option = command option t u i hyperbolic slope d e i m a l 0 2 hyperbolic prior slope used training command option hyperbolic sharpness option = command option t u i hyperbolic sharpness d e i m a l 10 0 hyperbolic prior sharpness used training command option crf input option = command option t u i crf input f i l e n a m e name to write r f after training command option random seed option = command option t u i random seed i n t e g e r 0 random seed randomly selecting a proportion instance list training command option label gram option = command option t u i label gram i n t e g e r 1 markov order labels 1 2 3 command option word window feature option = command option t u i word window size i n t e g e r 0 size window words features 0=none 10 20 command option use testb option = command option t u i use testb true|false use testb test set command option use hyperbolic prior option = command option t u i use hyperbolic prior true|false use hyperbolic prior command option use feature induction option = command option t u i use feature induction true|false not use or use feature induction command option cluster feature induction option = command option t u i cluster feature induction true|false cluster in feature induction command option use first mention feature option = command option t u i use firstmention feature true|false t use first mention feature command option use doc header feature option = command option t u i use docheader feature true|false command option include conll lexicons option = command option t u i include conll lexicons true|false command option n grams option = command option t u i ngrams true|false command option offsets option = command option t u i offsets e g 0 0 1 2 1 1 2 offset conjunctions command option cap offsets option = command option t u i cap offsets e g 0 0 0 1 offset conjunctions applied to features that are a z command option viterbi prefix option = command option t u i viterbi f i l e t u i filename in which to store most recent viterbi output command option list command options = command option list training testing and running a chinese word segmenter command option gaussian variance option hyperbolic slope option hyperbolic sharpness option random seed option label gram option word window feature option use hyperbolic prior option use feature induction option cluster feature induction option use first mention feature option use doc header feature option include conll lexicons option offsets option cap offsets option viterbi prefix option use testb option num evaluations = 0 iterations between evals = 16 doing feature induction = doing clustered feature induction = a p s = \\p lu l o w = \\p ll a p s n u m = \\p lu \\p nd a l p h a = \\p lu \\p ll a l p h a n u m = \\p lu \\p ll \\p nd p u n t = \\ ?! q u o t e = \ ` not found command options process homedir = get property h o m e lexdir = homedir+ research data resources offsets = offsets option value replace replace offsets = command option get interpreter eval +offsets cap offsets = cap offsets option value replace replace cap offsets = cap offsets length > 0 cap offsets = command option get interpreter eval +cap offsets pipe conll lexicons pipe = include conll lexicons option value conll lexicons pipe = serial pipes pipe trie lexicon membership lexdir + conll o n l l t w o p e r trie lexicon membership lexdir + conll o n l l t w o l o trie lexicon membership lexdir + conll o n l l t w o o r g trie lexicon membership lexdir + conll o n l l t w o m i s pipe p = serial pipes pipe conll ner2003 sentence2 token sequence regex matches i n i t a p pattern compile a p s+ regex matches a p i t a l i z e d pattern compile a p s+ l o w+ regex matches a l l a p s pattern compile a p s+ + regex matches m i x e d a p s pattern compile a z a z + a z a za z regex matches o n t a i n s d i g i t s pattern compile 0 9 regex matches a l l d i g i t s pattern compile 0 9 + regex matches n u m e r i a l pattern compile 0 9 + \\ + 0 9\\ + regex matches a l p h n u m e r i pattern compile a za z0 9 + regex matches r o m a n pattern compile ivxdlcm +| i v x d l m + regex matches m u l t o t s pattern compile \\ \\ + regex matches e n d s i n d o t pattern compile ^\\ + \\ regex matches o n t a i n s d a s h pattern compile a l p h a n u m+ + + a l p h a n u m+ regex matches a r o pattern compile a z a z\\ \\ a z\\ regex matches l o n e l y i n i t i a l pattern compile a p s+ \\ regex matches s i n g l e h a r pattern compile a l p h a regex matches a p l e t t e r pattern compile a z regex matches p u n pattern compile p u n t regex matches q u o t e pattern compile q u o t e regex matches l o w e r pattern compile l o w+ + regex matches m i x e d a p s pattern compile a z + a z + a z + a z include conll lexicons option value ? conll lexicons pipe noop note that word has not been lowecased! so i n i t a p etc redundant token sequence lowercase token text w= token sequence first sentence all caps offset conjunctions offsets cap offsets != ? pipe offset conjunctions cap offsets pipe noop t lowercase w= you want to use !use first mention feature option value ? pipe noop pipe features first mention f i r s t m e n t i o n= pattern compile a p s+ exclude singleton w=foo features b redundant pattern compile w= ^ + !use doc header feature option value ? pipe noop pipe token sequence doc header word window feature option value > 0 ? pipe features in window w i n d o w= word window feature option value word window feature option value pattern compile w o r d= pipe noop n grams option value ? pipe token text n grams h a r n g r a m= 2 3 4 pipe noop print token sequence features token sequence2 feature vector sequence set up training and testing data = homedir+ research data ie ner2003 eng testa use testb option value = homedir+ research data ie ner2003 eng train homedir+ research data ie ner2003 eng testb = homedir+ research data ie ner2003 eng train homedir+ research data ie ner2003 eng testa instance list training data = instance list p training data add thru pipe line group iterator reader 0 pattern compile ^ d o s t a r t x x $ out read +training data size + training instances instance list testing data = length > 1 testing data = instance list p testing data add thru pipe line group iterator reader 1 pattern compile ^ d o s t a r t x x $ testing data == now just train on a small fraction data random r = random 1 proportions below training testing ignore instance list training lists = training data split r 2 1 7 training data = training lists 0 and test on just 50% data testing data != instance list testing lists = testing data split r 5 5 testing data = testing lists 0 testing lists = testing data = training lists 1 training lists = testing data != print out all target names alphabet targets = p get target alphabet out print state labels i = 0 i < targets size i++ out print + targets lookup i out print out some feature out number features = +p get data alphabet size r f crf = r f p label gram option value == 1 crf add states labels connected in training data label gram option value == 2 crf add states bi labels connected in training data label gram option value == 3 crf add states tri labels connected in training data illegal state label gram must be 1 2 or 3 not + label gram option value r f trainer label likelihood crft = r f trainer label likelihood crf use hyperbolic prior option value crft set use hyperbolic prior crft set hyperbolic prior slope hyperbolic slope option value crft set hyperbolic prior sharpness hyperbolic sharpness option value crft set gaussian prior variance gaussian variance option value i = 0 i < crf num states i++ transducer state s = crf get state i s get name at 0 == i s set initial weight p o s i t i v e i n f i n i t y out training on +training data size + training instances + testing data size + testing instances multi segmentation evaluator eval = multi segmentation evaluator instance list training data testing data training testing b p e r b l o b o r g b m i s i p e r i l o i o r g i m i s viterbi writer vw = viterbi writer viterbi prefix option value instance list training data testing data training testing use feature induction option value cluster feature induction option value crft train feature induction training data testing data eval 99999 10 99 200 0 5 1 2 5 7 crft train feature induction training data testing data eval 99999 10 99 1000 0 5 1 2 5 7 training proportions = 1 2 5 7 i = 0 i < training proportions length i++ crft train training data 3 training proportions i eval evaluate crft vw evaluate crft crft train training data 3 eval evaluate crft vw evaluate crft eval evaluate crft vw evaluate crft 