2011 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e semi supervised pr logging logger r f sum lattice transducer transducer state types label alphabet types label vector types matrix ops types sequence logger lattice e step i projection in p r author gregory druck author kedar bellare sum lattice p r sum lattice logger logger = logger get logger sum lattice p r get name total weight lattice length gammas xis label vector labelings transducer transducer lattice node nodes sequence input sum lattice p r transducer trans index sequence input sequence output p r auxiliary model aux model cached dots increment constraints transducer incrementor incrementor label alphabet output alphabet save xis output == || input size == output size initialize some structures input = input transducer = trans lattice length = input size + 1 num states = transducer num states nodes = lattice node lattice length num states gammas = lattice length num states save xis xis = lattice length num states num states output counts = output alphabet != output counts = lattice length output alphabet size i = 0 i < num states i++ ip = 0 ip < lattice length ip++ gammas ip i = transducer i m p o s s i b l e w e i g h t save xis j = 0 j < num states j++ ip = 0 ip < lattice length ip++ xis ip i j = transducer i m p o s s i b l e w e i g h t forward pass at least one initial state = i = 0 i < num states i++ initial weight = transducer get state i get initial weight initial weight > transducer i m p o s s i b l e w e i g h t get lattice node 0 i alpha = initial weight at least one initial state = at least one initial state == logger warning there are no starting states! ip = 0 ip < lattice length 1 ip++ i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t state s = transducer get state i cached dot transition iterator iter = cached dot transition iterator r f state s input ip cached dots ip i aux model pre process index ip input iter has next state destination = iter next lattice node destination node = get lattice node ip + 1 destination get index destination node output = iter get output transition weight = iter get weight transition weight += aux model get weight index ip input iter destination node alpha = transducer sum log prob destination node alpha nodes ip i alpha + transition weight total weight = transducer i m p o s s i b l e w e i g h t i = 0 i < num states i++ nodes lattice length 1 i != total weight = transducer sum log prob total weight nodes lattice length 1 i alpha + transducer get state i get weight total weight == transducer i m p o s s i b l e w e i g h t backward pass i = 0 i < num states i++ nodes lattice length 1 i != state s = transducer get state i nodes lattice length 1 i beta = s get weight gammas lattice length 1 i = nodes lattice length 1 i alpha + nodes lattice length 1 i beta total weight incrementor != p = math exp gammas lattice length 1 i p >= 0 0 p <= 1 0 + 1e 6 p= + p + gamma= + gammas lattice length 1 i incrementor increment state s p ip = lattice length 2 ip >= 0 ip i = 0 i < num states i++ nodes ip i == || nodes ip i alpha == transducer i m p o s s i b l e w e i g h t state s = transducer get state i cached dot transition iterator iter = cached dot transition iterator r f state s input ip cached dots ip i aux model pre process index ip input iter has next state destination = iter next j = destination get index lattice node destination node = nodes ip + 1 j destination node != transition weight = iter get weight transition weight += aux model get weight index ip input iter nodes ip i beta = transducer sum log prob nodes ip i beta destination node beta + transition weight xi = nodes ip i alpha + transition weight + nodes ip + 1 j beta total weight save xis xis ip i j = xi incrementor != || aux model num > 0 || output alphabet != p = math exp xi p >= 0 0 p <= 1 0 + 1e 6 p= + p + xis + ip + + i + + j + = + xi incrementor != incrementor increment transition iter p increment constraints preprocess from above still applies aux model increment transition index ip input iter p output alphabet != output index = output alphabet lookup index iter get output output index >= 0 output counts ip output index += p gammas ip i = nodes ip i alpha + nodes ip i beta total weight incrementor != i = 0 i < num states i++ p = math exp gammas 0 i p >= 0 0 p <= 1 0 + 1e 6 p= + p incrementor increment initial state transducer get state i p output alphabet != labelings = label vector lattice length ip = lattice length 2 ip >= 0 ip math abs 1 0 matrix ops sum output counts ip < 0 000001 labelings ip = label vector output alphabet output counts ip lattice node get lattice node ip state index nodes ip state index == nodes ip state index = lattice node ip transducer get state state index nodes ip state index get xis xis get gammas gammas get total weight ! na n total weight total weight get gamma weight input position state s gammas input position s get index get gamma weight input position state index gammas input position state index get gamma probability input position state s math exp gammas input position s get index get gamma probability input position state index math exp gammas input position state index get xi probability ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index math exp xis ip i j get xi weight ip state s1 state s2 xis == illegal state xis were not saved i = s1 get index j = s2 get index xis ip i j length lattice length get alpha ip state s lattice node node = get lattice node ip s get index node alpha get beta ip state s lattice node node = get lattice node ip s get index node beta label vector get labeling at position output position labelings != labelings output position transducer get transducer transducer lattice node input position state state output alpha = transducer i m p o s s i b l e w e i g h t beta = transducer i m p o s s i b l e w e i g h t lattice node input position state state input position = input position state = state alpha == transducer i m p o s s i b l e w e i g h t sequence get input input 