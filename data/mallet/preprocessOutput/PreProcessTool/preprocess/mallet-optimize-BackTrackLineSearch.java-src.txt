2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author aron culotta <a href= mailto culotta >culotta edu< a> numerical recipes in p 385 lnsrch a simple backtracking line search no attempt at accurately finding minimum made goal only to ensure that back track line search will a position higher value optimize logging arrays r f optimize line optimizer optimize optimizable types matrix ops line searches and backtracking p385 numeric recipes in back track line search line optimizer gradient logger logger = logger get logger back track line search get name optimizable gradient value function back track line search optimizable gradient value optimizable function = optimizable max iterations = 100 stpmax = 100 e p s = 3 0e 12 termination conditions either a abs delta x x < r e l t o l x all coordinates b abs delta x < a b s t o l x all coordinates sufficient function increase uses a l f rel tolx = 1e 7 abs tolx = 1e 4 tolerance on absolute value difference a l f = 1e 4 sets tolerance relative diff in function value line search converges <tt>abs delta x x < tolx< tt> all coordinates set rel tolx tolx rel tolx = tolx sets tolerance absolute diff in function value line search converges <tt>abs delta x < tolx< tt> all coordinates set abs tolx tolx abs tolx = tolx initial step ignored b initial step not 1 0 it sometimes confuses backtracking reasons i t understand that jump gets l a r g e r on iteration 1 fraction step size alam found a good step 0 0 could not step in direction optimize line initial step g x old slope slope temp test alamin alam alam2 tmplam rhs1 rhs2 a b disc old alam f fold f2 g = function get num gradient x = function get num old = function get num function get x arraycopy x 0 old 0 x length function get value gradient g alam2 = tmplam = 0 0 f2 = fold = function get value logger loggable level f i n e logger fine e n t e r i n g b a k t r a k logger fine entering back track ln srch value= +fold+ direction one norm + matrix ops one norm line + direction inf norm + matrix ops infinity norm line ! matrix ops na n g sum = matrix ops two norm line sum > stpmax logger warning attempted step too big scaling sum= +sum+ stpmax= +stpmax matrix ops times equals line stpmax sum slope = slope = matrix ops dot product g line logger fine slope= +slope slope < 0 invalid optimizable slope = + slope + negative slope == 0 invalid optimizable slope = + slope + zero find maximum lambda converge when delta x x < r e l t o l x all coordinates largest step size that triggers threshold precomputed and saved in alamin test = 0 0 i=0 i<old length i++ temp = math abs line i math max math abs old i 1 0 temp > test test = temp alamin = rel tolx test alam = 1 0 old alam = 0 0 iteration = 0 look step size in direction given line iteration=0 iteration < max iterations iteration++ x = old + alam line initially alam = 1 0 i e take full newton step logger fine back track loop iteration +iteration+ alam= + alam+ old alam= +old alam logger fine before step x 1norm + matrix ops one norm x + alam + alam + old alam + old alam alam != old alam alam == old alam matrix ops plus equals x line alam old alam step logger fine after step x 1norm + matrix ops one norm x check convergence convergence on delta x alam < alamin || small abs diff old x alam < alamin function set old f = function get value logger warning e x i t i n g b a k t r a k jump too small alamin= +alamin+ exiting and using xold value= +f 0 0 function set x old alam = alam f = function get value logger fine value= +f sufficient function increase wolf condition f >= fold+ a l f alam slope logger fine e x i t i n g b a k t r a k value= +f f<fold illegal state function did not increase f= + f + < + fold + =fold alam value infinite i e we ve jumped to unstable territory then scale down jump infinite f || infinite f2 logger warning value infinite after jump + old alam + f= +f+ f2= +f2+ scaling back step size tmplam = 2 alam alam < alamin convergence on delta x function set old f = function get value logger warning e x i t i n g b a k t r a k jump too small exiting and using xold value= +f 0 0 backtrack alam == 1 0 first time through tmplam = slope 2 0 f fold slope rhs1 = f fold alam slope rhs2 = f2 fold alam2 slope alam alam2 != 0 f a i l u r e dividing alam alam2 alam= +alam a = rhs1 alam alam rhs2 alam2 alam2 alam alam2 b = alam2 rhs1 alam alam +alam rhs2 alam2 alam2 alam alam2 a == 0 0 tmplam = slope 2 0 b disc = b b 3 0 a slope disc < 0 0 tmplam = 5 alam b <= 0 0 tmplam = b+ math sqrt disc 3 0 a tmplam = slope b+ math sqrt disc tmplam > 5 alam tmplam = 5 alam lambda <= 5 lambda 1 alam2 = alam f2 = f logger fine tmplam +tmplam alam = math max tmplam 1 alam lambda >= 1 lambda 1 iteration >= max iterations illegal state too many iterations 0 0 iff we ve converged based on absolute x difference small abs diff x xold i = 0 i < x length i++ math abs x i xold i > abs tolx 