2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e inference gbp gnu trove t hash set types factor types var set types variable created may 27 2005 author < a h r e f= mailto casutton edu>casutton edu< a> $ region graph v 1 1 2007 10 22 21 37 58 exp $ region graph set regions = t hash set list edges = list region graph add region parent region child !is connected parent child add region parent add region child child root = parent children == parent children = list parent children add child child parents == child parents = list child parents add parent edges add region edge parent child connected region parent region child parent children contains child add region region region regions add region region index != 1 illegal argument region +region+ has already been added to a different region graph region index = regions size 1 size regions size iterator iterator regions iterator iterator edge iterator edges iterator compute inference caches compute descendants include descendant factors compute factors to send compute counting numbers compute cousins compute neighboring parents compute looping messages todo compute d p r well include descendant factors slightly inefficient a recursive soln would be more efficient iterator it = iterator it has next region region = region it next iterator d it = region descendants iterator d it has next region descendant = region d it next factors a set so it avoids duplicates region factors add all descendant factors compute looping messages iterator it = edge iterator it has next region edge edge = region edge it next region to = edge to list result = list iterator cousin it = edge cousins iterator cousin it has next region cousin = region cousin it next cousin == edge from iterator edge it = cousin children iterator edge it has next region cousin child = region edge it next cousin child == to || to descendants contains cousin child result add find edge cousin cousin child edge looping messages = result computes region graph counting numbers defined in yedidia et al compute counting numbers linked list queue = linked list iterator it = regions iterator it has next region region = region it next region root queue add region !queue empty region region = region queue remove first parent cnt = 0 iterator it = region parents iterator it has next region parent = region it next parent cnt += parent counting number region counting number = 1 parent cnt queue add all region children compute factors to send iterator it = edges iterator it has next region edge edge = region edge it next edge initialize factors to send compute cousins iterator it = edge iterator it has next region edge edge = region edge it next set cousins = t hash set edge from descendants cousins remove all edge to descendants cousins remove edge to cousins add edge from edge cousins = cousins compute descendants iterator it = regions iterator it has next region region = region it next region root compute descendants rec region compute descendants rec region region set descendants = t hash set region children size all region graphs are d a gs so no infinite regress iterator it = region children iterator it has next region child = region it next compute descendants rec child descendants add child descendants add all child descendants region descendants = descendants compute neighboring parents iterator it = edge iterator it has next region edge edge = region edge it next edge neighboring parents = list list l = linked list regions l remove all edge from descendants l remove edge from iterator uncle it = l iterator uncle it has next region uncle = region uncle it next iterator child it = uncle children iterator child it has next region cousin = region child it next edge cousins contains cousin edge neighboring parents add find edge uncle cousin horrifically inefficient region edge find edge region uncle region cousin idx = edges index region edge uncle cousin region edge edges get idx to buffer buf = buffer buf append r e g i o n g r a p h regions iterator it = regions iterator it has next region region = region it next buf append buf append region buf append edges iterator it = edges iterator it has next region edge edge = region edge it next buf append buf append edge from buf append > buf append edge to buf append buf to contains region region regions contains region region in graph whose factor list contains only a given potential ptl create an appropriate region will be created and added to graph none found a region or no region found and create region find region factor ptl create set all vars = ptl var set iterator it = regions iterator it has next region region = region it next region vars size == all vars size region vars contains all all vars region create region region = region ptl add region region region region in graph whose variable list contains only a given variable var create an appropriate region will be created and added to graph none found a region or no region found and create region find region variable var create iterator it = regions iterator it has next region region = region it next region vars size == 1 region vars contains var region create region region = region var add region region region finds smallest region containing a given variable might a region that contains many extraneous variables variable region find containing region variable variable region ret = iterator it = regions iterator it has next region region = region it next region vars contains variable ret == || region vars size < ret vars size ret = region ret finds smallest region containing all variables in a given set might a region that contains many extraneous variables var set region find containing region var set var set region ret = iterator it = regions iterator it has next region region = region it next region vars contains all var set ret == || region vars size < ret vars size ret = region ret num edges edges size 