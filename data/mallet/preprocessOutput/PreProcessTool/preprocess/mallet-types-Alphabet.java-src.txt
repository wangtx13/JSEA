2002 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e author andrew mc callum <a href= mailto >mccallum edu< a> types io i o io input stream io output stream io stream io output stream writer io print stream io print writer io serializable rmi dgc v m list iterator concurrent concurrent hash map concurrent concurrent map concurrent locks read write lock concurrent locks reentrant read write lock a mapping between integers and where mapping in each direction efficient integers are assigned consecutively starting at zero are added to alphabet can not be deleted from alphabet and thus integers are never reused <p> most use an alphabet a dictionary feature names associated a link types feature vector in an link types instance in a simple document classification usage each unique word in a document would be a unique entry in alphabet a unique associated it feature vectors rely on mapping to efficiently represent subset alphabet present in feature vector feature vector instance pipe pipe alphabet serializable gnu trove t hash map map list entries growth stopped = entry = v m instance = v m used in read resolve to identify persitent instances read write lock lock = reentrant read write lock alphabet capacity entry map = gnu trove t hash map capacity entries = list capacity entry = entry someone could to deserialize us into image e g r m i handle deserialized entries put absent instance alphabet entry 8 entry alphabet capacity capacity alphabet 8 alphabet entries entries length entry entries lookup index entry clone lock read lock lock alphabet ret = alphabet ret map = gnu trove t hash map map clone ret entries = list entries clone ret growth stopped = growth stopped ret entry = entry ret lock read lock unlock 1 entry isn t present lookup index entry add not present entry == illegal argument can t lookup \ null\ in an alphabet entry == entry = entry get insist that all entries in alphabet are same may not be strictly necessary but will a bunch easily made errors entry get != entry illegal argument non matching entry + entry get + was + entry lock read lock lock map contains key entry map get entry lock read lock unlock !growth stopped add not present lock write lock lock ret index = entries size map put entry ret index entries add entry ret index lock write lock unlock 1 lookup index entry lookup index entry lookup index lock read lock lock entries get index lock read lock unlock to lock read lock lock entries to lock read lock unlock an containing all entries in alphabet runtime type runtime type in in large enough to hold everything in alphabet then it it used such that all entries <tt>obj< tt> <tt>ret lookup index obj = obj< tt> to in lock read lock lock entries to in lock read lock unlock xxx should disable iterator s remove thread safety a copy should probably use size and lookup instead iterator iterator lock read lock lock list copy = list copy add all entries copy iterator lock read lock unlock lookup indices lock read lock lock ret = indices length i = 0 i < indices length i++ ret i = entries get indices i ret lock read lock unlock an corresponding to indices an indices to look up buf an to store in an values from alphabet runtime type same buf lookup indices buf lock read lock lock i = 0 i < indices length i++ buf i = entries get indices i buf lock read lock unlock lookup indices add not present ret = length i = 0 i < length i++ ret i = lookup index i add not present ret contains entry lock read lock lock map contains entry lock read lock unlock size lock read lock lock entries size lock read lock unlock stop growth growth stopped = start growth growth stopped = growth stopped growth stopped entry entry representation all alphabet entries each separated a newline to lock read lock lock buffer sb = buffer i = 0 i < entries size i++ sb append entries get i to sb append sb to lock read lock unlock dump dump out dump print stream out dump print writer output stream writer out dump print writer out lock read lock lock i = 0 i < entries size i++ out i + => + entries get i lock read lock unlock convenience that can often implement alphabets match in classes that implement alphabets carrying alphabets match alphabet carrying object1 alphabet carrying object2 alphabet a1 = object1 get alphabets alphabet a2 = object2 get alphabets a1 length != a2 length i = 0 i < a1 length i++ a1 i == a2 i a1 i == || a2 i == one but other isn t ! a1 i equals a2 i v m get instance instance debugging set instance v m instance = serialization serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o lock read lock lock out write u r r e n t s e r i a l v e r s i o n out write entries size i = 0 i < entries size i++ out write entries get i out write growth stopped out write entry out write instance lock read lock unlock read input stream in i o not found lock = reentrant read write lock lock write lock lock = in read size = in read entries = list size map = gnu trove t hash map size i = 0 i < size i++ o = in read map put o i entries add o growth stopped = in read entry = in read > 0 instanced added in 1 s instance = v m in read lock write lock unlock concurrent map< v m object> deserialized entries = concurrent hash map< v m object> gets called after read it lets decide whether to itself or a previously read in we use a hash map instance ids to determine we have already read in stream read resolve stream previous = deserialized entries get instance previous != out alphabet read resolve resolving to previous instance instance id= + instance previous instance != prev = deserialized entries put absent instance prev != prev out alphabet read resolve instance instance id= + instance 