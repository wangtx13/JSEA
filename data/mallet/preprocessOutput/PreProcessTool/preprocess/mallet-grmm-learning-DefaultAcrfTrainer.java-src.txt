2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e gnu trove t list io io writer io print writer date iterator list random logging logger a r f a r f evaluator a r f maximizable a r f labels assignment optimize conjugate gradient optimize limited memory b f g s optimize optimizable optimize optimizer types logger timing training a r fs <p > <p > created thu oct 16 17 53 14 2003 author <a href= mailto casutton > charles sutton< a> $ acrf trainer v 1 1 2007 10 22 21 37 43 exp $ acrf trainer a r f trainer logger logger = logger get logger acrf trainer get name optimizer maxer rethrow exceptions = acrf trainer a r f trainer constructor output prefix = set output prefix f output prefix = f optimizer get maxer maxer set maxer optimizer maxer maxer = maxer rethrow exceptions rethrow exceptions set rethrow exceptions rethrow exceptions acrf trainer rethrow exceptions = rethrow exceptions train a r f acrf instance list training train acrf training log evaluator 1 train a r f acrf instance list training num iter train acrf training log evaluator num iter train a r f acrf instance list training a r f evaluator eval num iter train acrf training eval num iter train a r f acrf instance list training instance list validation instance list testing num iter train acrf training validation testing log evaluator num iter train a r f acrf instance list training list instance list validation list instance list test set a r f evaluator eval num iter optimizable gradient value macrf = create optimizable acrf training list train acrf training list validation list test set eval num iter macrf optimizable gradient value create optimizable a r f acrf instance list training list acrf get maximizable training list threaded train a r f acrf instance list training list instance list validation list instance list test set a r f evaluator eval num iter maximizable gradient macrf = acrf get threaded maximizable training list train dcrf training list validation list test set eval num iter mdcrf incremental train a r f acrf instance list training instance list validation instance list testing num iter incremental train acrf training validation testing log evaluator num iter s i z e = 0 1 0 5 s u b s e t i t e r = 10 incremental train a r f acrf instance list training instance list validation instance list testing a r f evaluator eval num iter stime = date get time i = 0 i < s i z e length i++ instance list subset = training split s i z e i 1 s i z e i 0 logger info training on subset size + subset size optimizable gradient value subset macrf = create optimizable acrf subset train acrf training validation eval s u b s e t i t e r subset macrf logger info subset training + i + finished etime = date get time logger info all subset training finished time = + etime stime + ms train acrf training validation testing eval num iter train a r f acrf instance list training list instance list validation list instance list test set a r f evaluator eval num iter optimizable gradient value macrf optimizer maximizer = create maxer macrf maximizer gradient maximizer = bold driver maximizer gradient maximizer = gradient descent converged = reset on = stime = current time millis num nodes = macrf a r f maximizable a r f ? a r f maximizable a r f macrf get total nodes 0 thresh = 1e 5 num nodes early stopping reasonably conservative test set == logger warning a r f trainer no test set prev value = n e g a t i v e i n f i n i t y current value iter iter = 0 iter < num iter iter++ etime = date get time logger info a r f trainer iteration + iter + at time + etime stime converged = maximizer optimize 1 converged |= call evaluator acrf training list validation list test set iter eval converged reset on = runtime e e print stack trace we get a maximizing reset l b f g s memory and again we get an on second too then just give up reset on logger warning in iteration + iter + + e + resetting l b f gs and trying again maximizer limited memory b f g s limited memory b f g s maximizer reset maximizer conjugate gradient conjugate gradient maximizer reset reset on = logger warning in iteration + iter + + e + quitting and saying converged converged = rethrow exceptions e converged early stopping current value = macrf get value math abs current value prev value < thresh ignore cutoff we re about to reset l b f g s reset on logger info a r f trainer saying converged + current value + current value + previous + prev value + threshold was + thresh + = 1e 5 + num nodes converged = prev value = current value iter >= num iter logger info a r f trainer too many iterations stopping training max iter = +num iter etime = current time millis logger info a r f training time ms = + etime stime macrf maximizable a r f maximizable a r f macrf report test set != eval != t cache test set old cache = acrf cache unrolled graphs acrf set cache unrolled graphs eval test acrf test set testing acrf set cache unrolled graphs old cache converged optimizer create maxer optimizable gradient value macrf maxer == limited memory b f g s macrf maxer means stop means keep going opposite evaluators ugh! call evaluator a r f acrf instance list training list instance list validation list instance list test set iter a r f evaluator eval eval == no evaluator specified keep going blindly eval set output prefix output prefix t cache test set was cached = acrf cache unrolled graphs acrf set cache unrolled graphs timing timing = timing !eval evaluate acrf iter+1 training list validation list test set logger info a r f trainer evaluator quitting timing tick evaluation time iteration +iter+ timing tick evaluation time iteration +iter+ set test set caching back to normal acrf set cache unrolled graphs was cached some unsupported train a r f acrf instance list training list instance list validation list instance list test set a r f evaluator eval num iter optimizable gradient value macrf = create optimizable acrf training list train acrf training list validation list test set eval 5 macrf a r f template tmpls = acrf get templates ti = 0 ti < tmpls length ti++ tmpls ti add some unsupported weights training list logger info some unsupporetd weights initialized training train acrf training list validation list test set eval num iter macrf test a r f acrf instance list testing a r f evaluator eval test acrf testing a r f evaluator eval test a r f acrf instance list testing a r f evaluator evals list pred = acrf get best labels testing i = 0 i < evals length i++ evals i set output prefix output prefix evals i test testing pred testing random r = random 1729 random get random r train a r f acrf instance list training instance list validation instance list testing a r f evaluator eval proportions iter per proportion i = 0 i < proportions length i++ proportion = proportions i instance list lists = training split r proportion 1 0 logger info a r f trainer round + i + training proportion = + proportion train acrf lists 0 validation testing eval iter per proportion logger info a r f trainer training on full data train acrf training validation testing eval 99999 log evaluator a r f evaluator test results last results log evaluator evaluate a r f acrf iter instance list training instance list validation instance list testing should evaluate iter training != test acrf training training testing != test acrf testing testing test instance list test list list list description logger info description+ number instances = + test list size test results results = compute test results test list list results log description last results = results results print confusion test results compute test results instance list test list list list test results results = test results test list iterator it1 = test list iterator iterator it2 = list iterator it1 has next instance inst = instance it1 next out instance labels assignment lblseq = labels assignment inst get target labels sequence target = lblseq get labels sequence labels sequence = labels sequence it2 next out target compare labelings results target results compute statistics results compare labelings test results results labels sequence labels sequence target size == target size i = 0 i < size i++ out time +i labels lbls = get labels i labels lbls target = target get labels i results increment count lbls lbls target get joint accuracy last results get joint accuracy evaluator a r f evaluator evaluator = evaluate a r f acrf iter instance list training instance list validation instance list testing should evaluate iter test acrf testing testing test instance list test list list list description logger info number testing instances = + test list size test results results = log evaluator compute test results test list list print writer writer = print writer writer results print description writer writer close e e print stack trace results print confusion test results confusion confusion matrix num classes marginals confusion matrix counts counts per precision recall and f1 precision recall f1 measuring accuracy each factor t list factors measuring joint accuracy max t = 0 correct t = 0 alphabet alphabet test results instance list ilist ilist get 0 test results instance inst alphabet = alphabet setup alphabet inst num classes = alphabet size confusion = num classes num classes precision = num classes recall = num classes f1 = num classes isn t pretty but i swear there s not an easy way setup alphabet instance inst labels assignment lblseq = labels assignment inst get target factors = t list lblseq num slices i = 0 i < lblseq num slices i++ label alphabet dict = lblseq get output alphabet i factors i = t list dict size j = 0 j < dict size j++ idx = alphabet lookup index dict lookup j factors i add idx increment count labels lbls labels lbls target all same = and per label accuracy j = 0 j < lbls size j++ label lret = lbls get j label ltarget = lbls target get j out ltarget+ vs +lret idx = alphabet lookup index ltarget get entry idx ret = alphabet lookup index lret get entry idx != idx ret all same = confusion idx idx ret ++ measure joint accuracy max t++ all same correct t++ compute statistics compute marginals confusion matrix assumes that confusion i j means label i and label j counts = num classes counts = num classes i = 0 i < num classes i++ j = 0 j < num classes j++ counts i += confusion i j counts j += confusion i j compute per precision recall and f1 i = 0 i < num classes i++ correct = confusion i i counts i == 0 precision i = correct == 0 ? 1 0 0 0 precision i = correct counts i counts i == 0 recall i = 1 0 recall i = correct counts i f1 i = 2 precision i recall i precision i + recall i log log log desc logger info desc+ i label n correct p r f1 i = 0 i < num classes i++ logger info desc+ +i + + alphabet lookup i + + counts i + + confusion i i + + counts i + + precision i + + recall i + + f1 i + fnum = 0 fnum < factors length fnum++ correct = 0 = 0 i = 0 i < factors fnum size i++ lbl = factors fnum get i correct += confusion lbl lbl += counts lbl logger info desc + factor + fnum + accuracy + correct + + + + correct logger info desc + correct t + correct t + maxt + max t logger info desc + joint accuracy + correct t max t print desc print writer out out i label n correct p r f1 i = 0 i < num classes i++ out i + + alphabet lookup i + + counts i + + confusion i i + + counts i + + precision i + + recall i + + f1 i + fnum = 0 fnum < factors length fnum++ correct = 0 = 0 i = 0 i < factors fnum size i++ lbl = factors fnum get i correct += confusion lbl lbl += counts lbl out desc + factor + fnum + accuracy + correct + + + + correct out desc + correct t + correct t + maxt + max t out desc + joint accuracy + correct t max t print confusion out count i = 0 i < num classes i++ j = 0 j < num classes j++ out i + + j + + confusion i j get joint accuracy correct t max t test results a r f trainer 