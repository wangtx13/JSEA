pipe io types regex pipe changes text to lowercase removes xml entities apos lt and replaces all punctuation except character whitespace it then breaks up tokens on whitespace and applies n gram token replacements and deletions replacements are applied in order they are specified first and then within files n gram preprocessor pipe serializable list< replacement set> replacement sets n gram preprocessor replacement sets = list< replacement set> load replacements filename i o buffered reader in = buffered reader reader filename replacement set set = replacement set total replacements = 0 line line = in read line != set add replacement replacement line total replacements++ in close replacement sets add set total replacements load deletions filename i o buffered reader in = buffered reader reader filename replacement set set = replacement set total replacements = 0 line line = in read line != set add replacement replacement line total replacements++ in close replacement sets add set total replacements instance pipe instance instance input = instance get data input = input to lower out input remove xml entities input = input replace all apos input = input replace all \ input = input replace all < input = input replace all lt > remove all non letter number characters except dash and apostrophe input = input replace all ^\\p l \\p n \\ \\ reduce all blocks whitespace to a single space input = input replace all \\s+ replacement set set replacement sets input = set apply replacements input out input instance set data input instance serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write replacement sets read input stream in i o not found = in read replacement sets = list< replacement set> in read replacement set serializable hash map< list< replacement>> replacement index replacement set replacement index = hash map< list< replacement>> add replacement replacement replacement key = replacement get first token ! replacement index contains key key replacement index put key list< replacement> replacement index get key add replacement apply replacements input tokens = input split builder output = builder position = 0 position < tokens length token = tokens position initial position = position replacement index contains key token replacement replacement replacement index get token position = replacement apply tokens position output position > initial position position == initial position no replacements were made so nothing has been output output append token + position ++ output to serial u = 1 u r r e n t s e r i a l v e r s i o n = 1 write output stream out i o out write u r r e n t s e r i a l v e r s i o n out write replacement index read input stream in i o not found = in read replacement index = hash map< list< replacement>> in read 