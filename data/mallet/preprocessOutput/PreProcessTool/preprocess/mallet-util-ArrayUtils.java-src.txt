2003 m a l l e t m achine languag e ~mccallum 1 0 further ` l i e n s e gnu trove t procedure gnu trove t procedure reflect utility arrays like arrays but more useful author <a href= mailto casutton > charles sutton< a> $ utils v 1 1 2007 10 22 21 37 40 exp $ utils utils index obj i = 0 i < length i++ i != i equals obj i 1 index obj i = 0 i < length i++ i == obj i 1 procedure proc any element v any t procedure proc v i = 0 i < v length i++ proc execute v i procedure proc any element v any t procedure proc v i = 0 i < v length i++ j = 0 j < v i length j++ proc execute v i j each t procedure proc v i = 0 i < v length i++ proc execute v i each t procedure proc v i = 0 i < v length i++ j = 0 j < v i length j++ proc execute v i j print v out print i = 0 i < v length i++ out print + v i out print v out print i = 0 i < v length i++ out print + v i out to v buffer buf = buffer i = 0 i < v length i++ buf append v i i < v length 1 buf append buf to to v buffer buf = buffer i = 0 i < v length i++ buf append v i i < v length 1 buf append buf to to v buffer buf = buffer i = 0 i < v length i++ buf append v i i < v length 1 buf append buf to a containing all a additional extra space added zero initialized a additional extend a additional ret = a length + additional arraycopy a 0 ret 0 a length ret a containing all a additional extra space added zero initialized a additional extend a additional ret = a length + additional arraycopy a 0 ret 0 a length ret a that concatenation a1 and a2 a1 a2 append a1 a2 ret = a1 length + a2 length arraycopy a1 0 ret 0 a1 length arraycopy a2 0 ret a1 length a2 length ret a that concatenation a1 and a2 a1 a2 append a1 a2 ret = a1 length + a2 length arraycopy a1 0 ret 0 a1 length arraycopy a2 0 ret a1 length a2 length ret a a single element appended at end use sparingly it will allocate a you can easily turn a linear time algorithm to quadratic way v original elem element to add to end append v elem ret = v length + 1 arraycopy v 0 ret 0 v length ret v length = elem ret a a single element appended at end use sparingly it will allocate a you can easily turn a linear time algorithm to quadratic way v original elem element to add to end append v elem ret = v length + 1 arraycopy v 0 ret 0 v length ret v length = elem ret a a single element appended at end use sparingly it will allocate a you can easily turn a linear time algorithm to quadratic way v original elem element to add to end length v+1 that v0 v1 vn elem runtime type will be same he pased in append v elem ret = instance v get get component type v length+1 arraycopy v 0 ret 0 v length ret v length = elem ret clone cloneable arr magic so that it can be cast to original type when done a = instance arr get get component type arr length i = 0 i < arr length i++ a i = arr i clone a number times a value occurs in a given count sampled val count = 0 i = 0 i < sampled length i++ sampled i == val count++ count argmax elems best idx = 1 max = n e g a t i v e i n f i n i t y i = 0 i < elems length i++ elem = elems i elem > max max = elem best idx = i best idx equals m1 m2 m1 length != m2 length i = 0 i < m1 length i++ m1 i length != m2 i length j = 0 j < m1 i length j++ b1 = m1 i j b2 = m2 i j b1 != b2 arrays 