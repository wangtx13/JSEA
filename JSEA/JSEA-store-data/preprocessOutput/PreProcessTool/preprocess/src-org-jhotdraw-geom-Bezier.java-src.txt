# bezi 2 0 1 2006 06 14 1996 2006 it contributor disclose accordance geom geom provide algorithm fitting bezi curve set digitize point p algorithm automatically fitting digitize curve philip j schneid graphic gem academic press 1990 2 0 1 2006 06 14 fit bezi curve preserve close state fit bezi path 2 0 2006 01 14 support precision coordinate 1 0 march 14 2004 author bezi most point have m x p o i n t s 1000 prevent instance creation bezi example how curve fitting given point tolerance square between point fit curve algorithm generate piecewise cubic bezi representation approximate point when cubic generate routine draw bezi curve call which output bezi curve just create argument are degree control point respectively user have implement function themselve ascii output etc point2 d d digitize point point2 d 0 0 0 0 point2 d 0 0 0 5 point2 d 1 1 1 4 point2 d 2 1 1 6 point2 d 3 2 1 1 point2 d 4 0 0 2 point2 d 4 0 0 0 4 0 square general path path fit curve d fit bezi curve out path fit bezi curve set digitize point p polygon set digitize point user define square general path contain bezi curve general path fit curve polygon p point2 d d point2 d p npoint i 0 i d length i++ d i point2 d p xpoint i p ypoint i fit curve d fit bezi curve set digitize point d digitize point user define square general path contain bezi curve general path fit curve point2 d d point2 d t hat1 point2 d point2 d t hat2 point2 d unit tangent vector at endpoint general path bezi path general path bezi path move d 0 x d 0 y t hat1 compute left tangent d 0 t hat2 compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezi path bezi path fit bezi curve set digitize point path path onto which fit bezi curve user define square bezi path contain bezi curve bezi path fit bezi curve bezi path path point2 d d path polygon point2 d t hat1 point2 d point2 d t hat2 point2 d unit tangent vector at endpoint bezi path bezi path bezi path bezi path add bezi path node d 0 t hat1 compute left tangent d 0 t hat2 compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezi path bezi path set close path close bezi path fit bezi curve sub set digitize point d digitize point first indice first point d last indice last point d t hat1 unit tangent vector at start point t hat2 unit tanget vector at end point user define square bezi path path which bezi curve segment are fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 general path bezi path point2 d bez curve control point fit bezi curve u parameter value point u prime improve parameter value maximum fitting split point 1 point split point set at size one because we need input output parameter n pt number point subset iteration below which iterate iteration 4 time iterate point2 d t hat center point2 d unit tangent vector at split point i iteration n pt last first + 1 heuristic region ha two point n pt 2 dist v2 distance between2 point d last d first 3 0 bez curve point2 d 4 i 0 i bez curve length i++ bez curve i point2 d bez curve 0 d first bez curve 3 d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y parameterize point attempt fit curve u chord length parameterize d first last bez curve generate bezi d first last u t hat1 t hat2 find deviation point fit curve compute d first last bez curve u split point bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y too large some reparameterization iteration iteration i 0 i iteration i++ u prime reparameterize d first last u bez curve bez curve generate bezi d first last u prime t hat1 t hat2 compute d first last bez curve u prime split point bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y u u prime fitting fail split at point fit recursively t hat center compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezi path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezi path fit bezi curve sub set digitize point d digitize point first indice first point d last indice last point d t hat1 unit tangent vector at start point t hat2 unit tanget vector at end point user define square bezi path path which bezi curve segment are fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 bezi path bezi path point2 d bez curve control point fit bezi curve u parameter value point u prime improve parameter value maximum fitting split point 1 point split point set at size one because we need input output parameter n pt number point subset iteration below which iterate iteration 4 time iterate point2 d t hat center point2 d unit tangent vector at split point i iteration n pt last first + 1 heuristic region ha two point n pt 2 dist v2 distance between2 point d last d first 3 0 bez curve point2 d 4 i 0 i bez curve length i++ bez curve i point2 d bez curve 0 d first bez curve 3 d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y parameterize point attempt fit curve u chord length parameterize d first last bez curve generate bezi d first last u t hat1 t hat2 find deviation point fit curve compute d first last bez curve u split point bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y too large some reparameterization iteration iteration i 0 i iteration i++ u prime reparameterize d first last u bez curve bez curve generate bezi d first last u prime t hat1 t hat2 compute d first last bez curve u prime split point bezi path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y u u prime fitting fail split at point fit recursively t hat center compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezi path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezi path least square find bezi control point region d digitize point first indice first point d last indice last point d u prime parameter value region t hat1 unit tangent vector at start point t hat2 unit tanget vector at end point point2 d generate bezi point2 d d first last u prime point2 d t hat1 point2 d t hat2 i point2 d point2 d m x p o i n t s 2 precomput rh eqn n pt number pt sub curve 2 2 matrix x 2 matrix x det c0 c1 determinant matrix det c0 x det x c1 alpha l alpha value left right alpha r point2 d tmp point2 d utility variable point2 d bez curve r e t u r n bezi curve ctl pt bez curve point2 d 4 i 0 i bez curve length i++ bez curve i point2 d n pt last first + 1 compute s i 0 i n pt i++ point2 d v1 v2 v1 point2 d t hat1 clone v2 point2 d t hat2 clone v2 scale v1 b1 u prime i v2 scale v2 b2 u prime i i 0 v1 i 1 v2 create x matrix 0 0 0 0 0 1 0 0 1 0 0 0 1 1 0 0 x 0 0 0 x 1 0 0 i 0 i n pt i++ 0 0 + v2 dot i 0 i 0 0 1 + v2 dot i 0 i 1 1 0 + v2 dot i 0 i 1 1 0 0 1 1 1 + v2 dot i 1 i 1 tmp v2 sub i i d first + i v2 add i i v2 scale i i i d first b0 u prime i v2 add i i v2 scale i i i d first b1 u prime i v2 add i i v2 scale i i i d last b2 u prime i v2 scale i i i d last b3 u prime i x 0 + v2 dot i 0 tmp x 1 + v2 dot i 1 tmp compute determinant x det c0 c1 0 0 1 1 1 0 0 1 det c0 x 0 0 x 1 0 1 x 0 det x c1 x 0 1 1 x 1 0 1 derive alpha value det c0 c1 0 0 det c0 c1 0 0 1 1 10e 12 alpha l det x c1 det c0 c1 alpha r det c0 x det c0 c1 alpha negative wu barsky heuristic see text alpha 0 get coincident control point divide zero subsequent newton raphson root find call alpha l 1 0e 6 || alpha r 1 0e 6 dist v2 distance between2 point d last d first 3 0 bez curve 0 d first bez curve 3 d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bez curve first last control point bezi curve are position exactly at first last data point control point 1 2 are position alpha distance out on tangent vector left right respectively bez curve 0 d first bez curve 3 d last v2 add bez curve 0 v2 scale t hat1 alpha l bez curve 1 v2 add bez curve 3 v2 scale t hat2 alpha r bez curve 2 bez curve given set point their parameterization find better parameterization d digitize point first indice first point region d last indice last point region d u current parameter value bez curve current fit curve reparameterize point2 d d first last u point2 d bez curve n pt last first+1 i u prime parameter value u prime n pt i first i last i++ u prime i first newton raphson root find bez curve d i u i first u prime newton raphson iteration find better root q current fit bezi curve p digitize point u parameter value vor p newton raphson root find point2 d q point2 d p u numerator denominator point2 d q1 point2 d 3 q2 point2 d 2 q q point2 d q u point2 d q1 u point2 d q2 u point2 d u evaluate at q q q u prime improve u i compute q u q u bezi i i 3 q u generate control vertex q i 0 i 2 i++ q1 i point2 d q i+1 x q i x 3 0 q i+1 y q i y 3 0 generate control vertex q i 0 i 1 i++ q2 i point2 d q1 i+1 x q1 i x 2 0 q1 i+1 y q1 i y 2 0 compute q u q u q1 u bezi i i 2 q1 u q2 u bezi i i 1 q2 u compute f u f u numerator q u x p x q1 u x + q u y p y q1 u y denominator q1 u x q1 u x + q1 u y q1 u y + q u x p x q2 u x + q u y p y q2 u y u u f u f u u prime u numerator denominator u prime evaluate bezi curve at particular parameter value degree degree bezi curve v control point t parametric value find point point2 d bezi i i degree point2 d v t i j point2 d q point on curve at parameter t point2 d vtemp local copy control point copy vtemp point2 d degree+1 i 0 i degree i++ vtemp i point2 d v i clone triangle computation i 1 i degree i++ j 0 j degree i j++ vtemp j x 1 0 t vtemp j x + t vtemp j+1 x vtemp j y 1 0 t vtemp j y + t vtemp j+1 y q vtemp 0 q b0 b1 b2 b3 bezi multiplier b0 u tmp 1 0 u tmp tmp tmp b1 u tmp 1 0 u 3 u tmp tmp b2 u tmp 1 0 u 3 u u tmp b3 u u u u approximate unit tangent at left endpoint digitize curve d digitize point end index left end region point2 d compute left tangent point2 d d end point2 d t hat1 point2 d t hat1 v2 sub i i d end+1 d end t hat1 v2 normalize t hat1 t hat1 approximate unit tangent at right endpoint digitize curve d digitize point end index right end region point2 d compute right tangent point2 d d end point2 d t hat2 point2 d t hat2 v2 sub i i d end 1 d end t hat2 v2 normalize t hat2 t hat2 approximate unit tangent at center digitize curve d digitize point center index center end region point2 d compute center tangent point2 d d center point2 d v1 point2 d v2 point2 d t hat center point2 d v1 v2 sub i i d center 1 d center v2 v2 sub i i d center d center+1 t hat center x v1 x + v2 x 2 0 t hat center y v1 y + v2 y 2 0 t hat center v2 normalize t hat center t hat center assign parameter value digitize point using relative distance between point d digitize point first indice first point region d last indice last point region d chord length parameterize point2 d d first last i u parameterization u last first+1 u 0 0 0 i first+1 i last i++ u i first u i first 1 + v2 distance between2 point d i d i 1 i first + 1 i last i++ u i first u i first u last first u find maximum square distance digitize point fit curve d digitize point first indice first point region d last indice last point region d bez curve fit bezi curve u parameterization point split point point maximum input output parameter 1 compute point2 d d first last point2 d bez curve u split point i dist maximum dist current point2 d p point2 d point on curve point2 d v point2 d vector point curve split point 0 last first + 1 2 dist 0 0 i first + 1 i last i++ p bezi i i 3 bez curve u i first v v2 sub i i p d i dist v2 square length v dist dist dist dist split point 0 i dist point2 d v2 add i i point2 d point2 d b point2 d point2 d x x + b x y y + b y point2 d v2 scale i i i point2 d v s point2 d result point2 d result x v x s result y v y s result point2 d v2 sub i i point2 d point2 d b point2 d point2 d x x b x y y b y graphic gem 2d 3d vector library andrew glassn graphic gem academic press 1990 distance between two point v2 distance between2 point point2 d point2 d b dx x b x dy y b y math sqrt dx dx + dy dy scale input vector length point2 d v2 scale point2 d v newlen len v2 length v len 0 0 v x newlen len v y newlen len v length input vector v2 length point2 d math sqrt v2 square length square length input vector v2 square length point2 d x x + y y vector sum a+b point2 d v2 add point2 d point2 d b point2 d x x+b x y y+b y negate input vector point2 d v2 negate point2 d v v x v x v y v y v dot vector b v2 dot point2 d point2 d b x b x + y b y normaliz input vector point2 d v2 normalize point2 d v len v2 length v len 0 0 v x len v y len v 