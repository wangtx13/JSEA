2006 05 26 1 1 1 2 create element get attribute value get attribute value write encode 2006 05 02 xml element $ revision 1 4 $ $ date 2002 03 24 10 27 59 $ $ r e l e s e 2 2 1 $ nano xml 2 2000 2002 purpose 1 2 3 io xml element representation xml able parse xml p d l d t b parse xml data b d t d d parse xml data using u l o d e xml element xml xml element b r reader reader reader filename xml b r xml parse reader reader o d e u l d d d l d l d t b retrieve attribute b d t d d enumerate attribute element using link #enumerate attribute name enumerate attribute name attribute value retrieve using link #get attribute get attribute example show how list attribute element u l o d e xml element element b r iterator it element get attribute name b r it ha next b r key it next b r value element get attribute key b r out key + + value b r o d e u l d d d l d l d t b retrieve child element b d t d d enumerate child element using link #iterate child iterate child number child iterator retrieve using link #count child count child d d d l d l d t b element contain character data b d t d d iterator contain character data like example u l o d e lt title title lt title o d e u l retrieve data using link #get content get content d d d l d l d t b subclass xml element b d t d d when subclass xml element need override link #create element create element which ha copy receiver d d d l p author lt href mailto cyberelf mac com cyberelf mac com 2005 06 18 adapt 2 p i $ r e l e s e 2 2 1 $ $ revision 1 4 $ see xml parse xml element serialization serial serial u 6685035139346394777 l major nano xml class same major minor are binary compatible class same major are compatible major different need modify client see # n n o xml m i n o r v e r s i o n n n o xml m j o r v e r s i o n 2 minor nano xml class same major minor are binary compatible class same major are compatible major different need modify client see # n n o xml m j o r v e r s i o n n n o xml m i n o r v e r s i o n 2 attribute given element b invariant b field empty field nev key set iterator value are string hash map attribute child iterator element b invariant b field empty field nev iterator are instance xml element subclass xml element list child element b invariant b field iff element initialize eith parse set field s empty field contain valid xml identifier # p d t content b invariant b field iff element # p d t element field empty content conversion table amp entity key set iterator are entity name amp delimiter b invariant b field nev field alway contain association lt lt \ apo amp amp key set iterator are string value are array hash map entity line number where element start b invariant b line nr 0 line nr element attribute name are insensitive ignore leading trailing whitespace # p d t section have ignore ignore whitespace character read too much character provide push back functionality input reader have pushback reader there character field \0 read too much reader caller parse b invariant b field parse running reader reader current line number content b invariant b parser line nr 0 parse running parser line nr variable set are encode entity encoding left underlie create initializ xml element calling construction equivalent xml element hash map b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see # xml element hash map xml element hash map see # xml element see # xml element hash map xml element hash map xml element hash map create initializ xml element calling construction equivalent xml element entity entity entity conversion table b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see # xml element see # xml element see # xml element hash map xml element hash map xml element hash map entity entity create initializ xml element calling construction equivalent xml element hash map skip leading whitespace skip leading whitespace leading trailing whitespace p d t content ha b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see # xml element see # xml element hash map xml element hash map see # xml element hash map xml element hash map xml element skip leading whitespace hash map skip leading whitespace create initializ xml element calling construction equivalent xml element entity skip leading whitespace entity entity conversion table skip leading whitespace leading trailing whitespace p d t content ha b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see # xml element see # xml element see # xml element hash map xml element hash map xml element hash map entity skip leading whitespace entity skip leading whitespace create initializ xml element entity entity conversion table skip leading whitespace leading trailing whitespace p d t content ha ignore element attribute name have ignore b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see # xml element see # xml element see # xml element hash map xml element hash map see # xml element hash map xml element hash map xml element hash map entity skip leading whitespace ignore entity skip leading whitespace ignore create initializ xml element p constructor should i i call link #create element create element create child iterator entity entity conversion table skip leading whitespace leading trailing whitespace p d t content ha fill basic conversion table basic entity need entity list ignore element attribute name have ignore b precondition b entity fill basic conversion table then entity contain at least entry amp lt apo b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get see #create element xml element hash map entity skip leading whitespace fill basic conversion table ignore entity skip leading whitespace fill basic conversion table ignore xml element hash map entity skip leading whitespace fill basic conversion table ignore ignore whitespace skip leading whitespace ignore ignore content attribute hash map child list entity entity line nr 0 iterator it entity key set iterator it ha next key it next value entity get key value value value entity put key value fill basic conversion table entity put amp entity put entity put apo \ entity put lt entity put add child element child child element add b precondition b child child get child doe have parent element b postcondition b count child old count child + 1 iterate child old iterate child + child get child old iterate child + child see #count child see #iterate child see #get child see #remove child xml element remove child xml element add child xml element child child add child add modifie attribute attribute value value attribute b precondition b valid xml identifier value b postcondition b enumerate attribute name old enumerate attribute name + get attribute value set attribute value ignore upper attribute put value add modifie attribute attribute value value attribute b precondition b valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name + get attribute value set attribute value ignore upper attribute put value add modifie attribute attribute value value attribute b precondition b valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name + get attribute value set attribute value ignore upper attribute put value number child iterator element b postcondition b result 0 see #add child xml element add child xml element see #iterate child see #get child see #remove child xml element remove child xml element count child child size enumerate attribute name b postcondition b result iterator enumerate attribute name attribute key set iterator enumerate child iterator b postcondition b result iterator iterate child child iterator child iterator list safe modify list b postcondition b result see #add child xml element add child xml element see #count child see #iterate child see #remove child xml element remove child xml element list get child list child clone e nev happen howev some compiler are so braindead they require clause p d t content there content o d e o d e see #set content set content get content content line nr data on which element found 0 there associate data b postcondition b result 0 get line nr line nr attribute element attribute doesn t attribute b precondition b valid xml identifier get attribute get attribute attribute element attribute doesn t value attribute value key attribute miss b precondition b valid xml identifier get attribute value ignore upper value attribute get value value value value attribute looking up key hashtable attribute doesn t value correspond key p example value set contain mapping one 1 element contain attribute attr one then get attribute attr mapping key 1 attribute value set hash map mapping key set iterator value key key attribute miss allow literal literal are valid b precondition b valid xml identifier value set key set iterator value set are string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute map value set key allow literal ignore upper key attribute get result key key key result value set get key result allow literal result key invalid value key result attribute element attribute doesn t attribute b precondition b valid xml identifier see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute attribute element attribute doesn t value attribute value key attribute miss b precondition b valid xml identifier see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value get attribute value attribute looking up key hashtable attribute doesn t value correspond key p example value set contain mapping one 1 element contain attribute attr one then get attribute attr mapping key 1 attribute value set hash map mapping key set iterator value key key attribute miss allow literal literal are valid b precondition b valid xml identifier value set key set iterator value set are string value value set are string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literal get attribute value set key allow literal attribute element attribute doesn t 0 attribute b precondition b valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute 0 attribute element attribute doesn t value attribute value key attribute miss b precondition b valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value ignore upper value attribute get value value parse value number format e invalid value value get attribute value v get attribute value v v v attribute looking up key hashtable attribute doesn t value correspond key p example value set contain mapping one 1 element contain attribute attr one then get attribute attr mapping key 1 attribute value set hash map mapping key set iterator value key key attribute miss allow literal number literal number are valid b precondition b valid xml identifier value set key set iterator value set are string value value set are key eith key value set see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literal number ignore upper key attribute get result key key key result value set get key cast e invalid value set result allow literal number invalid value key result value key number format e invalid value key result value attribute element attribute doesn t 0 0 attribute b precondition b valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute 0 attribute element attribute doesn t value attribute value key attribute miss b precondition b valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value ignore upper value attribute get value value value value value number format e invalid value value attribute looking up key hashtable attribute doesn t value correspond key p example value set contain mapping one 1 0 element contain attribute attr one then get attribute attr mapping key 1 0 attribute value set hash map mapping key set iterator value key key attribute miss allow literal number literal number are valid b precondition b valid xml identifier value set key set iterator value set are string value value set are key eith key value set see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literal number ignore upper key attribute get result key key key result value set get key cast e invalid value set result allow literal number invalid value key result value key number format e invalid value key result value attribute element attribute doesn t value value attribute equal value value attribute equal value value doesn t match value value throw attribute value value associate value value associate value value attribute miss b precondition b valid xml identifier value value are different string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name get attribute value value value ignore upper value attribute get value value value equal value value equal value invalid value value get attribute value get attribute value element see #set set get read one xml element io reader pars reader reader which retrieve xml data b precondition b reader reader close b postcondition b state receiver update reflect xml element parse reader reader point first character last character xml element io i o occur reading input xml parse occur parse read data parse reader reader reader i o xml parse parse reader reader starting line nr 1 read one xml element io reader pars reader reader which retrieve xml data starting line nr line number first line data b precondition b reader reader close b postcondition b state receiver update reflect xml element parse reader reader point first character last character xml element io i o occur reading input xml parse occur parse read data parse reader reader reader starting line nr i o xml parse content attribute hash map child list read too much \0 reader reader parser line nr starting line nr ch scan whitespace ch expect input ch read ch || ch ? skip special tag 0 unread ch scan element read one xml element pars reader which retrieve xml data b precondition b length 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse xml parse parse reader reader starting line nr 1 i o e handling suxx read one xml element pars reader which retrieve xml data offset first character scan b precondition b offset lt length offset 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse offset xml parse parse substring offset read one xml element pars reader which retrieve xml data offset first character scan end character where stop scanning character scan b precondition b end lt length offset lt end offset 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse offset end xml parse parse substring offset end read one xml element pars reader which retrieve xml data offset first character scan end character where stop scanning character scan starting line nr line number first line data b precondition b end lt length offset lt end offset 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse offset end starting line nr xml parse substring offset end parse reader reader starting line nr i o e handling suxx read one xml element pars input reader which retrieve xml data offset first character scan end character where stop scanning character scan b precondition b input end lt input length offset lt end offset 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse input offset end xml parse parse input offset end starting line nr 1 read one xml element pars input reader which retrieve xml data offset first character scan end character where stop scanning character scan starting line nr line number first line data b precondition b input end lt input length offset lt end offset 0 b postcondition b state receiver update reflect xml element parse reader xml parse occur parse parse input offset end starting line nr xml parse reader reader reader input offset end parse reader reader starting line nr i o e nev happen remove child element child child element remove b precondition b child child child element receiver b postcondition b count child old count child 1 iterate child old iterate child child get child old iterate child child see #add child xml element add child xml element see #count child see #iterate child see #get child remove child xml element child child remove child remove attribute attribute b precondition b valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name get attribute remove attribute ignore upper attribute remove create similar xml element xml element create element xml element elem create element elem set elem create similar xml element p should override when subclass xml element xml element create element xml element entity ignore whitespace ignore change content content content set content content content content change element b precondition b valid xml identifier see #get set write xml element see #write io write output stream out output stream output stream output stream out write flush out i o e handling suxx write xml element write xml data b precondition b close io i o data could write see #to write i o write encode content write write attribute empty iterator it attribute key set iterator it ha next write key it next value attribute get key write key write write write encode value write content content length 0 write write encode content write write write write child empty write write write iterator it iterate child it ha next xml element child xml element it next child write write write write write write xml element indent element write xml data b precondition b close io i o data could write see #to 0 write xml element indent element write xml data b precondition b close indent indentation io i o data could write see #to indent write encode content space indent 2 array fill space write space write write attribute empty iterator enm attribute key set iterator enm ha next write key enm next value attribute get key write key write write write encode value write content content length 0 write write encode content write write write write child empty write write write write iterator enm get child iterator enm ha next xml element child xml element enm next child indent + 1 write space write write write write write i o e internal internal e get message init cause e write encode write xml data str write encode b precondition b close str write encode str i o i 0 i str length i + 1 ch str at i ch write write l write t write write write g write t write write write write m write p write write write q write u write o write t write \ write write write p write o write s write ch 32 || 126 write write # write x write 16 write write ch scan identifier current reader scan identifier append result result buffer which scan identifier put b precondition b result next character read reader valid first character xml identifier b postcondition b next character read reader won t identifier character scan identifier buffer result i o ch read ch || ch z ch || ch z ch 0 || ch 9 ch ch ch ch ch \u007 e unread ch result append ch scan identifier current reader next character whitespace scan whitespace i o ch read ch \r ch scan identifier current reader scan whitespace append result next character whitespace b precondition b result scan whitespace buffer result i o ch read ch result append ch \r ch scan delimit current reader scan delimiter append b precondition b next read delimit scan buffer i o delimit read delimit \ delimit expect input \ ch read ch delimit ch resolve entity append ch scan # p d t element d t section entity are resolve next lt skip scan data append data b precondition b data scan p data buffer data i o ch read ch ch read ch check d t data unread ch ch resolve entity data data append ch scan special tag tag d t section append it content buf b precondition b buf first lt ha already be read check d t buffer buf i o ch read ch unread ch skip special tag 0 check literal d t skip special tag 1 one ha already be read delimit char skip 0 delimit char skip 3 ch read ch delimit char skip 2 delimit char skip + 1 buf append buf append delimit char skip 0 delimit char skip 2 i 0 i delimit char skip i++ buf append delimit char skip 0 buf append delimit char skip 3 i 0 i delimit char skip i + 1 buf append buf append ch delimit char skip 0 skip comment b precondition b first lt ha already be read skip comment i o dash read 2 dash read 0 ch read ch dash read 1 dash read 2 read expect input skip special tag comment bracket level number open square bracket have already be read b precondition b first lt ha already be read bracket level 0 skip special tag bracket level i o tag level 1 delimit \0 bracket level 0 ch read ch bracket level + 1 ch ch read ch bracket level + 1 ch bracket level 1 ch skip comment tag level 0 ch read delimit \0 ch || ch \ delimit ch bracket level 0 ch tag level + 1 ch tag level 1 ch bracket level + 1 ch bracket level 1 ch delimit delimit \0 scan data literal text scanning stop when character doe match after complete text ha be check whichev come first literal literal check b precondition b literal check literal literal i o length literal length i 0 i length i + 1 read literal at i read character reader read i o read too much \0 ch read too much read too much \0 ch i reader read i 0 unexpect end data i 10 parser line nr + 1 i scan xml element elt element contain result b precondition b first lt ha already be read elt scan element xml element elt i o buffer buf buffer scan identifier buf buf elt set ch scan whitespace ch ch buf set length 0 unread ch scan identifier buf key buf ch scan whitespace ch expect input unread scan whitespace buf set length 0 scan buf elt set attribute key buf ch scan whitespace ch ch read ch expect input buf set length 0 ch scan whitespace buf ch unread ch scan p data buf ch read ch check d t buf scan p data buf ch scan whitespace buf ch unread ch scan p data buf ch || ignore whitespace buf set length 0 ch unread ch buf length 0 ch ch ch read ch expect input comment element ch read ch expect input comment element skip comment unread ch xml element child create element scan element child elt add child child ch scan whitespace ch expect input ch read unread ch ignore whitespace elt set content buf trim elt set content buf ch read ch expect input unread scan whitespace check literal expect input scan whitespace expect input resolve entity entity read reader value entity append buf buf where put entity value b precondition b first amp ha already be read buf resolve entity buffer buf i o ch \0 buffer key buf buffer ch read ch key buf append ch key key buf key at 0 # key at 1 x ch parse key substring 2 16 ch parse key substring 1 10 number format e unknown entity key buf append ch value entity get key value unknown entity key buf append value push character back read back buffer ch character push back b precondition b read back buffer empty ch \0 unread ch read too much ch create parse when invalid valueset given entity b precondition b xml parse invalid value set msg invalid value set entity \ + + \ xml parse get parser line nr msg create parse when invalid value given entity value value entity b precondition b value xml parse invalid value value msg attribute \ + + \ doe contain valid + value \ + value + \ xml parse get parser line nr msg create parse when end data input ha be reach xml parse unexpect end data msg unexpect end data reach xml parse get parser line nr msg create parse when syntax occur context context which occur b precondition b context context length 0 xml parse syntax context msg syntax parse + context xml parse get parser line nr msg create parse when next character read character wa expect set set human readable form wa expect b precondition b set set length 0 xml parse expect input set msg expect + set xml parse get parser line nr msg create parse when entity could resolve entity b precondition b length 0 xml parse unknown entity msg unknown invalid entity + + xml parse get parser line nr msg 