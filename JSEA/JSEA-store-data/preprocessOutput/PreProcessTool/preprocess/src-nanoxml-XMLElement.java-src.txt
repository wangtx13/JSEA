wern randelshof 2006 05 26 replace 1 1 collection by 1 2 collection remove all deprecate add create element name add get attribute name min max value add get attribute name value add print writer w write encode can be change to not encode unicode character 2006 05 02 xml element $ revision 1 4 $ $ date 2002 03 24 10 27 59 $ $ name r e l e a s e 2 2 1 $ is part of nano xml 2 lite copyright c 2000 2002 marc de scheemaeck all right reserve software is provide a is without any express or imply warranty in no event will the author be hold liable any damage arise from the use of software permission is grant to anyone to use software any purpose include commercial application and to alter it and redistribute it freely subject to the following restriction 1 the origin of software must not be misrepresent you must not claim that you write the original software you use software in a product an acknowledgment in the product documentation would be appreciate but is not require 2 alter source version must be plainly mark a such and must not be misrepresent a being the original software 3 notice may not be remove or alter from any source distribution nanoxml io xml element is a representation of an xml the is able to parse xml p d l d t b parse xml data b d t d d you can parse xml data using the following u l c o d e xml element xml xml element b r reader reader reader filename xml b r xml parse from reader reader c o d e u l d d d l d l d t b retrieve attribute b d t d d you can enumerate the attribute of an element using the link #enumerate attribute name enumerate attribute name the attribute value can be retrieve using the link #get attribute get attribute the following example show how to list the attribute of an element u l c o d e xml element element b r iterator it element get attribute name b r it ha next b r key it next b r value element get attribute key b r out key + + value b r c o d e u l d d d l d l d t b retrieve child element b d t d d you can enumerate the child of an element using link #iterate child iterate child the number of child iterator can be retrieve using link #count child count child d d d l d l d t b element contain character data b d t d d an iterator contain character data like in the following example u l c o d e lt title the title lt title c o d e u l you can retrieve that data using the link #get content get content d d d l d l d t b subclass xml element b d t d d when subclass xml element you need to override the link #create element create element which ha to a copy of the receiver d d d l p author marc de scheemaeck lt a href mailto cyberelf mac com cyberelf mac com a 2005 06 18 wern randelshof adapt 2 collection a p i $ name r e l e a s e 2 2 1 $ $ revision 1 4 $ see nanoxml xml parse xml element serialization serial serial u 6685035139346394777 l major of nano xml class with the same major and minor are binary compatible class with the same major are source compatible the major is different you may need to modify the client source see # n a n o xml m i n o r v e r s i o n n a n o xml m a j o r v e r s i o n 2 minor of nano xml class with the same major and minor are binary compatible class with the same major are source compatible the major is different you may need to modify the client source see # n a n o xml m a j o r v e r s i o n n a n o xml m i n o r v e r s i o n 2 the attribute given to the element b invariant b the field can be empty the field is nev the key set iterator and the value are string hash map attribute child iterator of the element b invariant b the field can be empty the field is nev the iterator are instance of xml element or a subclass of xml element list child the name of the element b invariant b the field is iff the element is not initialize by eith parse or set name the field is not it s not empty the field is not it contain a valid xml identifier name the # p c d a t a content of the b invariant b the field is iff the element is not a # p c d a t a element the field can be any include the empty content conversion table amp entity the key set iterator are the entity name without the amp and delimiter b invariant b the field is nev the field alway contain the following association lt lt \ apo amp amp the key set iterator are string the value are array hash map entity the line number where the element start b invariant b line nr 0 line nr the of the element and attribute name are insensitive ignore the leading and trailing whitespace of # p c d a t a section have to be ignore ignore whitespace character read too much character provide push back functionality to the input reader without have to use a pushback reader there is no such character field is \0 read too much the reader provide by the caller of the parse b invariant b the field is not the parse is running reader reader the current line number in the source content b invariant b parser line nr 0 the parse is running parser line nr wern randelshof variable is set to unicode character are not encode into entity the encoding is left to the underlie writer is encode unicode character create and initializ a xml element calling the construction is equivalent to xml element hash map b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see # xml element hash map xml element hash map see # xml element see # xml element hash map xml element hash map xml element hash map create and initializ a xml element calling the construction is equivalent to xml element entity entity the entity conversion table b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see # xml element see # xml element see # xml element hash map xml element hash map xml element hash map entity entity create and initializ a xml element calling the construction is equivalent to xml element hash map skip leading whitespace skip leading whitespace leading and trailing whitespace in p c d a t a content ha to be remove b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see # xml element see # xml element hash map xml element hash map see # xml element hash map xml element hash map xml element skip leading whitespace hash map skip leading whitespace create and initializ a xml element calling the construction is equivalent to xml element entity skip leading whitespace entity the entity conversion table skip leading whitespace leading and trailing whitespace in p c d a t a content ha to be remove b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see # xml element see # xml element see # xml element hash map xml element hash map xml element hash map entity skip leading whitespace entity skip leading whitespace create and initializ a xml element entity the entity conversion table skip leading whitespace leading and trailing whitespace in p c d a t a content ha to be remove ignore the of element and attribute name have to be ignore b precondition b entity b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see # xml element see # xml element see # xml element hash map xml element hash map see # xml element hash map xml element hash map xml element hash map entity skip leading whitespace ignore entity skip leading whitespace ignore create and initializ a xml element p constructor should i only i be call from link #create element create element to create child iterator entity the entity conversion table skip leading whitespace leading and trailing whitespace in p c d a t a content ha to be remove fill basic conversion table the basic entity need to be add to the entity list ignore the of element and attribute name have to be ignore b precondition b entity fill basic conversion table then entity contain at least the following entry amp lt apo and b postcondition b count child 0 iterate child empty enumeration enumerate property name empty enumeration get child empty vector get content get line nr 0 get name see #create element xml element hash map entity skip leading whitespace fill basic conversion table ignore entity skip leading whitespace fill basic conversion table ignore xml element hash map entity skip leading whitespace fill basic conversion table ignore encode unicode character ignore whitespace skip leading whitespace ignore ignore name content attribute hash map child list entity entity line nr 0 is encode unicode character encode unicode character iterator it entity key set iterator it ha next key it next value entity get key value value value to entity put key value fill basic conversion table entity put amp entity put entity put apo \ entity put lt entity put add a child element child the child element to add b precondition b child child get name child doe not have a parent element b postcondition b count child old count child + 1 iterate child old iterate child + child get child old iterate child + child see #count child see #iterate child see #get child see #remove child nanoxml xml element remove child xml element add child xml element child child add child add or modifie an attribute name the name of the attribute value the value of the attribute b precondition b name name is a valid xml identifier value b postcondition b enumerate attribute name old enumerate attribute name + name get attribute name value set attribute name value ignore name name to upper attribute put name value to add or modifie an attribute name the name of the attribute value the value of the attribute b precondition b name name is a valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name + name get attribute name value set attribute name value ignore name name to upper attribute put name to value add or modifie an attribute name the name of the attribute value the value of the attribute b precondition b name name is a valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name + name get attribute name value set attribute name value ignore name name to upper attribute put name to value the number of child iterator of the element b postcondition b result 0 see #add child nanoxml xml element add child xml element see #iterate child see #get child see #remove child nanoxml xml element remove child xml element count child child size enumerate the attribute name b postcondition b result iterator enumerate attribute name attribute key set iterator enumerate the child iterator b postcondition b result iterator iterate child child iterator the child iterator a a list it is safe to modify list b postcondition b result see #add child nanoxml xml element add child xml element see #count child see #iterate child see #remove child nanoxml xml element remove child xml element list get child list child clone e nev happen howev some compiler are so braindead that they require clause the p c d a t a content of the there is no such content c o d e c o d e is see #set content set content get content content the line nr in the source data on which the element is found 0 there is no associate source data b postcondition b result 0 get line nr line nr an attribute of the element the attribute doesn t is name the name of the attribute b precondition b name name is a valid xml identifier get attribute name get attribute name an attribute of the element the attribute doesn t value is name the name of the attribute value key to use the attribute is miss b precondition b name name is a valid xml identifier get attribute name value ignore name name to upper value attribute get name value value value value an attribute by looking up a key in a hashtable the attribute doesn t the value correspond to key is p a an example value set contain the mapping one 1 and the element contain the attribute attr one then get attribute attr mapping key 1 name the name of the attribute value set hash map mapping key set iterator to value key key to use the attribute is miss allow literal literal are valid b precondition b name name is a valid xml identifier value set the key set iterator of value set are string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute name map value set key allow literal ignore name name to upper key attribute get name result key key key result value set get key result allow literal result key invalid value name key result an attribute of the element the attribute doesn t is name the name of the attribute b precondition b name name is a valid xml identifier see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name get attribute name an attribute of the element the attribute doesn t value is name the name of the attribute value key to use the attribute is miss b precondition b name name is a valid xml identifier see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name value get attribute name value an attribute by looking up a key in a hashtable the attribute doesn t the value correspond to key is p a an example value set contain the mapping one 1 and the element contain the attribute attr one then get attribute attr mapping key 1 name the name of the attribute value set hash map mapping key set iterator to value key key to use the attribute is miss allow literal literal are valid b precondition b name name is a valid xml identifier value set the key set iterator of value set are string the value of value set are string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute name hash map value set key allow literal get attribute name value set key allow literal an attribute of the element the attribute doesn t 0 is name the name of the attribute b precondition b name name is a valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name get attribute name 0 an attribute of the element the attribute doesn t value is name the name of the attribute value key to use the attribute is miss b precondition b name name is a valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name value ignore name name to upper value attribute get name value value parse value number format e invalid value name value get attribute name min max value v get attribute name value v min min v max max v an attribute by looking up a key in a hashtable the attribute doesn t the value correspond to key is p a an example value set contain the mapping one 1 and the element contain the attribute attr one then get attribute attr mapping key 1 name the name of the attribute value set hash map mapping key set iterator to value key key to use the attribute is miss allow literal number literal number are valid b precondition b name name is a valid xml identifier value set the key set iterator of value set are string the value of value set are key is eith a key in value set or an see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute name hash map value set key allow literal number ignore name name to upper key attribute get name result key key key result value set get key cast e invalid value set name result allow literal number invalid value name key result value of key number format e invalid value name key result value an attribute of the element the attribute doesn t 0 0 is name the name of the attribute b precondition b name name is a valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name get attribute name 0 an attribute of the element the attribute doesn t value is name the name of the attribute value key to use the attribute is miss b precondition b name name is a valid xml identifier see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute name value ignore name name to upper value attribute get name value value value of value value number format e invalid value name value an attribute by looking up a key in a hashtable the attribute doesn t the value correspond to key is p a an example value set contain the mapping one 1 0 and the element contain the attribute attr one then get attribute attr mapping key 1 0 name the name of the attribute value set hash map mapping key set iterator to value key key to use the attribute is miss allow literal number literal number are valid b precondition b name name is a valid xml identifier value set the key set iterator of value set are string the value of value set are key is eith a key in value set or a see #set attribute set attribute see #enumerate attribute name see #get attribute get attribute see #get attribute get attribute get attribute name hash map value set key allow literal number ignore name name to upper key attribute get name result key key key result value set get key cast e invalid value set name result allow literal number invalid value name key result value of key number format e invalid value name key result value an attribute of the element the attribute doesn t value is the value of the attribute is equal to value is the value of the attribute is equal to value is the value doesn t match value or value an is throw name the name of the attribute value the value associate with value the value associate with value value to use the attribute is miss b precondition b name name is a valid xml identifier value and value are different string see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute name get attribute name value value value ignore name name to upper value attribute get name value value value equal value value equal value invalid value name value get attribute name value get attribute name value the name of the element see #set name set name get name name read one xml element from a io reader and pars it reader the reader from which to retrieve the xml data b precondition b reader reader is not close b postcondition b the state of the receiver is update to reflect the xml element parse from the reader the reader point to the first character following the last character of the xml element io i o an occur reading the input nanoxml xml parse an occur parse the read data parse from reader reader reader i o xml parse parse from reader reader starting line nr 1 read one xml element from a io reader and pars it reader the reader from which to retrieve the xml data starting line nr the line number of the first line in the data b precondition b reader reader is not close b postcondition b the state of the receiver is update to reflect the xml element parse from the reader the reader point to the first character following the last character of the xml element io i o an occur reading the input nanoxml xml parse an occur parse the read data parse from reader reader reader starting line nr i o xml parse name content attribute hash map child list read too much \0 reader reader parser line nr starting line nr ch scan whitespace ch expect input ch read ch || ch ? skip special tag 0 unread ch scan element read one xml element from a and pars it the reader from which to retrieve the xml data b precondition b length 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse xml parse parse from reader reader starting line nr 1 i o e handling suxx read one xml element from a and pars it the reader from which to retrieve the xml data offset the first character in to scan b precondition b offset lt length offset 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse offset xml parse parse substring offset read one xml element from a and pars it the reader from which to retrieve the xml data offset the first character in to scan end the character where to stop scanning character is not scan b precondition b end lt length offset lt end offset 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse offset end xml parse parse substring offset end read one xml element from a and pars it the reader from which to retrieve the xml data offset the first character in to scan end the character where to stop scanning character is not scan starting line nr the line number of the first line in the data b precondition b end lt length offset lt end offset 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse offset end starting line nr xml parse substring offset end parse from reader reader starting line nr i o e handling suxx read one xml element from a and pars it input the reader from which to retrieve the xml data offset the first character in to scan end the character where to stop scanning character is not scan b precondition b input end lt input length offset lt end offset 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse input offset end xml parse parse input offset end starting line nr 1 read one xml element from a and pars it input the reader from which to retrieve the xml data offset the first character in to scan end the character where to stop scanning character is not scan starting line nr the line number of the first line in the data b precondition b input end lt input length offset lt end offset 0 b postcondition b the state of the receiver is update to reflect the xml element parse from the reader nanoxml xml parse an occur parse the parse input offset end starting line nr xml parse reader reader reader input offset end parse from reader reader starting line nr i o e will nev happen remove a child element child the child element to remove b precondition b child child is a child element of the receiver b postcondition b count child old count child 1 iterate child old iterate child child get child old iterate child child see #add child nanoxml xml element add child xml element see #count child see #iterate child see #get child remove child xml element child child remove child remove an attribute name the name of the attribute b precondition b name name is a valid xml identifier b postcondition b enumerate attribute name old enumerate attribute name name get attribute name remove attribute name ignore name name to upper attribute remove name create a similar xml element xml element create element name xml element elem create element elem set name name elem create a similar xml element p you should override when subclass xml element xml element create element xml element entity ignore whitespace ignore is encode unicode character change the content content the content set content content content content change the name of the element name the name b precondition b name name is a valid xml identifier see #get name set name name name name write the xml element to a see #write io writer write writer to output stream out output stream output stream writer writer output stream writer out write writer writer flush out to i o e handling suxx to write the xml element to a writer writer the writer to write the xml data to b precondition b writer writer is not close io i o the data could not be write to the writer see #to write writer writer i o name write encode writer content writer write writer write name attribute is empty iterator it attribute key set iterator it ha next writer write key it next value attribute get key writer write key writer write writer write write encode writer value writer write content content length 0 writer write write encode writer content writer write writer write writer write name writer write child is empty writer write writer write writer write iterator it iterate child it ha next xml element child xml element it next child write writer writer write writer write writer write name writer write write the xml element to a print writer and indent the element writer the writer to write the xml data to b precondition b writer writer is not close io i o the data could not be write to the writer see #to print print writer writer print writer 0 write the xml element to a print writer and indent the element writer the writer to write the xml data to b precondition b writer writer is not close indent the indentation io i o the data could not be write to the writer see #to print print writer writer indent name write encode writer content space indent 2 array fill space writer write space writer write writer write name attribute is empty iterator enm attribute key set iterator enm ha next writer write key enm next value attribute get key writer write key writer write writer write write encode writer value writer write content content length 0 writer write write encode writer content writer write writer write writer write name writer write child is empty writer write writer write writer write writer write iterator enm get child iterator enm ha next xml element child xml element enm next child print writer indent + 1 writer write space writer write writer write writer write name writer write writer write i o e internal internal e get message init cause e write a encode to a writer writer the writer to write the xml data to str the to write encode b precondition b writer writer is not close str write encode writer writer str i o i 0 i str length i + 1 ch str at i ch writer write writer write l writer write t writer write writer write writer write g writer write t writer write writer write writer write a writer write m writer write p writer write writer write writer write q writer write u writer write o writer write t writer write \ writer write writer write a writer write p writer write o writer write s writer write unicode ch unicode 32 || is encode unicode character unicode 126 writer write writer write # writer write x writer write to unicode 16 writer write writer write ch scan an identifier from the current reader the scan identifier is append to result result the buffer in which the scan identifier will be put b precondition b result the next character read from the reader is a valid first character of an xml identifier b postcondition b the next character read from the reader won t be an identifier character scan identifier buffer result i o ch read ch a || ch z ch a || ch z ch 0 || ch 9 ch ch ch ch ch \u007 e unread ch result append ch scan an identifier from the current reader the next character following the whitespace scan whitespace i o ch read ch \r ch scan an identifier from the current reader the scan whitespace is append to result the next character following the whitespace b precondition b result scan whitespace buffer result i o ch read ch result append ch \r ch scan a delimit from the current reader the scan without delimiter is append to b precondition b the next read is the delimit scan buffer i o delimit read delimit \ delimit expect input or \ ch read ch delimit ch resolve entity append ch scan a # p c d a t a element c d a t a section and entity are resolve the next lt is skip the scan data is append to data b precondition b data scan p c data buffer data i o ch read ch ch read ch check c d a t a data unread ch ch resolve entity data data append ch scan a special tag and the tag is a c d a t a section append it content to buf b precondition b buf the first lt ha already be read check c d a t a buffer buf i o ch read ch unread ch skip special tag 0 check literal c d a t a skip special tag 1 one ha already be read delimit char skip 0 delimit char skip 3 ch read ch delimit char skip 2 delimit char skip + 1 buf append buf append delimit char skip 0 delimit char skip 2 i 0 i delimit char skip i++ buf append delimit char skip 0 buf append delimit char skip 3 i 0 i delimit char skip i + 1 buf append buf append ch delimit char skip 0 skip a comment b precondition b the first lt ha already be read skip comment i o dash to read 2 dash to read 0 ch read ch dash to read 1 dash to read 2 read expect input skip a special tag or comment bracket level the number of open square bracket that have already be read b precondition b the first lt ha already be read bracket level 0 skip special tag bracket level i o tag level 1 delimit \0 bracket level 0 ch read ch bracket level + 1 ch ch read ch bracket level + 1 ch bracket level 1 ch skip comment tag level 0 ch read delimit \0 ch || ch \ delimit ch bracket level 0 ch tag level + 1 ch tag level 1 ch bracket level + 1 ch bracket level 1 ch delimit delimit \0 scan the data literal text scanning stop when a character doe not match or after the complete text ha be check whichev come first literal the literal to check b precondition b literal check literal literal i o length literal length i 0 i length i + 1 read literal at i read a character from a reader read i o read too much \0 ch read too much read too much \0 ch i reader read i 0 unexpect end of data i 10 parser line nr + 1 i scan an xml element elt the element that will contain the result b precondition b the first lt ha already be read elt scan element xml element elt i o buffer buf buffer scan identifier buf name buf to elt set name name ch scan whitespace ch ch buf set length 0 unread ch scan identifier buf key buf to ch scan whitespace ch expect input unread scan whitespace buf set length 0 scan buf elt set attribute key buf ch scan whitespace ch ch read ch expect input buf set length 0 ch scan whitespace buf ch unread ch scan p c data buf ch read ch check c d a t a buf scan p c data buf ch scan whitespace buf ch unread ch scan p c data buf ch || ignore whitespace buf set length 0 ch unread ch buf length 0 ch ch ch read ch expect input comment or element ch read ch expect input comment or element skip comment unread ch xml element child create element scan element child elt add child child ch scan whitespace ch expect input ch read unread ch ignore whitespace elt set content buf to trim elt set content buf to ch read ch expect input unread scan whitespace check literal name expect input name scan whitespace expect input resolve an entity the name of the entity is read from the reader the value of the entity is append to buf buf where to put the entity value b precondition b the first amp ha already be read buf resolve entity buffer buf i o ch \0 buffer key buf buffer ch read ch key buf append ch key key buf to key at 0 # key at 1 x ch parse key substring 2 16 ch parse key substring 1 10 number format e unknown entity key buf append ch value entity get key value unknown entity key buf append value push a character back to the read back buffer ch the character to push back b precondition b the read back buffer is empty ch \0 unread ch read too much ch create a parse when an invalid valueset is given to a name the name of the entity b precondition b name xml parse invalid value set name msg invalid value set entity name \ + name + \ xml parse get name parser line nr msg create a parse when an invalid value is given to a name the name of the entity value the value of the entity b precondition b name value xml parse invalid value name value msg attribute \ + name + \ doe not contain a valid + value \ + value + \ xml parse get name parser line nr msg create a parse when the end of the data input ha be reach xml parse unexpect end of data msg unexpect end of data reach xml parse get name parser line nr msg create a parse when a syntax occur context the context in which the occur b precondition b context context length 0 xml parse syntax context msg syntax parse + context xml parse get name parser line nr msg create a parse when the next character read is not the character that wa expect set the set of character in human readable form that wa expect b precondition b set set length 0 xml parse expect input set msg expect + set xml parse get name parser line nr msg create a parse when an entity could not be resolve name the name of the entity b precondition b name name length 0 xml parse unknown entity name msg unknown or invalid entity + name + xml parse get name parser line nr msg 