# bezi path 1 1 2006 03 22 1996 2006 it contributor disclose accordance geom geom bezi path allow construction path consist straight line quadratic curve cubic curve p bezi path represent geometric path construct vertex each node ha three control point c0 c1 c2 mask define which control point are path pass through c0 c1 control curve going toward c0 c2 control curve going away c0 author 1 1 2006 03 22 move line quad 1 0 january 20 2006 create bezi path list bezi path node shape constant control point c1 c1 m s k 1 constant control point c2 c2 m s k 2 convenience constant control point c1 c2 c1 c2 m s k c1 m s k | c2 m s k we cache general path instance speed up shape operation general path general path we cache index outermost node speed up index outermost node out 1 value set close bezi path close define vertex node bezi path p vertex consist three control point c0 c1 c2 bezi path alway pass through c0 c1 use control curve toward c0 c2 use control curve going away c0 node cloneable mask use describe which control point addition c0 are effect mask 0 control point x coordinate x 3 control point y coordinate y 3 hint editing tool set editing tool keep control point on same line keep colinear node mask 1 node node set set node mask mask keep colinear keep colinear arraycopy x 0 x 0 3 arraycopy y 0 y 0 3 node point2 d c0 mask 0 x 0 c0 x y 0 c0 y x 1 c0 x y 1 c0 y x 2 c0 x y 2 c0 y node mask point2 d c0 point2 d c1 point2 d c2 mask mask x 0 c0 x y 0 c0 y x 1 c1 x y 1 c1 y x 2 c2 x y 2 c2 y node x0 y0 mask 0 x 0 x0 y 0 y0 x 1 x0 y 1 y0 x 2 x0 y 2 y0 node mask x0 y0 x1 y1 x2 y2 mask mask x 0 x0 y 0 y0 x 1 x1 y 1 y1 x 2 x2 y 2 y2 get mask mask set mask value mask value set control point index point2 d p x index p x y index p y point2 d get control point index point2 d x index y index move point2 d p move p x x 0 p y y 0 move x y move x x 0 y y 0 move dx dy i 0 i 3 i++ x i + dx y i + dy clone node node clone x x clone y y clone clone support e internal internal init cause e builder buf builder buf append i 0 i 3 i++ i 0 mask i i buf append buf append x buf append i buf append buf append x i buf append y buf append i buf append buf append y i buf append buf create instance bezi path convenience add control point single coordinate c0 add point2 d c0 add node 0 c0 c0 c0 add point x y add node 0 x y x y x y convenience add control point three coordinate c0 c1 c2 mask add mask point2 d c0 point2 d c1 point2 d c2 add node mask c0 c1 c2 convenience change single coordinate control point set index coord point2 d p node get index x coord p x y coord p y convenience getting single coordinate control point point2 d get index coord node get index point2 d x coord y coord call after bezi path ha be invalidate path general path out 1 recompute bezi path invalid validate path general path general path general path convert bezi path general path general path general path general path gp general path gp set winding rule general path i n d e v e n o d d size 0 gp move 0 0 gp line 0 0 + 1 size 1 node current get 0 gp move current x 0 current y 0 gp line current x 0 current y 0 + 1 node previou node current previou current get 0 gp move current x 0 current y 0 i 1 n size i n i++ previou current current get i previou mask c2 m s k 0 current mask c1 m s k 0 gp line current x 0 current y 0 gp quad current x 1 current y 1 current x 0 current y 0 current mask c1 m s k 0 gp quad previou x 2 previou y 2 current x 0 current y 0 gp curve previou x 2 previou y 2 current x 1 current y 1 current x 0 current y 0 close size 1 previou get size 1 current get 0 previou mask c2 m s k 0 current mask c1 m s k 0 gp line current x 0 current y 0 gp quad current x 1 current y 1 current x 0 current y 0 current mask c1 m s k 0 gp quad previou x 2 previou y 2 current x 0 current y 0 gp curve previou x 2 previou y 2 current x 1 current y 1 current x 0 current y 0 gp close path gp contain point2 d p validate path general path contain p outline bezi path contain specify point p point test tolerance tolerance test outline contain point2 d p tolerance validate path path iterator i general path get path iterator affine transform tolerance coord 6 type i current segment coord prev x coord 0 prev y coord 1 i next i do i current segment coord geom line contain point prev x prev y coord 0 coord 1 p x p y tolerance prev x coord 0 prev y coord 1 i next intersect rectangle2 d r validate path general path intersect r path iterator get path iterator affine transform at validate path general path get path iterator at contain rectangle2 d r validate path general path contain r path iterator get path iterator affine transform at flatness validate path general path get path iterator at flatness intersect x y h validate path general path intersect x y h rectangle2 d get bounds2 d validate path general path get bounds2 d rectangle2 d get bounds2 d validate path rectangle2 d r general path get bounds2 d r rectangle2 d rectangle2 d r rectangle2 d r get x r get y r get width r get height rectangle get bound validate path general path get bound contain x y h validate path general path contain x y h contain x y validate path general path contain x y set close value close value close value invalidate path close close create deep copy bezi path clone bezi path bezi path clone i 0 n size i n i++ set i node get i clone transform bezi path tx transformation transform affine transform tx point2 d p point2 d node cp i 0 i 3 i++ p x cp x i p y cp y i tx transform p p cp x i p x cp y i p y invalidate path set bezi path size size remove size 1 i 0 n size i n i++ get i set get i size size add node get size clone point at center bezi path point2 d get center sx 0 sy 0 node p sx + p x 0 sy + p y 0 n size point2 d sx n sy n point on edge bezi path which cross line center bezi path specify point edge cross line near c0 control point point2 d chop point2 d p validate path geom chop general path p point2 d ctr get center chop point cx 1 cy 1 len m x v l u e point along edge validate path path iterator i general path get path iterator affine transform 1 coord 6 type i current segment coord prev x coord 0 prev y coord 1 i next i do i next i current segment coord point2 d chop geom intersect prev x prev y coord 0 coord 1 p x p y ctr x ctr y chop cl geom length2 chop x chop y p x p y cl len len cl cx chop x cy chop y prev x coord 0 prev y coord 1 close size 1 node first get 0 node last get size 1 point2 d chop geom intersect first x 0 first y 0 last x 0 last y 0 p x p y ctr x ctr y chop cl geom length2 chop x chop y p x p y cl len len cl cx chop x cy chop y none found pick close vertex len m x v l u e j 0 n size j n j++ node cp get j l geom length2 cp x 0 cp y 0 p x p y l len len l cx cp x 0 cy cp y 0 point2 d cx cy index control point furthest center index outermost node out 1 point2 d ctr get center out 0 dist 0 i 0 n size i n i++ node cp get i d geom length2 ctr x ctr y cp x 0 cp y 0 d dist dist d out i out relative point on path where 0 start point path 1 end point path relative value between 0 1 point2 d get point on path relative flatness size 0 size 1 get 0 get control point 0 relative 0 get 0 get control point 0 relative 1 get size 1 get control point 0 validate path determine length path len 0 path iterator i general path get path iterator affine transform flatness coord 6 type i current segment coord prev x coord 0 prev y coord 1 i next i do i next i current segment coord len + geom length prev x prev y coord 0 coord 1 prev x coord 0 prev y coord 1 compute relative point on path relative len len relative po 0 i general path get path iterator affine transform flatness type i current segment coord prev x coord 0 prev y coord 1 i next i do i next i current segment coord seg len geom length prev x prev y coord 0 coord 1 po + seg len relative len point2 d coord 0 coord 1 compute relative point2 d on line point2 d prev x po len + coord 0 po + seg len len prev y po len + coord 1 po + seg len len factor relative len po seg len point2 d prev x 1 factor + coord 0 factor prev y 1 factor + coord 1 factor po + seg len prev x coord 0 prev y coord 1 internal we should nev get here get segment polyline hit given point2 d index segment 1 segment wa hit find segment point2 d find tolerance x x x work straight line node v1 v2 bezi path temp path bezi path node t1 t2 temp path add t1 node temp path add t2 node i 0 n size 1 i n i++ v1 get i v2 get i+1 v1 mask 0 v2 mask 0 geom line contain point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance i t1 set v1 t2 set v2 temp path invalidate path temp path outline contain find tolerance i close size 1 v1 get size 1 v2 get 0 v1 mask 0 v2 mask 0 geom line contain point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance size 1 t1 set v1 t2 set v2 temp path invalidate path temp path outline contain find tolerance size 1 1 join two segment one given point2 d hit node bezi path index join segment 1 segment wa join join segment point2 d join tolerance i 0 i size i++ node p get i geom length p x 0 p y 0 join x join y tolerance remove i i 1 split segment at given point2 d segment wa hit index segment 1 segment wa hit split segment point2 d split tolerance i find segment split tolerance next i i + 1 % size i 1 get i mask c2 m s k c2 m s k get next i mask c1 m s k 0 quadto add i + 1 node c2 m s k split split split get i mask c2 m s k 0 get next i mask c1 m s k c1 m s k quadto add i + 1 node c2 m s k split split split get i mask c2 m s k c2 m s k get next i mask c1 m s k c2 m s k cubicto add i + 1 node c1 m s k | c2 m s k split split split lineto add i + 1 node split i+1 move x1 y1 size 0 illegal path state move allow when empty add node x1 y1 line x1 y1 size 0 illegal path state line allow when empty add node x1 y1 quad x1 y1 x2 y2 size 0 illegal path state quad allow when empty add node c1 m s k x2 y2 x1 y1 x2 y2 curve x1 y1 x2 y2 x3 y3 size 0 illegal path state curve allow when empty node last point get size 1 last point mask | c2 m s k last point x 2 x1 last point y 2 y1 add node c1 m s k x3 y3 x2 y2 x3 y3 point2 d polygon point2 d point point2 d size i 0 n size i n i++ point i point2 d get i x 0 get i y 0 point 