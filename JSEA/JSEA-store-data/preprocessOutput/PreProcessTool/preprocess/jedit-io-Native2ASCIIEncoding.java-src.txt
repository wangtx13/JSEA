j edit programmer s text editor tab size 8 indent size 8 no tabs folding explicit collapse folds 1 copyright ?? 2012 j edit contributors program is free software you can redistribute it and or modify it under the terms of the g n u general license as published by the free software foundation either 2 of the license or any later program is distributed in the hope that it will be useful but w i t h o u t a n y w a r r a n t y without even the implied warranty of m e r c h a n t a b i l i t y or f i t n e s s f o r a p a r t i c u l a r p u r p o s e see the g n u general license more details you should have received a copy of the g n u general license along with program not write to the free software foundation inc 59 temple place suite 330 boston m a 02111 1307 u s a org jedit io importsimport io filter reader io filter writer io i o io input stream io output stream io pushback reader io reader io writer reflect invocation target buffer charset charset charset charset encoder charset malformed input annotation nonnull annotation nullable org gjt sp jedit io charset encoding org gjt sp jedit io encoding i s o 8859 1 with unicode escapes as e g needed http download oracle com javase 6 docs api properties html author bj??rn vampire kautler since 5 1pre1 native2 a s c i i encoding encoding encoding nonnull reader get text reader nonnull input stream in i o native2 a s c i i reader in nonnull writer get text writer nonnull output stream out i o filter writer ascii encoding get text writer out override nonnull writer append nullable sequence csq i o write csq ? csq to override nonnull writer append nullable sequence csq start end i o sequence cs csq ? csq write cs sub sequence start end to override nonnull writer append c i o write c override write nonnull str i o write str 0 str length override write nonnull cbuf i o write cbuf 0 cbuf length override write nonnull str off len i o write str substring off off + len to override write nonnull cbuf off len i o buf len 6 i 0 j off j2 off + len j j2 j++ c cbuf j ascii encoder can encode c buf i++ c arraycopy format \\u%04 x c to 0 buf i 6 i + 6 write buf 0 i override write c i o ascii encoder can encode c write c write format \\u%04 x c nonnull reader get permissive text reader nonnull input stream in i o native2 a s c i i reader in members nonnull reader get text reader nonnull input stream in nullable ? pushback reader clazz i o invocation target no such instantiation illegal access native2 a s c i i reader in clazz nonnull reader get permissive text reader nonnull input stream in nullable ? pushback reader clazz i o invocation target no such instantiation illegal access native2 a s c i i reader in clazz members instance variables charset encoder ascii encoder charset name a s c i i encoder charset encoding ascii encoding charset encoding a s c i i native2 a s c i i reader filter reader native2 a s c i i reader nonnull input stream in permissive i o pushback reader iso 8859 1 encoding get text reader in 5 in pushback reader in permissive permissive native2 a s c i i reader nonnull input stream in permissive nullable ? pushback reader clazz i o no such invocation target illegal access instantiation clazz ? pushback reader iso 8859 1 encoding get text reader in 5 clazz get constructor reader instance iso 8859 1 encoding get text reader in 5 in pushback reader in permissive permissive override read i o delegate read to the i s o 8859 1 result in read does not start escape sequence or is escaped e o f which is signalled by 1 is also captured result ! \\ || escaped escaped result check following character read in read e o f reached read 1 result not an escape sequence read ! u escaped in unread read result read in remainder of possible escape sequence escape u \0 \0 \0 \0 read 1 + in read escape 1 4 e o f reached during escape sequence read 0 permissive escaped in unread u result malformed input 1 read 5 doesn t necessarily mean e o f but could also mean no more input available currently so to read on read 5 read2 in read escape read 5 read we have really hit e o f so there is not enough input an escape sequence read2 1 permissive escaped in unread escape 0 read result malformed input 1 read + read2 no unicode escape with non hex characters in positions 3 6 i 1 i 5 i++ e escape i ! e 0 e 9 || e a e f || e a e f permissive escaped in unread escape 0 read result malformed input 1 valid unicode escape escaped parse escape 1 4 16 override read buffer target i o len target remaining cbuf len n read cbuf 0 len n 0 target put cbuf 0 n n override read cbuf i o read cbuf 0 cbuf length override read cbuf off len i o readn cbuf off len readn cbuf off len i o read 5 chars more than requested to have more input last character is a \ buf len len + 5 buf buf len delegate read to the i s o 8859 1 read in read buf e o f reached read 1 read read read from underlying stream result read after conversion result 0 how many additional characters need to be read because of collapsed escape sequences needed 0 iterate read chars but maximum len ones i outer i 0 i read i len i++ character under consideration c buf i does not start escape sequence c ! \\ || escaped add to result buffer and to next character escaped cbuf off + result++ c less than 5 characters left after current position because either there was no more input available or because of e o f read i 1 5 to read in more characters to complete the escape sequence read i + 1 + 5 read in missing characters read2 in read buf read i + 1 + 5 read e o f reached read2 1 add to result buffer and to next character permissive or e o f reached after backslash or not an escape sequence otherwise permissive || read i 1 0 || buf i + 1 ! u escaped cbuf off + result++ c outer malformed input 1 read + read2 no unicode escape without u at second position buf i + 1 ! u add to result buffer and to next character escaped cbuf off + result++ c no unicode escape with non hex characters in positions 3 6 j i + 2 j2 i + 6 j j2 j++ e buf j ! e 0 e 9 || e a e f || e a e f add to result buffer and to next character permissive otherwise permissive escaped cbuf off + result++ c outer malformed input 1 valid unicode escape escaped cbuf off + result++ parse buf i + 2 4 16 need 5 more chars that were consumed escape collapsing but only the escape sequence was not in the additional space needed + math min len i 1 5 advance pointer i + 5 in unread buf i read i nothing was collapsed needed 0 result read more chars due to escape collapsing read readn cbuf off + result needed e o f reached read 1 result result + read override skip to skip i o to skip 0 illegal argument skip value is negative skip buffer size math min to skip m a x s k i p b u f f e r s i z e skip buffer || skip buffer length skip buffer size skip buffer skip buffer size remaining to skip in remaining 0 skipped read skip buffer 0 math min remaining skip buffer size skipped 1 remaining skipped to skip remaining members m a x s k i p b u f f e r s i z e 8192 encoding iso 8859 1 encoding charset encoding i s o 8859 1 instance variables pushback reader in permissive skip buffer escaped 